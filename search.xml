<?xml version="1.0" encoding="UTF-8"?>
<search>
  <entry>
    <title>2025-2026年学习日志——备用存档</title>
    <content>自用的学习路径和备份笔记


ai推荐版学习路径规划## 第一阶段：美术与设计基础### 学习目标：1. 掌握色彩理论和搭配技巧，能够为二次元风格网站选择合适的配色方案。2. 学习美术基础理论，如构图、透视、光影等，提升界面设计的视觉表现力。3. 掌握UI设计原则和UX设计方法，能够设计出既美观又易用的界面。### 学习内容：- **色彩搭配**：  - 学习色轮、色彩关系（对比色、类似色等）  - 学习色彩心理学，了解不同色彩对用户情绪的影响  - 使用工具如Adobe Color、Coolors进行配色练习- **美术理论**：  - 构图原则（如三分法、对称、平衡）  - 光影基础，理解高光、阴影、反射  - 透视基础，一点透视、两点透视- **UI/UX设计**：  - 学习Material Design、iOS设计规范  - 学习界面布局、组件设计、图标设计  - 学习用户体验设计流程，包括用户研究、信息架构、交互设计、可用性测试- **工具学习**：  - **Figma**：深入学习组件、自动布局、原型设计、团队协作  - **蓝湖**：学习标注、切图、与开发协作  - **PS基础**：学习图像处理、调整，用于处理位图素材  - **AI教程**：学习矢量图绘制，制作图标、插画### 推荐资源：- 书籍：《写给大家看的设计书》、《配色设计原理》- 在线课程：站酷高高手、UI中国上的相关课程- 实践：模仿优秀二次元风格网站的设计，进行重设计练习## 第二阶段：前端基础巩固与进阶### 学习目标：1. 学习HTML、CSS、JavaScript，达到熟练水平。2. 学习CSS预处理器Less，掌握嵌套、变量、混合等特性。3. 学习Tailwind CSS，能够快速构建自定义样式的界面。4. 学习Canvas基础，能够实现简单的动态效果。5. 学习Vue.js框架，掌握组件化开发。### 学习内容：- **HTML/CSS/JS巩固**：  - 深入理解HTML5语义化、CSS3新特性（渐变、动画、变形等）  - JavaScript高级特性：闭包、原型链、异步编程（Promise、async/await）  - 学习ES6+语法，如箭头函数、模块化、解构等- **Less**：  - 变量、混合、嵌套、运算、函数  - 使用Less编写可维护的CSS代码- **Tailwind CSS**：  - 学习实用优先的原子化CSS理念  - 掌握Tailwind的响应式设计、深色模式等  - 结合Vue.js使用Tailwind- **Canvas**：  - 学习Canvas API，绘制图形、文本、图像  - 实现简单的动画和交互  - 学习使用Canvas库，如Konva.js，提高开发效率- **Vue.js**：  - Vue基础：指令、计算属性、组件、生命周期  - Vue Router：路由管理  - Vuex：状态管理  - 学习Vue3的Composition API### 推荐资源：- 书籍：《JavaScript高级程序设计》、《Vue.js设计与实现》- 在线课程：Vue官方教程、Tailwind CSS官方文档- 实践：使用Vue+Tailwind CSS重构之前设计的界面## 第三阶段：高级前端技术### 学习目标：1. 学习Three.js，能够在网页中创建3D场景。2. 学习Live2D，制作动态看板娘。3. 学习Git高级用法，掌握团队协作流程。### 学习内容：- **Three.js**：  - 学习3D图形学基础概念：场景、相机、渲染器、几何体、材质、光照  - 加载3D模型，添加交互  - 与Vue.js结合使用- **Live2D**：  - 学习Live2D Cubism SDK，了解模型导入和驱动  - 在网页中嵌入Live2D模型，实现交互（如鼠标跟随、点击动作）- **Git高级**：  - 分支管理（git flow）、合并冲突解决、标签管理  - 与团队协作：Pull Request、Code Review### 推荐资源：- Three.js：官方文档、Three.js Journey课程（付费但优秀）- Live2D：官方文档、GitHub上的开源项目（如CubismWebSamples）- Git：Pro Git书籍、Git官方文档## 番外：Hexo主题开发与部署### 学习目标：1. 掌握Hexo主题开发流程，能够独立开发自定义主题。2. 学习Linux服务器基础，能够部署Hexo博客。3. 学习TCP/IP等网络协议基础，了解HTTP/HTTPS。### 学习内容：- **Hexo主题开发**：  - 学习Hexo主题结构：layout、partial、helper等  - 使用EJS或Pug模板引擎  - 编写自定义的CSS和JavaScript  - 实现主题配置化- **Linux服务器部署**：  - 学习Linux基础命令  - 学习Nginx配置，部署静态网站  - 学习使用Git进行自动化部署  - 学习域名解析、SSL证书配置（HTTPS）- **网络协议**：  - 学习TCP/IP模型，了解HTTP/HTTPS协议  - 学习DNS、CDN等概念### 推荐资源：- Hexo：官方文档、开源主题源码（如NexT）- Linux：鸟哥的Linux私房菜、Linux命令行与Shell脚本编程大全- 网络协议：《图解HTTP》、《TCP/IP详解 卷1》## 第四阶段：持续学习与独立制作并项目实践### 学习目标：1. 整合所学知识，完成一个完整的二次元风格Hexo主题。2. 不断优化，添加更多趣味功能（如小游戏、音效、动画等）。3. 学习辅助工具，提高开发效率。### 学习内容：- **项目实践**：  - 设计并开发多个完整的网站主题  - 实现响应式设计，适配移动端  - 添加动画效果（CSS动画、GSAP、Canvas动画）  - 集成Live2D看板娘  - 优化性能，提高加载速度- **辅助工具**：  - **AI工具**：使用ChatGPT、Copilot辅助编程和设计  - **设计资源**：使用IconFont、Unsplash、Pixiv等获取素材  - **开发工具**：使用VSCode插件、Chrome开发者工具、Webpack等  - **效率工具**：使用Notion、Trello进行任务管理### 推荐资源：- 参与开源项目，贡献代码或设计- 关注前端和设计领域的博客、大会（如CSSConf、VueConf）- 不断挑战更复杂的项目，如WebGL游戏、可视化项目等## 工具推荐汇总### 设计工具：- Figma：UI设计、原型设计- 蓝湖：标注、切图、协作- Adobe Photoshop：图像处理- Adobe Illustrator：矢量图绘制- After Effects：动效设计- Live2D Cubism：2D角色模型制作### 开发工具：- VS Code：代码编辑器- Git：版本控制- Node.js：JavaScript运行环境- Vite：前端构建工具- Webpack：模块打包- Chrome DevTools：调试### 辅助工具：- ChatGPT：代码和设计建议- GitHub Copilot：代码自动补全- Notion：知识管理和项目规划- Trello：任务管理- IconFont：图标资源- Unsplash：免费图片- Pixiv：二次元插图### 部署运维：- Linux服务器（如Ubuntu）- Nginx：Web服务器- Let&amp;#x27;s Encrypt：免费SSL证书- GitHub Actions：自动化部署



分类规划美术基础 → UI/UX设计 → 前端技术 → 高级交互 → 部署运维   ↓         ↓           ↓          ↓          ↓色彩理论  Figma/PS     Vue3/TS   Canvas     Linux构图基础  组件系统    Tailwind   Three.js   Nginx矢量绘制  交互原型    Node.js    Live2D      CI/CD



工具备用UI&amp;#x2F;UX设计
Figma - 主UI设计工具（团队协作、设计系统、原型）
Adobe Photoshop - 图像处理、合成、调色
Adobe Illustrator - 矢量图形、图标设计、插画
Adobe XD - 备用UI设计工具（特别适合原型制作）
Principle - 交互动效设计
Protopie - 高级交互原型（支持逻辑判断）
After Effects - 复杂动效制作、Lottie动画输出
Zeplin - 设计稿交付、标注（开发者友好）
Avocode - 设计稿切图、CSS代码生成
Abstract - Figma&amp;#x2F;Sketch版本控制（团队协作）
InVision - 设计演示与协作

前端技术
Node.js - JavaScript运行时
pnpm - 高效包管理器（推荐）
Yarn - 包管理器备选
npm - Node包管理器

高级交互
Three.js Editor - 在线Three.js编辑器
Spline - 在线3D设计工具
WhatFont Tool - 网页字体识别
FontBase - 字体管理器
SonarLint - 代码质量分析
CodeClimate - 代码质量平台

部署运维</content>
    <url>/2025/09/04/2025-2026%E5%B9%B4%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97%E2%80%94%E2%80%94%E5%A4%87%E7%94%A8%E5%AD%98%E6%A1%A3/</url>
  </entry>
  <entry>
    <title>Ayer主题修复图片显示</title>
    <content>起因是我突然发现，我目前使用的这个博客网站的图片无法显示了，查阅了原主题作者的开源链接，Ayer，发现原作者已经在2022年就停止更新，图片无法显示的问题一直没能修复。查阅了一年以来的fork也没有人解决这个问题，于是我出手了（不是）
我也fork了原主题项目，更名为Ayerr，开始bug修复和高强度自定义设置，打算以后一直更新下去。
总之这是一篇更新日志，v1.0，来记录这个衍生主题Ayerr的首次更新：修复原主题Ayer无法显示图片的问题。
✨ 同时也欢迎一起更新！项目地址：https://github.com/Morlvoid/hexo-theme-ayerr


为 Hexo 主题 Ayer 修复图片显示问题1. 修复内容说明1.1 问题描述Ayer 主题原作者已经停止更新，主题中存在图片显示问题，无法正常使用 &amp;#123;% asset_img %&amp;#125; 标签和传统 Markdown 语法添加图片。
1.2 修改文件列表


文件路径
修改内容



scripts/asset-image.js
新增文件，实现 &amp;#123;% asset_img %&amp;#125; 标签支持


README.md
更新文档，添加图片使用说明


package.json
更新主题名称和相关信息


_config.yml
更新配置，简化菜单


1.3 核心修复代码scripts&amp;#x2F;asset-image.js// 注册 &amp;#123;% asset_img %&amp;#125; 标签 const &amp;#123; join &amp;#125; = require(&amp;#x27;path&amp;#x27;); hexo.extend.tag.register(&amp;#x27;asset_img&amp;#x27;, function(args) &amp;#123;     // 解析参数，例如：&amp;#123;% asset_img demo.jpg &amp;quot;图片描述&amp;quot; %&amp;#125;     const img = args[0];     const alt = args.slice(1).join(&amp;#x27; &amp;#x27;) || &amp;#x27;&amp;#x27;; // 支持带空格的描述文字         // 获取当前上下文     const ctx = this;     let imgPath = img;         // 如果是绝对路径或外部链接，直接返回     if (/^(?:https?:\/\/|\/)/.test(img)) &amp;#123;         return `&amp;lt;img src=&amp;quot;$&amp;#123;img&amp;#125;&amp;quot; alt=&amp;quot;$&amp;#123;alt&amp;#125;&amp;quot; class=&amp;quot;article-img&amp;quot;&amp;gt;`;     &amp;#125;         // 构建正确的图片路径     // 对于文章资源，使用相对路径     const post = ctx.post || ctx.page;     if (post &amp;amp;&amp;amp; post.asset_dir) &amp;#123;         // 对于文章内的资源，直接使用文件名即可，Hexo 会自动处理路径         imgPath = img;     &amp;#125;         // 手动构建图片 URL，避免使用可能出现问题的 url_for 辅助函数     // 直接使用根路径 + 资源路径     const src = hexo.config.root + imgPath;         // 返回标准的 img HTML 标签     return `&amp;lt;img src=&amp;quot;$&amp;#123;src&amp;#125;&amp;quot; alt=&amp;quot;$&amp;#123;alt&amp;#125;&amp;quot; class=&amp;quot;article-img&amp;quot;&amp;gt;`; &amp;#125;, &amp;#123;async: false, ends: false&amp;#125;);

2. 修复后的新主题 Ayerr 安装使用2.1 安装方法方法一：直接克隆源代码后移动到theme文件夹中git clone https://github.com/Morlvoid/hexo-theme-ayerr.git themes/ayerr

方法二：手动下载
从 GitHub 下载主题压缩包
解压到 themes/hexo-theme-ayerr 目录

2.2 启用主题修改博客根目录的 _config.yml 文件：
theme: hexo-theme-ayerr

2.3 基本配置启用文章资源文件夹：修改博客根目录的 _config.yml 文件：
post_asset_folder: true

修改theme文件夹下的hexo-theme-ayerr根目录的 _config.yml 文件：
post_asset_folder: true

2.4 更新主题cd themes/hexo-theme-ayerrgit pull

3. 修复后添加图片的方法修复图片显示问题后，有两种方法可以为博客添加图片：
3.1 方法一：使用 asset_img 标签语法格式&amp;#123;% asset_img 图片文件名 &amp;quot;图片描述&amp;quot; %&amp;#125;

使用示例&amp;#123;% asset_img demo.png &amp;quot;这是使用 asset_img 标签的图片&amp;quot; %&amp;#125;

特点
专为文章资源文件夹设计
自动处理图片路径
生成带有 article-img 类的图片标签
支持带空格的描述文字
无需手动拼接图片路径

3.2 方法二：使用传统 Markdown 语法语法格式![图片描述](图片文件名)

使用示例![这是使用传统 Markdown 语法的图片](demo.png)

特点
标准 Markdown 语法，兼容性好
简洁易记
自动处理文章资源文件夹中的图片
支持描述文字

3.3 图片存放位置将图片放在与文章同名的资源文件夹中，例如：
source/_posts/├── test.md└── test/    └── demo.png

如果要在其他页面中存，例如about.html，也需要新建一个与index同名的文件夹，例：
source/about/├── index.md└── index/    └── demo.png

3.4 注意事项
图片格式：支持常见的图片格式，如 PNG、JPG、GIF 等
图片尺寸：建议使用适当尺寸的图片，避免过大影响加载速度
图片命名：避免使用中文和特殊字符，建议使用英文和数字
启用文章资源文件夹：确保在博客根目录的 _config.yml 中启用 post_asset_folder: true

4. 修复效果验证4.1 生成测试hexo cleanhexo g

4.2 服务器测试hexo s

4.3 预览效果
✅ &amp;#123;% asset_img %&amp;#125; 标签正常工作
✅ 传统 Markdown 语法正常工作
✅ 图片 URL 格式正确
✅ 图片显示样式优化

5. 主题特色5.1 新增功能
✅ 修复了图片显示问题
✅ 支持 &amp;#123;% asset_img %&amp;#125; 标签
✅ 支持传统 Markdown 语法
✅ 优化了图片显示样式
✅ 简化了侧边栏菜单

5.2 主题配置
支持响应式设计
支持多语言
支持黑夜模式
支持代码复制功能
支持文章字数统计
支持多种评论系统

6. 常见问题6.1 图片不显示怎么办？
检查文章资源文件夹是否启用
检查图片是否放在正确的资源文件夹中
检查图片路径是否正确
清理缓存并重新生成

6.2 如何添加多个图片？&amp;#123;% asset_img demo1.png &amp;quot;图片 1&amp;quot; %&amp;#125;&amp;#123;% asset_img demo2.png &amp;quot;图片 2&amp;quot; %&amp;#125;&amp;#123;% asset_img demo3.png &amp;quot;图片 3&amp;quot; %&amp;#125;

6.3 如何调整图片大小？可以在 Markdown 中直接添加 HTML 标签：
&amp;lt;img src=&amp;quot;demo.png&amp;quot; alt=&amp;quot;图片&amp;quot; style=&amp;quot;width: 50%;&amp;quot;&amp;gt;

7. 贡献与反馈
项目地址：https://github.com/Morlvoid/hexo-theme-ayerr
欢迎提交 Issue 和 Pull Request
如有问题，可在 GitHub 上创建 Issue 反馈

8. 许可证本项目基于原作者的 SATA 许可证，在遵守 MIT 许可证的前提下，你应该马不停蹄的给这个开源项目“点个赞”，比如 github 右上角的 star，然后你应该感谢这个开源项目的作者。

修复人：Morlvoid修复时间：2026-01-14
</content>
    <url>/2026/01/14/Ayer%E4%B8%BB%E9%A2%98%E4%BF%AE%E5%A4%8D%E5%9B%BE%E7%89%87%E6%98%BE%E7%A4%BA/</url>
  </entry>
  <entry>
    <title>Exercism.org-Java-Cook your lasagna</title>
    <content>Exercism.org-Java-Cook your lasagna
https://exercism.org/tracks/java/exercises/lasagna


InstructionsIn this exercise you’re going to write some code to help you cook a brilliant lasagna from your favorite cooking book.
You have four tasks, all related to the time spent cooking the lasagna.
1. Define the expected oven time in minutesDefine the expectedMinutesInOven() method that does not take any parameters and returns how many minutes the lasagna should be in the oven. According to the cooking book, the expected oven time in minutes is 40:
Lasagna lasagna = new Lasagna();//Create a Lasagna object using the new keywordlasagna.expectedMinutesInOven();//Invoking the expectedMinutesInOven() method in the Lasagna// =&amp;gt; 40

2. Calculate the remaining oven time in minutesDefine the remainingMinutesInOven() method that takes the actual minutes the lasagna has been in the oven as a parameter and returns how many minutes the lasagna still has to remain in the oven, based on the expected oven time in minutes from the previous task.
Lasagna lasagna = new Lasagna();lasagna.remainingMinutesInOven(30);//Invoking the remainingMinutesInOven() method in the Lasagna// =&amp;gt; 10

3. Calculate the preparation time in minutesDefine the preparationTimeInMinutes() method that takes the number of layers you added to the lasagna as a parameter and returns how many minutes you spent preparing the lasagna, assuming each layer takes you 2 minutes to prepare.
Lasagna lasagna = new Lasagna();lasagna.preparationTimeInMinutes(2);// =&amp;gt; 4

4. Calculate the total working time in minutesDefine the totalTimeInMinutes() method that takes two parameters: the first parameter is the number of layers you added to the lasagna, and the second parameter is the number of minutes the lasagna has been in the oven. The function should return how many minutes in total you’ve worked on cooking the lasagna, which is the sum of the preparation time in minutes, and the time in minutes the lasagna has spent in the oven at the moment.
Lasagna lasagna = new Lasagna();lasagna.totalTimeInMinutes(3, 20);// =&amp;gt; 26

Question Answerspublic class Lasagna &amp;#123;    // TODO: define the &amp;#x27;expectedMinutesInOven()&amp;#x27; method    public int expectedMinutesInOven()&amp;#123;        return 40;    &amp;#125;    // TODO: define the &amp;#x27;remainingMinutesInOven()&amp;#x27; method    public int remainingMinutesInOven(int time)&amp;#123;        return expectedMinutesInOven() - time;    &amp;#125;    // TODO: define the &amp;#x27;preparationTimeInMinutes()&amp;#x27; method    public int preparationTimeInMinutes(int layers)&amp;#123;        return layers*2;    &amp;#125;    // TODO: define the &amp;#x27;totalTimeInMinutes()&amp;#x27; method    public int totalTimeInMinutes(int layers,int time)&amp;#123;        return preparationTimeInMinutes(layers)+remainingMinutesInOven(time);    &amp;#125;&amp;#125;


Word
Instructionsn.(计算机的)指令;指示;说明书;命令;操作指南;吩咐;用法说明instruction的复数


brilliantadj.明亮的;很成功的;很好的;巧妙的;聪颖的;技艺高的;使人印象深的n.宝石;钻石


lasagnan.(意大利)千层面


taskn.任务;(尤指艰巨或令人厌烦的)工作;(尤指语言教学中旨在帮助达到某一学习目的的)活动vt.交给某人(任务);派给某人(工作)


relatevt.联系;讲(故事);把…联系起来;叙述;使有联系;讲述


expectv.预期;预计;期待;要求;指望;预料;等待;盼望;猜想


expectedadj.预期的;预料的v.预期;预计;期待;要求;指望;预料;等待;盼望expect的过去分词和过去式


ovenn.烤箱;烤炉


remainingadj.剩下的;仍需做的;还需处理的v.仍然是;剩余;保持不变;遗留;继续存在;仍需去做(或说、处理)remain的现在分词


actualadj.实际的;(强调事情最重要的部分)真正的，…本身;真实的


remainv.（事实、问题等）仍然是（表示强调）;剩余，余留;保留，坚持（观点、态度或信念）;保持不变;仍然存在，继续存在;留下，逗留，停留;（最后）属于;（最后）取决于;尚待，留待;仍需去做（或说、处理）n.剩余物，残余（物）;遗体，残骸;（历史）遗迹，残迹


previousadj.以前的, 先前的, 以往的;上一次的, 上一个的;&amp;lt;口&amp;gt;过早的, 过急的;(时间上)稍前的


preparationn.准备;(医药、化妆品等)配制品，制剂;准备工作;预备


layersn.层;表层;层次;阶层v.把…分层堆放layer的第三人称单数和复数


assumingconj.假如;假设…为真v.假设;假定;承担(责任);认为;呈现(外观、样子);取得(权力);显露(特征);就(职)adj.傲慢的assume的现在分词

</content>
    <url>/2023/08/09/Exercism-org-Java-Cook-your-lasagna/</url>
  </entry>
  <entry>
    <title>Exercism.org-Java-Annalyn&apos;s Infiltration</title>
    <content>Exercism.org-Java-Annalyn’s Infiltration
https://exercism.org/tracks/java/exercises/annalyns-infiltration


InstructionsIn this exercise, you’ll be implementing the quest logic for a new RPG game a friend is developing. The game’s main character is Annalyn, a brave girl with a fierce and loyal pet dog. Unfortunately, disaster strikes, as her best friend was kidnapped while searching for berries in the forest. Annalyn will try to find and free her best friend, optionally taking her dog with her on this quest.
After some time spent following her best friend’s trail, she finds the camp in which her best friend is imprisoned. It turns out there are two kidnappers: a mighty knight and a cunning archer.
Having found the kidnappers, Annalyn considers which of the following actions she can engage in:

Fast attack: a fast attack can be made if the knight is sleeping, as it takes time for him to get his armor on, so he will be vulnerable.
Spy: the group can be spied upon if at least one of them is awake. Otherwise, spying is a waste of time.
Signal prisoner: the prisoner can be signalled using bird sounds if the prisoner is awake and the archer is sleeping, as archers are trained in bird signaling, so they could intercept the message.
Free prisoner: Annalyn can try sneaking into the camp to free the prisoner. This is a risky thing to do and can only succeed in one of two ways:
If Annalyn has her pet dog with her she can rescue the prisoner if the archer is asleep. The knight is scared of the dog and the archer will not have time to get ready before Annalyn and the prisoner can escape.
If Annalyn does not have her dog then she and the prisoner must be very sneaky! Annalyn can free the prisoner if the prisoner is awake and the knight and archer are both sleeping, but if the prisoner is sleeping they can’t be rescued: the prisoner would be startled by Annalyn’s sudden appearance and wake up the knight and archer.



You have four tasks: to implement the logic for determining if the above actions are available based on the state of the three characters found in the forest and whether Annalyn’s pet dog is present or not.
1. Check if a fast attack can be madeImplement the (static) AnnalynsInfiltration.canFastAttack() method that takes a boolean value that indicates if the knight is awake. This method returns true if a fast attack can be made based on the state of the knight. Otherwise, returns false:
boolean knightIsAwake = true;AnnalynsInfiltration.canFastAttack(knightIsAwake);// =&amp;gt; false

2. Check if the group can be spied uponImplement the (static) AnnalynsInfiltration.canSpy() method that takes three boolean values, indicating if the knight, archer and the prisoner, respectively, are awake. The method returns true if the group can be spied upon, based on the state of the three characters. Otherwise, returns false:
boolean knightIsAwake = false;boolean archerIsAwake = true;boolean prisonerIsAwake = false;AnnalynsInfiltration.canSpy(knightIsAwake, archerIsAwake, prisonerIsAwake);// =&amp;gt; true

3. Check if the prisoner can be signalledImplement the (static) AnnalynsInfiltration.canSignalPrisoner() method that takes two boolean values, indicating if the archer and the prisoner, respectively, are awake. The method returns true if the prisoner can be signalled, based on the state of the two characters. Otherwise, returns false:
boolean archerIsAwake = false;boolean prisonerIsAwake = true;AnnalynsInfiltration.canSignalPrisoner(archerIsAwake, prisonerIsAwake);// =&amp;gt; true

4. Check if the prisoner can be freedImplement the (static) AnnalynsInfiltration.canFreePrisoner() method that takes four boolean values. The first three parameters indicate if the knight, archer and the prisoner, respectively, are awake. The last parameter indicates if Annalyn’s pet dog is present. The method returns true if the prisoner can be freed based on the state of the three characters and Annalyn’s pet dog presence. Otherwise, it returns false:
boolean knightIsAwake = false;boolean archerIsAwake = true;boolean prisonerIsAwake = false;boolean petDogIsPresent = false;AnnalynsInfiltration.canFreePrisoner(knightIsAwake, archerIsAwake, prisonerIsAwake, petDogIsPresent);// =&amp;gt; false


Question Answersclass AnnalynsInfiltration &amp;#123;    public static boolean canFastAttack(boolean knightIsAwake) &amp;#123;        return !knightIsAwake;    &amp;#125;    public static boolean canSpy(boolean knightIsAwake, boolean archerIsAwake, boolean prisonerIsAwake) &amp;#123;        return knightIsAwake || archerIsAwake || prisonerIsAwake;    &amp;#125;    public static boolean canSignalPrisoner(boolean archerIsAwake, boolean prisonerIsAwake) &amp;#123;        return prisonerIsAwake &amp;amp;&amp;amp; !archerIsAwake;    &amp;#125;    public static boolean canFreePrisoner(boolean knightIsAwake, boolean archerIsAwake, boolean prisonerIsAwake, boolean petDogIsPresent) &amp;#123;        return (prisonerIsAwake &amp;amp;&amp;amp; !archerIsAwake &amp;amp;&amp;amp; !knightIsAwake) || (!archerIsAwake &amp;amp;&amp;amp; petDogIsPresent);    &amp;#125;&amp;#125;



Word
representedv.代表，表示;（在竞赛或体育赛事中）代表（国家或地区）;（标志或符号）意味着，代表着，标志着;描绘，（形象地）表现，描写;代理（个人或团体）;代表（个人或团体）出席;使有代表性，使有代表作;使呈现;陈述，诉说;象征;展示;相当于，相等于;作为……的代表（代言人）;表述;想象，设想;演出，扮演;提出异议，提出抗议;维护……的利益;回想;再提出;作为……的象征;典型地反映;成为……实例，成为典型;再呈现;抗议说;再递交;再上演，再演出;集中地体现;再赠送


implementvt.实施;执行;贯彻;使生效n.工具;器具;(常指)简单的户外用具


implementingv.实施;执行;贯彻;使生效implement的现在分词


questn.追求(幸福等);探索;寻找vi.探索;探求


logicn.逻辑;逻辑学;(做某事的)道理，合乎情理的原因;逻辑系统;思维方式;解释方法


developv.发展;发展，变化;开发;加强;研制;出现(问题);使（胶卷）显影;(使)成长;壮大; 患(病);修建;详尽阐述;(问题)开始影响;(疾病)开始侵袭


developingadj.发展中的v.(使)成长，发展，壮大;开发;研制;出现(问题); 患(病);(问题)开始影响;(疾病)开始侵袭develop的现在分词


Unfortunatelyadv.不幸地;遗憾地;可惜地;可悲地


disastern.灾害;灾难;灾祸;不幸;祸患;彻底失败的人(或事)


striken.罢工;（有损声誉的）不利因素，打击;袭击;(尤指)空袭;打;击;罢课;踢;罢市;全中;军事进攻;（珍贵东西的）意外发现;击球未中v.罢工;撞击;打;击打，踢(球等);击;碰撞;撞;敲;给（某人以…）印象;突击;擦，划（火柴）;行进;侵袭;碰;弹奏;突然想到;照在…上;开采出;顿时使处于某状态


kidnapvt.绑架;劫持;诱拐（小孩等），拐骗n.诱拐;绑架罪


kidnappersn.绑架者；绑匪；拐骗犯kidnapper的复数


berryn.浆果;莓


freeadj.自由的;免费的;空闲的;(货物等) 免税的;自然的, 不拘束的;自愿的, 主动的;未固定的，松开的;不受阻碍的;丰盛的;直爽的, 坦率的;受准许的, 可允许的;(用钱) 大手大脚的adv.自由地;免费地;帆脚索被松开地v.释放;使免于;使可用于;使解脱出来;使能腾出时间


optionallyadv.可选地;随意地


trailv.跟踪;(在比赛或其他竞赛中)落后，失利，失败;追踪;(被)拖，拉;蔓生;(尤指跟在他人后面)疲惫地走，没精打采地慢走，磨蹭n.(乡间的)小路，小径;（特定）路线，路径;(尤指打猎时跟踪的)踪迹，臭迹;(长串的)痕迹，踪迹，足迹


campn.营地;阵营;(尤指政府让人长时间住宿的)营房，营帐;兵营;度假营vi.露营;(尤指在假日)野营;宿营;暂住;借住;借宿adj.夸张的，滑稽可笑的(尤指故意逗笑);做作的;故意带女子气的，女性化的(被某些人认为是典型同性恋的特征)


imprisonvt.监禁;关押


mightyadj.强大的;巨大的;非凡的;强而有力的adv.非常;极其;很


cunningadj.狡猾的;巧妙的;奸诈的;诡诈的;灵巧的;精巧的n.狡猾;狡黠;诡诈


archern.弓箭手;射箭运动员


considerv.考虑;认为;觉得;顾及;(尤指为作出决定而)仔细考虑;以为;细想;体谅;端详


actionn.行动;（身体部位的）动作，功能;作用;行为;诉讼;起诉;战斗;情节;机械装置，活动部件;所做之事;激动人心的事vt.务必做，确保处理(某事)


engagev.从事;（使）衔接，啮合;聘用;雇用;与（某人）交战;吸引住(注意力、兴趣);与…建立密切关系;尽力理解


vulnerableadj.脆弱的;(身体上或感情上)易受…伤害的


attackn.攻击;袭击;(在战争中使用武器的)进攻;（队员等的）进攻;发作，侵袭;（病、虫等的）损害，伤害;(口头和书面的)抨击，非难;抑制;进攻队员;（情感的）一阵突发v.攻击;袭击;(在战争等中使用武器)进攻;抨击;侵袭;非难;奋力处理


armorn.装甲；盔甲v.为…装甲


spyn.间谍;密探;暗中监视v.当间谍;发现，注意到;察看，探查;突然看见，突然发现;仔细观察adj.间谍的，间谍活动的


uponprep.在……上;在上面;刚一……就;即将发生;用在一些动词后，与on 同义;（用于两个相同的名词之间，强调数量之多）（一个）接（一个），……又……adv.在上面，在物体上;从此，因此


signaln.信号;(尤指铁路和公路上的)指示灯，信号灯，红绿灯;标志;预示;暗号v.显示;表示;表明;标志;表达;发信号;示意;预示;发暗号adj.重大的;显要的


prisonern.囚犯;犯人;战俘;俘虏;被(敌人等)关起来的人;羁押候审者


interceptvt.拦截;截住;拦阻n.拦截;（数学）截距;截击;截听;拦截者


trainn.列车;火车;行列;队列;拖裾，裙裾;一系列相关的事情(或行动);列队行进的人(或动物)v.培训;训练(人或动物);教育;进行…训练;接受训练;培养…的能力(或素质);(尤指)进行体育锻炼;使（植物）朝某方向生长


trainedv.培训;训练(人或动物);教育;进行…训练;接受训练;培养…的能力(或素质);(尤指)进行体育锻炼adj.培训；训练过的，受过培训的train的过去分词和过去式


signalingn.打信号，发信号


sneakv.溜;偷走(不重要的或小的东西);偷拿;偷偷地走;偷带;（儿童向成人）打小报告，告状;偷偷地做n.打小报告的人，告状者(尤指儿童)adj.突然的;出其不意的


riskyadj.有风险的;有危险(或风险)的


rescuevt.抢救;营救;援救n.救援;抢救;营救;获救;营救行动


escapev.逃脱，幸免于难;(从不愉快或危险处境中)逃脱;逃避;逃跑;摆脱;(从监禁或管制中)逃走;逃出;避免(不愉快或危险的事物);漏出;被忘掉;（不自觉地）由…发出n.逃脱;逃避;漏出;逃避现实;解脱;Esc键;消遣;渗出(量)


sneakyadj.偷偷摸摸的;鬼鬼祟祟的;悄悄的


rescuedv.抢救;营救;援救rescue的过去分词和过去式


suddenadj.突然的，忽然的;意外的，突然发生的;迅速的，快的;&amp;lt;古&amp;gt;未经事先考虑的，鲁莽的，急速作成的，草率从事的adv.&amp;lt;口&amp;gt;突然地，出乎意料地n.突然发生的事（或情况）


appearancen.出现;外观;外表;外貌;出版;公开露面;(尤指突然的)抵达，到来;起源;首次使用


implementvt.实施;执行;贯彻;使生效n.工具;器具;(常指)简单的户外用具


determiningv.确定;测定;决定;影响;形成;安排;裁决;查明;支配;准确算出adj.决定性的determine的现在分词


determinev.确定;测定;决定;决定，决心（做某事）;影响;形成;安排;裁决;查明;支配;准确算出


availableadj.可获得的;有空的;可购得的;可找到的


presentn.目前;现在;礼物;礼品adj.存在;当前的;出现;出席;在场;现存的vt.提出;(以某种方式)展现，显示，表现;表达，表示;提交;使发生;颁发;交付;授予;把…交给;上演;正式介绍;突然出现;主持播放;正式出席

</content>
    <url>/2023/08/08/Exercism-org-Java-Annalyn-s-Infiltration/</url>
  </entry>
  <entry>
    <title>ACG基础知识补完计划</title>
    <content>省流：近几年自修了动画相关的多个专业，包括动画、数字媒体艺术等，之后还有打算丰富一些游戏设计、艺术科技相关的专业内容，决定写一期简单的ACG科普指南，目前包括：动画史、动画概论、动画剧本、电影史、视听语言、漫画创作、运动规律、数字动画制作等，决定将ACG相关的内容做一些统合与科普。


大纲动漫艺术概论一、动画的本质与定义

基本定义动画是以“逐格拍摄”为技术基础，通过美术形式（绘画、模型、数字建模等）塑造动态影像的视听艺术形式346。
核心原理
视觉暂留（Persistence of Vision）：人眼在光信号消失后仍短暂保留影像（约0.1-0.4秒），使连续帧播放产生运动幻觉34。
运动创造生命：通过赋予静态符号（角色、物体）动作与时间性，实现生命力表达7。




二、动画的本体特征



特性
内涵说明
案例&amp;#x2F;表现



假定性
虚拟形象、动作、环境的非真实性被观众接受为“真实”
《猫和老鼠》物理定律颠覆34


夸张性
情节、造型、动作的极端强化（如速度变形、形态扭曲）
《米老鼠》弹性运动规律46


技术性
依赖工艺技术实现运动（赛璐璐分层、3D骨骼绑定）
皮克斯RenderMan渲染3


时尚性
与流行文化互动（视觉风格、题材选择反映时代思潮）
《蜘蛛侠：平行宇宙》波普艺术风格1


综合性
融合文学、音乐、戏剧、美术等多门类艺术语言
《幻想曲》交响乐动画化6



三、动画叙事类型与形式

小说式叙事
特征：细节堆叠、生活流表达，弱化戏剧冲突
代表作：《岁月的童话》《梦幻街少女》15


戏剧式叙事
特征：二元对立冲突、高潮导向结构，强调视听煽情
代表作：《白雪公主》《埃及王子》1


纪实性叙事
特征：基于真实事件，强化时代背景可信度
代表作：《萤火虫之墓》《种树的人》1


抽象性叙事
特征：弱化情节，强调视觉韵律与诗意隐喻
代表作：《线与色的即兴诗》（先锋实验动画）15




四、动画分类体系
（一）按传播媒介



类型
特点
代表作品



影院动画
90-120分钟；制作精良；戏剧化结构；高成本音乐与明星配音
《狮子王》《千与千寻》34


电视动画
单集10-30分钟；系列化；有限动画技术；强角色IP
《辛普森一家》《海绵宝宝》2


网络动画
碎片化时长；互动性；UGC创作；风格多元化
《罗小黑战记》《中国唱诗班》3


（二）按制作工艺

平面动画：手绘（单线平涂）、剪纸（《猪八戒吃西瓜》）、沙动画24
立体动画：偶动画（黏土、布偶）、实物动画（材料实验）2
数字动画：
2D（Flash&amp;#x2F;TVPaint）：《小美人鱼》（计算机上色革新）6
3D（CG建模）：《玩具总动员》（首部全3D长片）36




五、动画发展关键史
（一）技术里程碑

1877年：埃米尔·雷诺改进活动视镜 → 动画之父15
1914年：赛璐璐胶片发明（伊尔·赫德） → 分层制作效率革命36
1928年：《蒸汽船威利》（迪士尼） → 首部同步有声动画15
1995年：《玩具总动员》（皮克斯） → 全3D长片起点36

（二）艺术运动与国家学派



流派
代表国家&amp;#x2F;地区
美学特征
代表人物&amp;#x2F;作品



美国主流
美国
歌舞剧结构；符号化造型；大团圆结局
迪士尼《美女与野兽》46


中国学派
中国
水墨&amp;#x2F;剪纸民族化；文学改编；“以形写神”
《大闹天宫》《山水情》3


有限动画
日本
低帧率；静态对话帧；电视产业化
手冢治虫《铁臂阿童木》3


欧洲实验
法国&amp;#x2F;捷克
非暴力；悲剧主题；材料创新（针幕&amp;#x2F;沙动画）
诺曼·麦克伦《邻居》3



六、动画创作核心流程

前期设计
导演阐述：创作意图与艺术目标说明书5
造型板：角色转面图&amp;#x2F;比例图&amp;#x2F;服饰分解图5


中期制作
设计稿（Layout）：镜头空间分层与动作规划58
原画（Key Animation）：关键动作设计（角色生命力核心）5
动画（In-between）：补间帧绘制5


后期合成
摄影表：时间轴&amp;#x2F;分层&amp;#x2F;特效指令蓝图5
声音设计：对白（性格化）、音效（空间感）、音乐（抒情&amp;#x2F;象征性）7




七、当代动画前沿议题

技术伦理：AI生成动画的版权争议（如《犬与少年》威尼斯入围短片）
文化表达：
全球化 vs 本土化：如《蜘蛛侠：平行宇宙》非裔拉丁裔主角设定
跨媒介叙事：游戏动画（《赛博朋克2077》边缘行者）与元宇宙应用


产业模式：
流媒体主导制作（Netflix《爱死机》单元剧模式）
中国动画产业政策扶持（2015-2025国漫崛起计划）4



动画剧本
 一、动画剧本的本质与特性

定义与功能

本体定位：动画剧本是以文字构建“动画思维”的蓝图，通过画面叙事创造超现实逻辑的幻想世界17。
核心功能：
奠定视听语言基础（画面、声音、剪辑的文本预演）7；
建立动画特有的“幻想逻辑”（打破物理定律但自洽，如《猫和老鼠》的弹性变形）17。




与实拍剧本的核心差异



维度
实拍剧本
动画剧本



叙事逻辑
遵循现实物理法则
构建幻想逻辑（如角色不死、时空扭曲）3


角色塑造
依赖演员表演
依赖美术造型+动作设计（如《大闹天宫》京剧化动作）1


场景表现
受制于实景限制
无边界想象（如《千与千寻》异世界）4





 二、动画剧本创作核心原理
(一) 主题与结构

主题设计

确立原则：需具象化抽象概念（如《疯狂动物城》用动物城隐喻种族歧视）24。
创新策略：
原型颠覆：重构经典符号（如《怪物史莱克》颠覆公主形象）4；
时空穿越：跨越现实维度强化幻想性（如《蜘蛛侠：平行宇宙》）4。




结构模型

经典三幕式：
graph LRA[开端-建立冲突] --&amp;gt; B[中段-多回合对抗] B --&amp;gt; C[高潮-终极对决] C --&amp;gt; D[结局-命运交代]:cite[2]:cite[7]

动画变体结构：

系列剧：单元独立+主线伏笔（如《海绵宝宝》每集新事件）8；
实验短片：非线性叙事（如《回忆积木小屋》倒叙人生）4。





(二) 角色塑造方法论

角色设计层级



层级
内容
案例参考



外在形象
造型&amp;#x2F;服饰&amp;#x2F;标志性动作
米老鼠手套、悟空虎皮裙1


内在性格
主导性格+矛盾点（如胆小者被迫勇敢）
《驯龙高手》小嗝嗝5


潜史(Backstory)
隐藏背景驱动行为（如《冰雪奇缘》艾莎的童年创伤）3




台词与动作设计

台词原则：符合身份+性格化+潜台词（如《玩具总动员》巴斯光年的太空术语显虚荣）37；
动作逻辑：夸张化但符合角色设定（《猫和老鼠》汤姆变形需基于“猫”的生物学特征）1。



(三) 冲突与悬念机制

冲突类型
外部冲突：角色VS反派&amp;#x2F;环境（如《狮子王》辛巴VS刀疤）7；
内部冲突：自我价值观斗争（如《心灵奇旅》22号厌恶投胎）2。


悬念设计技巧：
信息差：观众知悉角色未知的危险（如《千与千寻》父母变猪而千寻不知）3；
倒计时：限时任务制造紧张感（如《功夫熊猫》太郎越狱倒计时）7。




 三、类型化创作规范
(一) 媒介分类创作要点



类型
剧本核心要求
代表作品分析



影院动画
强视觉奇观+普世主题（合家欢）
《寻梦环游记》亡灵节视觉+家族爱1


电视系列剧
单元闭环+角色IP化（每集独立事件）
《小猪佩奇》家庭场景复用8


网络短片
碎片化叙事+风格化实验
《中国唱诗班》诗画意境4


(二) 改编策略对比



策略
操作方法
案例



忠实原著
保留主线+视觉化文字（如《哈利·波特》神奇动物）
《小蝌蚪找妈妈》水墨还原6


局部创编
抽取元素重构（如角色&amp;#x2F;世界观移植）
《花木兰》迪士尼融合美式幽默6


彻底颠覆
解构原型+反套路（如反派变主角）
《怪物史莱克》童话逆向4



 四、剧本格式与工业化标准

专业格式要素

分场标题：场号. 时空（如：1. 日 内 森林小屋）47；
动作描述：
只写可视行为（❌避免“他想…”）；
分行标注角色动作（如：悟空（跳上云层，挠头张望））7；




创作流程标准化
graph TBA[灵感→编剧阐述] --&amp;gt; B[故事梗概300字]B --&amp;gt; C[分场大纲（无对白）]C --&amp;gt; D[剧本初稿]D --&amp;gt; E[对白精修+动作细化]:cite[3]:cite[5]


五、产业实践与营销策略

IP开发思维
数据化选题：基于受众画像选择题材（如Netflix用大数据定《爱死机》单元主题）5；
跨媒介叙事：剧本预留衍生接口（如《英雄联盟：双城之战》角色可游戏化）5。


剧本销售技巧
提案材料：故事精华叙述（1页）+ 剧本样稿（3-5场关键戏）5；
圈层适配：
少儿向：强角色+低理解门槛（如《喜羊羊》）；
成人向：暗喻社会议题（如《马男波杰克》）57。





汇总动漫艺术概论动画的起源和发展将动画界定为是给儿童看的电影，窄化了动画的艺术空间与社会功能。动画其实只是一种电影类型。
动画的定义常见相关名称“动画”这个名词有许多其他的叫法，例如，卡通，卡通片，美术片，动画片，Animation，Anime。卡通Cartoon，原意是指具有幽默或是讽刺意味的漫画。法国人奥诺雷·杜米埃为讽刺漫画家代表，将政治卡通发展到了艺术的高度。卡通是一种由报纸上多格的政治漫画转化成的绘画形式，主要是对幽默讽刺画的称呼，是以时事或生活实景为主题并运用简单夸张的手法来加以表现的特殊绘画作品。卡通包含壁画，油画，地毯等的草图，底图，也可以指漫画，讽刺画，幽默画。
卡通片是卡通电影的简称，指的是借用风格简练、充满幽默讽刺的绘画语言来讲述故事的非真人电影。美术片是一种特殊形式的电影，是中国动画在“中国学派”时期使用的称呼，主要运用绘画或其他造型艺术的形象（人，动物或其他物体）来表现艺术家的创作意图，是一门综合艺术。美术片是动画片、剪纸片、木偶片和折纸片的总称，也是电影的四大片种之一。实际上我们的美术片更接近广义的Animation。动画片以绘画或其他造型艺术形式作为人物造型和环境空间造型的主要表现手段，不追求故事片的逼真性特点，而是运用夸张、神似、变形的手法，借助于幻想、想象和象征，反映人们的生活、理想和愿望，是一种高度假定性的艺术。一般采用逐格拍摄的方法，把系列分解为若干环节的动作依次拍摄下来，连续放映时便在银幕上产生活动的影像。动画片是集合了绘画、电影、数字媒体、摄影、音乐、文学等众多艺术门类与一身的艺术表现形式。Animation这个英语单词其字源“Anima”拉丁语的意思是“灵魂”，“Animare”则有“赋予生命”的意义，“Animat”用来表示“使……活起来”的意思。Animation包括所有用逐格方式拍摄和制作出来的影像。Animeアニメ是根据日语读音来收录的动画之意。20世纪70年代，日式英语Anime才出现。1992年如今北美最大规模的漫展Anime Expo正式开始举办，Anime一词才开始在欧美地区迅速普及。
动画的起源1.动画的意念动画意念归纳起来，不外乎有两种形式：（1）重叠性绘画（2）连续性绘画
2.动画的雏形16世纪西方首度出现手翻书Flip Book的雏形。1825年，英国医师约翰·A·派里斯创造了“魔术画片”，又名幻盘。1832年，比利时物理学家约瑟夫·普拉托依据“魔术画片”原理发明了“费纳奇镜”，又称“诡盘”“幻透镜”。1834年，英国的威廉·霍尔纳发明了“西洋镜”，又称为“走马盘”。宋代（960-1279年）已有走马灯，当时称“马骑灯”。17世纪，欧洲教士阿瑟纳修斯·科歇尔就发明了幻灯。在中国唐朝发明的皮影戏，其影像的清晰度和精致感不亚于同时期的魔术幻灯。1853年，奥地利的冯·乌其梯奥斯将军制作出活动幻灯，令投影在银幕上的静止绘画活动起来，放映了世界上最早的“动画”。这是动画的雏形，同是也是电影的雏形。1861年，美国费城的科尔曼·塞勒斯为一种特殊的魔术灯申请了专利，叫电影镜。
3.动画（电影）的创想1876年，法国工程师艾米尔·雷诺设计了活动视镜。1879年，艾米尔·雷诺又改进了活动视镜，设计了活动视镜影戏机。1877年至1879年间，英国摄影师埃德沃德·J·迈布里奇发明了“变焦实用镜”，为托马斯·阿尔瓦·爱迪生提供了研究并发明电影的灵感。1888年，艾米尔·雷诺再度改进了设计，申请了光学影戏机的专利。
1894年，法国人让·艾米·勒罗伊在纽约用他制作的“神奇放映机”放映了电影。美国人托马斯·爱迪生也带着十台活动电影放映机在纽约举办了首次商演。活动电影放映机并非投影装置，它是一个大箱子，观众都必须通过一个窥孔观看里面的影像。爱迪生把一系列的发明，包括乔治·伊斯曼发明的底片，进行重组完善、开发利用，直至把他们变成极具商业价值的一个整体。正是爱迪生的发明带来了电影和电影产业的发展。1895年，魔术师乔治·梅里爱制作早期魔术电影，添加各种魔术和表演，创造出那个时代最富想象力的原创电影。1899年，梅里爱制作的7分钟电影《灰姑娘》已经使用到了“多幕剧”的手法讲述完整的故事。梅里爱的得意之作当属1902年的《月球之旅》。动画的产生虽然早于电影，但真正意义的现代动画，是在电影摄影集出现以后才发展起来的。
4.动画的原理1824年，视觉暂留理论，英国科学家彼得·罗杰特为破解“为什么静止的图画能产生运动效果”的难题提供了理论依据。人眼在观察景物时，光信号传入大脑神经，需经过一段短暂的时间，光的作用结束后，视觉形象并不立即消失，这种残留的视觉称为“后像”，视觉的这一现象则被称为“视觉暂留”，是人眼具有的一种性质。1828年， 比利时物理学家约瑟夫·普拉托又发现，形象在视网膜的停留时间根据愿始物象的强度、颜色、光度强弱和历时长短而变化在物体表面照明亮度适中的情况下，形象在视网膜上停留时简为者分之三干四秒，这是视觉生理作用的效果。“视觉暂留”是动画生成的理论基础，也是发明电影的理论基础。1829年，约瑟夫·普拉托实验证明:物象停滞的时间一般为0.1~0.4秒。1870年，悬空载运理论，英国人埃德沃德·迈布里奇是最早探索摄影瞬间性的摄影师，连续使用摄影证明马在飞奔的过程中，某一时间四蹄会全部悬空。1973年，法国科学家文提安·朱尔斯·马莱在其撰写的《动物机理》一书中提出“悬空载运’。1877年,埃德沃德·迈布里奇通过拍摄斯坦福的赛马“奥克斯登”的运动照片证明了“悬空载运”。1912年，格式塔心理学派的奠基人之一马克思·韦特海默发表了他的《运动知觉的研究》，这篇关宇似动现象的经典奢作，经过很多次的实验得出结论”运动是种知觉心理现象。此种知觉现象的特征是。知觉是整体的体验，而非感觉的组合。运动的感知是伴随非常小的点间隔而获得的，也就成为“短程似动”。似动现象是人眼视觉的一种心理作用。
5.动画的诞生1906年， 美国人詹姆斯.斯图尔特布莱克顿制作出一部接近现代动画概念的影片，片名叫《滑稽脸的幽默相》。他使用了“剪纸”的手法。这出粉笔脱口秀被公认为是世界上第一部动画影片。1908年，法国人埃米尔.柯尔首创用负片制作动画影片，他运用摄影机上的停格技术拍摄了世界上第一部动画系列影片《幻影集》。也是第一个利用遮幕摄影结合动画和真人动作的先驱，被奉为当代动画片之义。1907年，美国入温瑟。麦凯选用了《睡梦乡中的小尼莫》中的几个角色，工画了4000张图画，一一拍摄下来，再用手工底片一一着色。1911年，动画片《小尼莫》首次在美国电影院上映。这是迄今为止世界上公认的第一部像样的动画短片。
动画的特征动画的特殊记录方式：影像是用电影胶片或录影带以逐格记录的方式制作出来的。动画影像的“动作”是创造出来的幻觉，而不是原本存在的。
动画与相关艺术动画带有多门艺术的“遗传因子”，反映了艺术门类间的交叉和融合的轨迹，是一门结合视觉与听觉以及相关艺术门类形式与内容的综合艺术。
1.动画与美术动画片属于电影范畴，但电影与美术又是两种不同的艺术形式，所以美术创作和动画片创作的艺术思维既有共性又有区别。动画与美术的共性：动画与没事一样都来源于生活，反映生活。他们受到社会历史条件的影响和制约，并受到一定的社会政治、哲学美学和文艺思潮的影响，所以在他们的发展中，会出现各种思潮和流派。他们的发展都是以一定的经济条件为基础，同时又不可避免地受到民族性等上等建筑的制约，所以均有一定的教化意义。美术与动画都是视觉艺术，他们有着共同的审美特征。动画包括了美术的各种艺术形态，它以美术为一定的表现手段，是各种视觉形象的体现。动画与美术的区别：1）表现方式：美术作品表现的是事物的瞬间形象，是静态的。相对美术作品的“静止”“瞬间”，动画表现的是“运动”“发展”。通过摄像机连续放映动画片。2）感知方式：美术作品都是静态的，观众欣赏时欣赏角度完全不受限制。动画不能给观众带来这种自由：观众的眼镜受到放映机（准确的说是创作者的意图）的限制，创作者限定了观众观看的内容，也限定了观看角度。观众在美术作品中整个欣赏过程中的参与度较大，创作者通过作品引发观众的联想和感受，从而完成创作意图的传达。动画电影则主要是创作者主观意识的介入，观众的感受很大程度上只能是对创作者感受的理解和认同。3）构成方式：现代的动画电影不再是单纯的视觉艺术，它已成为一种综合性的视听艺术。从构成上看，美术作品中所包含的构图、透视、色彩、造型等元素是在美术本身范畴之内的，而现代动画电影几乎包罗了现有的艺术形式：文学、戏剧、摄影、音乐、服装、化妆等，也包括了美术中的一些构成元素。除此之外，现代动画电影还广泛运用了计算机合成、数码声音等高科技手段。动画还有一个显著的特点，那就是“蒙太奇”的运用，这样使创作者可以按照自己的意图重新拼接时间、空间和事物的发展运动，创造出一种全新的叙事方法。这种特殊的叙事方式区别于其他艺术思维，从而使动画产生了区别于美术的独特魅力。
2.动画与普通电影动画具备了电影最基本的条件——拍摄、洗印、放映。所以说动画是电影范畴内的一种类型。它与纪录片、故事片、实验片共同组成电影的四大片种，但它与广义上的电影又有一定的区别，所以说它属于电影，但又不同于普通电影。1）动画与普通电影的共性：动画与普通电影一样同属于视听艺术，其创作灵感均来源于生活，反映生活。传统艺术一般可分为时间艺术和空间艺术，而动画与电影却把这两者综合了起来。这种综合使得他们能够最大限度地吸收文学、绘画、雕塑、建筑、音乐、戏剧等各门艺术的表现手段和技巧。他们以电影技术为手段，以画面和音响为媒介，在运动的时间和空间里创造形象，并以时空来进行叙事、再现和反映生活。其中的视觉构成、时空形式和蒙太奇手法是他们共同的基本规律，他们都逼真的还原了人类通过器官（视觉或听觉）得到的对生活的感知。普通电影与动画一样都是假定性的，但其最终的目的有本质上的不同：故事电影无论通过什么手段，它的最终目的是造成真实的幻觉；而动画电影的假定性正是出于他的非真实制作手段。其目的是通过自身的感染力，令观众在明知是虚构的情况下依然为之感动。因此动画所付出的努力并不是为了“制造现实”，而是通过其特有的夸张的渲染来超越现实，展现一个与现实不同的梦幻世界。2）动画与普通电影的区别：“画”出来的运动，就决定了它离不开美术思维，形成了动的特殊性：既需要电影思维也需要美术思维，两者缺一不可又有主次之分。一方面作为电影门类的动画，电影思维在创作中占着主导地位，美术思维则属于从属地位，它服从于整体的电影思维。动画中美术思维的全部任务就是为了表现电影思维。造型、构图、色彩等美术创作手段已不再是为美术本身服务，而是根据电影思维的需要，为动画服务。另一方面，美术思维也反作用与电影思维。首先，在动画中，电影思维必须通过美术手段来完成，没有“画”就没有动画；其次，美术思维又给电影思维提供了特殊的、无所不包的存在空间和无所不能的特殊表现手段。在动画中，只要创作者有足够丰富的想象力，一切都可能发生，一切都可能做到。这对于普通电影的思维来说是极大地解放。普通电影有着自己本身的艺术价值，而动画不仅有着普通电影的价值，还有着自身独特的艺术价值。动画将美术这种形式发挥到极致，并将它同电影的形式进行有机结合。
动画的发展动画从无声到有声，从黑白到彩色，从平面到立体，从单一到多元，可以说动画在诞生之后便从没停止过发展的脚步。
1.动画工业的成型1913年，第一间动画公司拉乌·巴瑞工作室在纽约成立，精心为自己的动画片《钉子》设计出动画史上第一套动画定位系统，为以后动画的发展奠定了基础，解决了从开始就困扰动画师们的一个问题：如何使处于某一特定环境下的角色运动起来，却不用每次都把角色和背景重新画一遍。1915年，美国人埃尔·赫德创造了新的动画制作工艺，他先在塑料胶片上画动画片，然后再把塑料胶片上的一幅图片拍摄成动画电影。透明的赛璐珞片取代以往的动画纸。画家可以将人物单独画在赛璐珞片上面而把背景叠在下面拍摄。这样不但节省了很多时间，提高了制作动画片的效率，也扩展了动画片的表现能力。定位系统的发明与赛璐珞片的运用使得动画片的基本拍摄方法就建立起来了。1915年，美国动画家麦克斯·弗莱谢尔发明了转描机，可将真人电影中人物的动作转印在赛璐珞片上。他使用转描机和动画技术创作了《墨水瓶人》和《小丑可可》。
2.两种倾向动画创造艺术观念随着动画片技术的不断成熟逐步确立起来了。法国人埃米尔·柯尔和美国人温瑟·麦凯的作品分别代表了动画发展的不同走向。温瑟·麦凯是在华特·迪士尼之前对动画艺术性及商业化进行建设性探索的功臣。他于1914年创作的真人与动画片合成的影片《恐龙葛蒂》和于1918年创作的第一步部以动画表现的纪录片《路斯坦尼亚号的沉默》都代表了当时动画片艺术的最高水平。动画家埃米尔·柯尔的动画片则致力于动画视觉表现力的挖掘，极富个性和自由创作精髓。随后欧美动画艺术家们分别向这两个方向发展，最后形成两种倾向：一种是以讲故事的方式出现，注重商业效应，这一倾向的动画最后发展成为商业性很强的主流动画片。另一种强调画面感觉，发挥艺术家自己的个性，创作者们把动画当做一门高尚的艺术来潜心追求，这一倾向的动画最后发展为艺术实验短片。
主流动画与非主流动画按照对动画艺术的两种不同倾向以及艺术家的不同追求，动画可分为主流动画与非主流动画。
1.主流动画主流动画是以观众和市场为目标创作的故事类动画片。（1）美国动画的兴起与发展 1911年美国动画家温瑟·麦凯制作出生平第一部动画电影《小尼莫》，后来又完成了《蚊子的故事》，除了表现角色动作外，还具备了故事的结构。1914年，推出著名的代表作《恐龙葛蒂》。他把故事、角色和真人表演安排成互动式情节。1919年拉乌·巴瑞公司的麦克斯·弗莱谢尔创作了《墨水瓶人》和《小丑可可》。1919年派特·苏利文公司出品《猫的闹剧》一举成功。这一时期的动画艺术家还有戴夫·弗莱舍，保罗·泰利，华特·兰兹等人。在20世纪20年代至40年的创作的卡通人物如：大力水手波派，啄木鸟伍迪等至今仍然脍炙人口。1）迪士尼公司。华特·迪士尼公司出品的动画是美国主流动画的主要代表。从了1928年迪士尼制作出了影史上第一部音画同步的有声卡通片《蒸汽船威利》，米老鼠开始成为家喻户晓的人物。1932年推出了世界上第一部彩色卡通片《花与树》，也是世界上第一部获得奥斯卡动画短片奖的影片。1937年，迪士尼拍摄的世界上第一部彩色动画电影《白雪公主和七个小矮人》，成功开启了动画史的新纪元。1940年《木偶奇遇记》，1940年《幻想曲》，1941年《小飞象》，1942年《小鹿斑比》。2）其他美国动画出品公司华纳影片公司（原名华纳兄弟影片公司）1934年成立。《蝙蝠侠》，《兔宝宝》，《超人》。汉纳·巴贝拉公司《摩登原始人》《瑜伽熊》等。还有梦工厂、20世纪福克斯、米高梅、派拉蒙。（2）中国动画始于20世纪20年代，动画创始人万籁鸣、万古蟾、万超尘（简称万氏三兄弟）拍摄出片长仅有1分钟的动画广告片《舒珍东华打字机》，开创了中国动画的先河。1926年摄制完成了中国第一部动画片《大闹画室》。1941年“万氏兄弟”拍摄了片长80分钟，既是中国也是亚洲的第一部动画长片《铁扇公主》，将中国的动画艺术载入世界电影史册。1946年10月中国共产党领导创立的第一个电影制片厂——东北电影制片厂（简称东影）成立，为中国动画20世纪后半期的发展奠定了基础。1957年，中国第一家专业美术电影制片厂——上海美术电影制片厂（简称上海美影厂）成立，于1950年9月完成的第一部动画片是《谢谢小花猫》，是新中国第一部童话题材的动画片。1961—1964年，动画长片《大闹天宫》成功拍摄，标志着中国动画民族风格在此期间形成确立了中国动画民族化风格的发展方向，此时的中国动画进入了第一个高峰期。1966—1976年的“文革”使中国动画片创作一度停止。“文革”结束后，中国动画迎来了他的第二个高峰期，《哪吒闹海》《天书奇谭》等动画片的成功确立了“中国学派”在世界动画中的地位。
（3）日本动画。日本在商业动画领域凭着独特的风格和巨大的产量，是亚洲唯一能与美国抗衡的动画大国。日本的文化和价值观念也随着动画片的大量输出，传播到世界各地。1956年10月，东映动画株式会社的成立带动了日本动画的发展。由大川博(1896—1971年) 带领于1958年推出第一部彩色动画长片一取材于中国神话故事的《白蛇传》，荣获第一届威尼斯儿童电影节特别奖。1959 年日本推出第一部超宽银幕动画片 《少年猿飞佐助》也取得了良好的商业回报。至此，东映动画株式会社平均以每年一部长片的出产速度，为动画市场提供了大量的影片。被誉为“漫画之神”的手冢治虫是日本动画的主要代表人物之一，他是日本新漫画的创始人。1965年他推出的日本第一部彩色电视动画系列片《森林大帝》，推动了日本电视动画的前进步伐。他的主要动画作品有《街角的故事》《铁臂阿童木》《森林大帝》等。20世纪80年代，考入东映公司的宫崎骏成为日本动画界的龙头，他用了八年时间得到了全方位的锻炼成为动画大师。1978 年，宫崎骏独立工作制作电规动面片《未来少年柯南》。1979年，他执导《鲁邦三世·卡里奥斯特罗之城》获日本动面最高荣誉“大藤奖”。1984年， 他推出第一部影院动画片 《风之谷》荣获日本大藤奖和十四届巴黎国际科幻电影节最佳作品。1985年宫崎要和高畑勋等人创立“吉卜力”工作室，宫崎骏的主要作品有《风之谷》《天空之城》《龙猫》《幽灵公主》《千与千寻》《哈尔的移动城堡》《起风了》《你想活出怎样的人生》等。日本动画家还有大友克洋，押井守，今敏，汤浅政明，细田守，新海诚等。（4）欧洲各国动画。美国的动画获得世界声誉后，欧洲的动画家也纷行动起来，但是他们不愿意去复制美国的风格，而是在许多国家先后成立了动画制作中心来制作动画，这个情况一直维持到20世纪50年代。
苏联(俄罗斯)的动画艺术开始于1922年，创作的第一部动画片为 《战火中的中国》(1922-1923年)。1936年5月在莫斯科建立了专门拍摄动画片的制片厂，为苏联(俄罗斯)的动画艺术发展奠定了基础。苏联(俄罗斯)的动画艺术家特别注重对影片的思想内容和社会的宣传功能这两方面，在表现形式上力求和艺术风格完整统一，同时也对自身的民族文化进行认真挖掘、整理、研究。初期有《星际的旅行》(1942 年梅尔库罗夫制作)、《阿哈梅德王子奇遇记》(1928 年洛蒂·雷尼克制作的皮影动画)、《拉西与尼诺夫的前奏曲》(1934 年伊伏斯登兄弟三人摄制)等。后来逐步发展为一种教育儿童的电影，有《小沙皇杜朗台》(1935 年)、《新格利弗游记》(1934年木偶片)等。第二次世界大战后，在艺术风格上和质量技术上逐渐成熟，如《快乐的歌》《渔夫和金鱼的故事》《灰脖鸭》《冰雪女王》。1940年至1945年间拍摄文学名著改编的《七瓣花》《金画》《卡什旦》等。
法国、捷克、荷兰等国的主流动画也有着各自的成就。法国的保罗·格利牟特( Paul Grimault)创作的《国王与鸟》(1979年);法国同加拿大、比利时、英国四国联合投资共同熔炼的超级动画巨著《美丽都三重奏》(2003年);捷克动画家杰利·川卡的《好兵帅克》(1954年); Studio Bratri V Triku公司制作发行的《鼹鼠的故事》等。
2.非主流动画非主流动画是和主流动画相对而言的，它是指更加注重个体化制作和自己的创作体验。艺术家们把动画当做一门艺术来加以发挥，创作了许多风格各异、个性很强的试验性动画。因其在动画行业中不占主导地位，故称为非主流动画。（1）美国。“美国联合制作公司”简称UPA。（2）加拿大的NFB。诺曼·麦克拉伦的《母鸡之舞》（1942）《邻居》（1952）《线与色的即兴诗》（1959）《同步曲》（1971）。南斯拉夫的萨格勒布动画学派。（3）亚洲各国。
中国水墨动画片《小蝌蚪找妈妈》(1960 年)、《牧笛》(1963年)、 《山水情》(1988年) 等，剪纸片《猪八戒吃西瓜》(1958年)、《金色的海螺》(1963年)、 《草人》(1985 年)、《鹬蚌相争》(1983年) 等，还有许多木偶片、折纸片和陶塑等各种形式的美术片。“中国学派”的艺术短片不强调完整的故事，而是有目的地进行动画技巧探索，追求个性鲜明的动画语言，富于哲理性和追求社会文化性思考的主题内涵。我国近代艺术短片的代表作品有《三个和尚》(1980 年)、《悍牛与牧童》(1984 年)、《新装的门铃》(1986年)、《寂寥的天空》(1987 年)、《高女人和矮丈夫》《毕加索与公牛》(1989 年)和《十二只蚊子和五个人》(1992 年)。
法国动画家拉卢( Larrieu)的《奇幻星球》(1973 年);英国动画家鲍伯·贾佛瑞( Bob Jaffrey) 的《伟大》(1975 年)、《梦幻玩偶》(1979 年)，英籍荷兰人迈克尔·度德·威特(Michael Dudok de Wit) 的《和尚与鱼》( 1994年)、《父与女》(2001年);捷克动画家杰利.川卡的《手》(1965年)等，都是艺术动画的杰作。
动画剧本剧本的定义一个剧本可以定义为由画面、对白和描述来叙述的故事，并且将所有这些安置在故事结构的情境脉络之中。
动画剧本的基本特征是幻想。
剧本的主要特征：代言体的写作方式，最终服务于演出这一实践目的，特殊的格式，有时会有一些特殊的规则。
剧本：文学形式的一种体裁，由剧中人物的对话和舞台指示构成，是戏剧演出的文字底本。
即兴的定义为：“在当前所处环境中某些因素的刺激下，即时做出的表现、反应或者创作行为。即兴可以衍生出新的思考方式，新的动作行为，新的结构或象征意义，或者新的表演方式。”
动画剧本的分类动画剧本基本上可以分为四种形式，其中包括实验动画短片、系列动画片、连续动画片和影院动画片。
实验动画短片是以一种个体化创作的，保持自我风格、形式、技巧以及制作方式的动画艺术家的作品。例如奥斯卡最佳动画短片《神奇飞书》、《丹麦诗人》、《回忆积木屋》、《彼得与狼》《失物招领》等。
系列动画片的故事中的人物性格和人物之间的关系都很固定，几乎没有发展变化。每一集的时间长度一般在10分钟左右。例如经典系列动画片《猫和老鼠》、《蜡笔小新》、《机器猫》、《米老鼠和唐老鸭》、《加菲猫》、《倒霉熊》等。
连续剧&amp;#x2F;连续动画片可以相当于一个完整的长篇故事、长篇电影，从第一集开始到最后一集结束都是围绕着一条统一的故事线连接起来的。人物之间有着密切的联系，人物的关系会随着剧情的发展而发生相应的变化，从而慢慢的揭示出人物的真相。每一集标准时间长度一般在20分钟左右。例如经典连续动画片《太空堡垒》、《灌篮高手》、《七龙珠》等。
影院动画片的长度和常规电影长度几乎是同一个标准，一般为90分钟左右。影院动画片大多改编自文学作品，如童话神话和小说。叙事结构是与经典戏剧的叙事结构基本相符，有明确的因果关系、一定模式的开头、情节的开展、起伏、高潮以及一个完整的结局。例如《风之谷》、《功夫熊猫》、《冰河世纪》、《千与千寻》等。
动画题材类型动画题材类型：爱情类型、成长类型、动作冒险类型、犯罪或侦探类型、恐怖&amp;#x2F;惊悚类型、超级英雄类型、麻烦家伙类型、愚者成功类型、如愿以偿类型、家庭生活类型、惩罚类型、体育竞技类行、机器人科幻类型、魔法奇幻类型。
爱情类型爱情可以作为驱动力量，使主人公做出让人意想不到的事情。爱情可以分为几个层面，爱人之间的感情，关爱某些事物的感情，比如贫困儿童或身陷困难处境的某个人或动物,或是宗教信仰等方面的。《飞屋环游记》、《僵尸新娘》《萤火之森》。
成长类型都以一个未成年的小孩开始，写他们在成长过程中所经历的一些事件，从中得到历练，逐渐的变得成熟起来。最后以主人公完成自己的心愿或某一阶段的胜利结束。这类主人公要有一个特定的成长环境作为故事背景，首先交代主人公的身份和社会地位以及家庭环境等等。《狮子王》、《小鹿斑比》、《我在伊朗长大》。
动作冒险这类一直都是动画影片的主要题材类型，如果动作冒险包含了命运、狂妄或精神的东西，那么便成为激动人心的冒险。它明白无误地考验并表现了主人公的机智过人、意志坚强和临危不惧。《丁丁历险记》、《冰河世纪》、《马达加斯加》、《里约的大冒险》《风之谷》。
侦探片（从侦探大师的观点）、黑帮片（匪徒的观点）、罪行（犯罪大师的观点）或越狱戏（囚犯的观点）。在犯罪类型中必须有一项犯罪，而且必须在故事讲述过程的早期发生。必须有一个侦探人物，无论是专业的还是业余的，发现线索，提出疑问。比如《名侦探柯南》、《鲨鱼黑帮》。看看为什么对人性黑暗面的研究，通常是对我们自身进行的研究。《名侦探柯南》、《鲨鱼黑帮》。
恐怖&amp;#x2F;惊悚类型有两个主要组成部分：鬼怪和屋子例如《鬼怪屋》、《圣诞夜惊魂》、《精灵旅社》、《鬼妈妈》。
超级英雄的故事要求编剧赋予主人公以高尚品德和同情心，并且愿意为小人物和弱势群体解决问题。这个类型不都是带斗篷穿紧身衣的超人故事，凡人也有英雄，他们受到周围平庸世界的挑战。一个成功的超级英雄跟多的是来源于负面角色的塑造，其对抗力量要无比的强大，以至于能够彻底的击败这个超级英雄几个回合。这种暂时的胜利或失败我们将其称作“伪胜利和伪失败”，但最后的结局一定是不可逆转的，超级英雄一定要得到真正的胜利，坏蛋无法翻身或永远消失在这个世界中。例如《闪电狗波特》、《超人特工队》、《功夫熊猫》、《复仇者：史上最强的英雄组合》。
麻烦家伙类型主人公与超级英雄截然相反，一个普通人或者一个连普通人的基本条件都没有的残缺人，观众从一开始就会对该故事类型中的主人公产生同情，希望他能够摆脱困境。挑战的相对难度才是故事吸引人的东西。让负面价值尽可能的坏，麻烦越大主人公克服困难的效果越好，不论坏蛋还是坏事，主人公都成功地使出浑身解数战胜更为强大的负面力量。影片最后主人公一定要成功，开篇价值和结尾价值产生截然不同的重大逆转。《别惹蚂蚁》。
“愚者成功”型的要素很简单。愚者成功的故事给了我们胜利的间接体验。例如影片《四眼天鸡》和《野蛮人罗纳尔》。
如愿以偿型在影片中很普遍，因为这在人们的生活中占有相当重要的地位，“我想拥有、我想成为”影片以主人公为实现自己的梦想驱动整个故事。《美食总动员》。
家庭生活类型动画,是将人们生活中发生的一些小故事进行浓缩,以夸张搞笑的情景喜剧形式演绎。主要人物都是家庭成员,例如《樱桃小丸子》和《蜡笔小新》等影片。多以家庭生活作为故事背景，将平时发生在我们周围有关于情亲和友情的故事进行夸张处理，捕捉生活中的矛盾冲突，以幽默搞笑方式呈现出家庭生活中的温馨。《蜡笔小新》日本 臼井仪人。
惩罚类型的规律是一定要让主人公“死的很惨”，这种类型的主人公经常遭到周围人或事的“恶搞”。惩罚类型动画片多以系列的形式出现。例如韩国的《倒霉熊》和美国的《猫和老鼠》。
体育竞技类型以体育竞技作为故事的主要内容，其核心要表现的是“励志”这一主题。影片往往围绕一个或多个主人公例如《汽车总动员》和《灌篮高手》等，讲述他们求胜的艰苦经历。一般在这类影片中都有“魔鬼教练”和强大的对手这两种角色，挑战对象步步升级。《灌篮高手》日本井上雄彦。
机器人科幻类型例如影片《wall-E》、《机器人总动员》、《变形金刚》、《太空堡垒》等。这类影片多以机器人作为影片的主要人物。就像历史一样，未来也只是一个背景，其间任何类型都可以有用武之地。《机器人总动员》2008年 安德鲁·斯坦顿导演 皮克斯制作，迪士尼发行。
魔法奇幻类型日本动画大师宫崎骏的影片《哈尔的移动城堡》、《悬崖上的金鱼公主》、《千与千寻》、《幽灵公主》。
故事理论最早起源于希腊。电影剧本创作大师罗布特·麦基，《故事》。亚里士多德创作《诗学》，探讨了诗的定义、分类、特征和作用。
故事的组成部分一个故事是由一些部分：人物、情节、动作、对白、场景、段落、事件、事变组合而成的，而作为作者必须将这些部分有机地组织成为一个整体，并赋予其确定的形象和形式以及完整的开端、中段和结尾。
一系列幕构成所有要素中最伟大的结构：故事。
当我们观察人物在故事的开头中负荷价值的情境，然后把它的故事结尾的价值负荷进行比较时，就能够看到电影弧光，把生活从故事开始是的一个情境带到故事结束时的另一个变化了的情境的巨大变化。这个最后情境，这一结尾变化，必须是绝对而不可逆转的。
事件或者是人为的，或者能够影响到人，这样便勾勒出了人物；事件必须发生在场景之中，于是便生出影像、动作和对白；事件必须从冲突中吸取能量，于是便激发出任务和观众的情感。
结构是对人物生活故事中一系列事件的选择，这种选择将事件组合成一个具有战略意义的序列，以激发特定而具体的情感，并表达一种特定而具体的人生观。
人物弧光电影人物的弧光(character arc)指的是在剧情发展过程中,电影中的特定角色经历的心理、情感或行为上的变化。弧光代表着人物的成长、转变和发展,通常跟随着角色的内外在冲突以及他们在故事中所经历的事件和挑战。 弧光可以是正向的,表示角色从开始到结束经历了积极的变化和成长。这种弧光可以包括角色逐渐超越自己的限制,克服内心的困难,发展更强大的能力,改变价值观或实现自我救赎等。
另一方面,弧光也可以是负向的,表示角色经历了消极的变化和堕落。这种弧光可能包含角色逐渐走向堕落、失去目标和动力,或者经历生活中的灾难性事件而导致的心理上的崩溃。
弧光是塑造电影角色和推动故事发展的重要手段之一。通过展示人物的弧光，观众可以更好地理解角色的内心世界、情感状态和成长过程。弧光也为角色提供了深度和复杂性，使其更具有共鸣力和可信度。
故事价值故事事件创造出人物生活情境中有意味的变化，这种变化是用某种价值来表达和经历的，并通过冲突来完成。故事价值涵盖着这一概念的一切内涵和外延。价值是故事讲述手法的灵魂。从根本上而言，我们这门艺术即是向世人表达价值观的艺术。
故事价值是人类经验的普遍特征，这些特征可以从此一时到彼一时，由正面转化为负面，或由负面转化为正面。例如，生&amp;#x2F;死（正面&amp;#x2F;负面）便是一个故事价值，即如：爱&amp;#x2F;恨、自由&amp;#x2F;奴役、真理&amp;#x2F;谎言、忠诚&amp;#x2F;背叛、智慧&amp;#x2F;愚昧、力量&amp;#x2F;软弱、兴奋&amp;#x2F;厌倦，等等。人类经验中的价值都随时可能走向反面，这种二元特征便是故事价值。
罗伯特·麦基在《故事》一书中讲道：“设计情节是指在故事的危险领域内航行，当面临无数岔道时选择正确的航道。情节就是作者对事件的选择以及事件在时间中的设计。”经典的情节设计是围绕一个主人公而构建的故事，这个主人公为了追求自己的欲望，经过一段连续的时间，在一个连贯而具有因果关联的虚构实现中，与主要来自外界的对抗力量进行抗争，直到一个绝对而不可逆转的变化而结束的闭合式结局。
故事情节设计的关键就是对主人公在某段经历过程中产生的悬念和冲突这两大要素进行精心的设计和安排，而观众需要的恰恰就是在这种悬念和冲突中津津有味的看完整部影片。悬念比任何其他元素都更能影响作品的吸引力，它是构成作品的本质。
世界著名悬念大师阿尔弗雷德·希区柯克曾说过：“情绪就是悬念的基本要素。”
悬念本身也是一种手段，悬念不应该成为目的，它应该是人物经历的附属品。悬念是关于预期的，悬念是观看事件展开的过程，悬念就是创造和延长预期。
冲突：冲突有很多种功能，要求观众选择立场，制造裂痕然后为圆满解决铺平道路，帮助制造悬念，让作品具有方向感，可以出乎意料，可以让我们了解人物。冲突不能太快得到解决。
故事背景故事背景有4个方面的：时代、期限、地点和冲突层面。
时代：时代是一个故事在时间中的位置。第一个时间维是是时代。是指故事是发生在现在，还是在过去，还是在想象中的未来。
期限：期限是故事在时间中的长度。
地点：地点是故事在空间中的位置。地点是故事的物质维。
冲突层面：冲突层面是故事在人类斗争等级体系中的位置。
一个背景包括物质域、时间域，社会域。这是一条垂直的线索，是在冲突层面上来讲述的故事。故事聚焦于人物内心，即使是不自觉的冲突，或者提高一个层面，聚焦于人际冲突，或者更高更广，聚焦于与社会机构的竞争，或者再广泛一些，聚焦于与环境力量的斗争。通过生活中的多重体验，故事可以定位于这些层面的任意一个活任意组合。
故事主线故事主线：故事始终必须向前发展，它将沿着一条路径，一个方向，一条从开端直到结尾的发展路线，无论它是否采用了闪回的讲述方式。无论它是否以非线性或线性的方式来讲述，故事都是沿着可以达到一定目的的一条路径发展。这就是故事主线。
一个主人公欲望的能量形成了故事设计中一个被称为故事主线的重要成分，它又称为贯穿线或超级目标。故事主线是主人公为恢复生活的平衡所表现出的深层欲望和所进行的不懈努力。它是第一位的统一力量，将故事的所有其他要素融为一体。因为，无论在故事的表面发生什么，每一个场景、形象和话语最终都只是故事主线的一个方面，与欲望和行动的这一核心有着某种因果或主题的联系。
不自觉与自觉欲望：如果主人公有不自觉的欲望，那么他的自觉目标便成为故事线。如果主人公有一个不自觉的欲望，那么这个不自觉的欲望便会成为故事线。一个不自觉欲望总是要更强烈、更持久，深深扎根于主人公的内心。
求索之路：一个事件打破一个人物生活的平衡，使之或变好或变坏，在他内心激发起一个自觉或不自觉的欲望，意欲恢复平衡，于是这一事件就把他送上了一条追寻欲望对象的求索之路，一路上他必须与各种内心的、个人的、外界的对抗力量向抗衡。他也许能也许不能实现欲望。这便是故事的要义。
故事的组成一个故事是一个由五部分组成的设计。激励事件，故事讲述的第一个重大事件，是一切后续情节的首要导因，它使其他四个要素开始运转起来即，进展纠葛、危机、高潮、结局。
故事鸿沟这一概念出自于银幕剧作大师罗布特·麦基的《故事》一书，即:故事产生于主观领域和客观领域的相交之处。
人物塑造是通过人物的生活细节和生活方式以及其他形式的特征所表示出来的。人物塑造是一个人一切可以观察到的素质的总和，一切通过仔细考察可以获知的东西。
人物压力： 只有当一个人在压力之下作出选择时才能得到揭示——压力越大，揭示越深，该选择便越真实地表达了人物的本性。
人物揭示：用对比反衬人物塑造来揭示真正的人物性格，这是所有优秀故事讲述手法中最基本的要素。无论人物言说什么，无论他们举止如何，观众了解深层的人物性格的唯一办法，就是看他们在压力之下做出的选择。
两难选择： 人物真正的选择是两难之择。它发生于两种情境。一种是不可调和的两善取其一的选择：从人物的视点来看，两个事物都是他所欲者，他两者都想要，但环境迫使他只能选择一种。另一种是两恶取其轻的选择：从人物的观点来看，两个事物都是他所不欲者，他一个也不想要，但环境迫使他必须二者择一。在这种真正的两难之境中，一个人物如何选择便是对其人性以及他所生活的世界的一个强有力的表现。
人物设计的要素人物设计的要素：创做一个出色的人物必须具备四个要素：
第一，人物首先必须要有一个坚定的戏剧性需求。
第二，人物必须要有一个对事物的个人观点。
第三，人物必须要有一个对事物的态度。
第四，这个人物总要经历某种事物的转变。
1.戏剧性需求：每个主要人物都有一个强烈的戏剧性需求。戏剧性需求被定义为人物在剧本的严谨过程中所想要赢得、得到、获取或成就的东西。戏剧性需是人物的目的、使命、动机，是推动人物在故事线的叙事情节中穿行的驱动力。
2.观点：观点可以定义为是“一个人看待或观察世界的方式”。每个人都有自己的独特观点,观点是某种个体性或独立性的信仰体系。人们的经验世界决定了人们的观点。
3.态度：态度可以定义为是一种“行为方式或意见”，并且反应某个人的个人意见，这种意见是通过理性思考做出的判断。态度包含了一个人的行为方式。在社会行为或理论道德方面采取高姿态或低调都是一种态度。一种态度与一种观点的不同之处在于，决定采取某种态度是出于个人的判断：这是对的，那是错的。
4.变化或转变：故事中人物所经历某种形式的变化或转变，既可以是情感方面的也可以是身体方面的。人物是否在电影剧本的发展过程里发生转变，取决于人物是否合适，而并不是绝对必须的。变化和转变始终在生活中存在，如果能够让人物身上激发出某种形式的情感转变，就能创造出行为的轨迹并且增添表现人物形象的另一个维度。这种变化和转变被好莱坞编剧教父罗伯特·麦基定义为人物弧光。最优秀的作品不但揭示人物真相，而且在讲述过程中表现人物本性的发展轨迹或变化。
动画片的主人公不一定是人。由群体组合可构成一个复合主人公，必须达到两个条件：第一，群体中的所有个体必须志同道合，拥有同一个欲望；第二，在为了满足这一欲望而进行的斗争中，他们必须同甘共苦，同舟共济，一荣皆荣，一损俱损。在一个复合主人公之内，动机、行为和结果都是共通的。
主人公的特点1.主人公必须是一个具有意志力的人物。
2.主人公必须具有自觉的欲望。主人公的意志驱动一个已知的欲望。主人公具有一个需要或目标，一个欲望对象，而且他自己知道接下来要做什么。主人公的欲望对象可以是外在的，也可以是内在的。
3.主人公还可以有一个自相矛盾的不自觉欲望。一个成功的主人公还会有一个不自觉的欲望，一个多层面的主人公的自觉欲望和不自觉欲望是互相矛盾的。他相信他所需要的东西与他实际上需要而自己并未察觉的东西相对立。
4.主人共必须有至少一次实现欲望的机会。
5.主人公必须具有移情作用，同情作用则可有可无。“移情”是指像“观众”，在主人公的内心深处，观众发现了某种共通的人性。用“一个可以追随的人”，“一个可以为之喝彩的人”描述观众心灵中所产生的与主人公的移情联系。
主动主人公与被动主人公：
 主动主人公在为追求欲望而采取行动时，与他周围的人和世界发生冲突。
 被动主人公表面消极被动，但在内心追求欲望时，于其自身性格的方方面面发生冲突。
无论故事的主人公是单一、多重还是复合，无论其人物塑造特征如何，所有的主人公都必须具有他们的特点。
   （1）主人公必须是一个具有意志力的人物。
   （2）主人公必须具有自觉的欲望。
   （3）主人公还可以有一个自相矛盾的不自觉欲望。
   （4）主人共必须有至少一次实现欲望的机会。
（5）主人公必须具有移情作用，同情作用则可有可无。
小人物、小角色：所有的角色，哪怕是一个很小、很小的角色，都要具有特定的吸引观众、令人难忘的性格。给予每一个小角色一个令人耳目一新的特征，使得这个小角色在荧幕上给观众留下深刻的印象
台词台词包括对白和旁白两大类。性格通常是通过语言模式的类型来表现的。而想在影片中使用的外语，可以在语言的要素、非语言信息或者是动物声音的基础上表达。
潜台词是指在某一话语的背后，所隐藏着的那些没有直接、明白表达出来的意思；或者说，潜台词就是话中话所含有的意思。在戏剧的台词中没有直接说出，但观众通过思考都能领悟得出来的言语。潜台词是人物在行动过程中真实的内心表现，是表现人物形象的灵魂。找到了潜台词，也就找到了人物的真正的思想感情。
对白在电影中所有说出的台词都叫对白。是指影片中由人物说出来的语言。是电影艺术的主要表现手段之一。影视语言作为人类思想交流的媒介，它既有表意功能，同时又能创造出艺术美感。对白要与影像相互配合，否则观众会感到困惑及不和谐。1）银幕对白要求压缩和简约。2）它必须具有方向。3）它应该具有目的。
旁白电影艺术中以“画外音”形式出现的解说性、评论性语言。通常以剧作者“第三人称式”的客观观点或以某剧中人物“第一人称式”的主管视点出现。通常被作为剧作结构的一种辅助手段应用于说明剧情发展的事件、地点、时代背景；对剧情大幅度的时空跨越；介绍人物；对剧情的某些内容作必要的解释或发表具有哲理性和柔情型的议论等方面。旁白能够使电影产生主观色彩，且通常带有宿命意味。
内心独白：电影艺术中以“画外音”形式出现的剧中人物的内心自白。它是电影编剧揭示人物心理活动的基本手段之一，是人物言语动作的一种形式。与旁白不同，它只能是“第一人称式”的。
人物塑造人物塑造的五个诀窍：
1.人物就是自知。
2.动作就是人物。电影是表现行为。
3.给人物一个安身之处。地点应该作为一个独立的特征来处理。人物应该安置在正确的时间和地点。
4.热爱所有的人物。
5.负面角色要更强大。
场景场景：场景的目的有两个，一个是为了推动故事向前发展，另一个是为了揭示人物的有关信息。一个场景即是一个微缩故事，有着和电影剧本同样的结构准则：开端、发展、高潮、结局。在一个统一或连续的时空中通过冲突表现出来的、改变人物生活中的负载着价值的情境的一个动作。这段动作根据至少一个具有一定程度的感知的重要性的价值改变了人物生活中负荷价值的情境。理想的场景即是一个故事事件。一个场景的长度或景点几乎没有任何限制。一个场景必须统一在欲望、动作、冲突和变化周围。
场景的要素每个场景都包括两样东西:地点和时间。这两个要素将事物固定在框架内。
场景目标必须是一个人物的超级目标或故事主干的一个方面。在每一个场景中，一个人物追求一个与其当前的时空有关的欲望。人物通过在压力之下选择采取一个活另一个行动来追求他的场景目标。但是从任一或所有冲突层面却产生出一个在他意料之外的反应。其效果是再期望和结果之间裂开一道鸿沟，把他外在时运、内心生活或二者同时从正面转向负面或从负面转向正面，其衡量标准是观众所知道的押上台面的风险价值。
场景内的冲突每一个场景必须有某种形式上的冲突，在场景内构建矛盾冲突是吸引观众看下去最简单的方法。冲突就是一切。
场景的转折点场景导致细微而又意义重大的变化。序列高潮是一个导致适中逆转的场景，这种变化的冲击力要大于场景。幕高潮是一个导致重大逆转的场景，这一变化冲击力要大于序列高潮。转折点的效果是四重的：惊奇、增强好奇心、见识、新方向。
节拍、序列：节拍是场景中的最小结构组成部分。节拍是动作和反应中的一种行为交流。这些变化的行为通过一个又一个的节拍构筑了场景的转化。序列是指一系列场景，一般为2到5个，其中每一个场景的冲击力呈递增趋势，直到最后达到顶峰。
场景设计技巧1. 确定冲突 任何人物或力量都可能驱动一个场景
2. 确认开篇价值  
3. 将场景分为节拍  节拍是人物行为中动作和反应的一种交流。通过观察场景和人物的第一个动作，看这个人物表面上是在做什么，透过这一表面，看到人物实际上是在做什么。
4. 比较结尾和开端价值
5. 确定转折点的位置  从开篇场景的第一个节拍开始，检查描述人物动作的那些进行时短语。这种动作反应模式构成了一系列节奏很快的节拍。
幕幕：幕式一系列序列的组合，以一个高潮场景为其顶点，导致价值的重大转折，其冲击力要比所有前置的序列或场景更为强劲。幕——一个表现人物生活中负荷价值的情境中重大逆转的动态单位。
一幕故事一个故事可以用一幕讲述，一系列场景构筑成几个序列，一系列场景构成一个序列，最后进展为一个重大逆转，结束故事。
两幕故事一个故事可用两幕讲述，两个重大逆转之后，便告结束。但是，这同样要求比较简短，如情境喜剧、中篇小说或一小时戏剧。
三幕故事当故事达到一定的长度时，如故事影片、一小时一集的电视剧、长篇小说，则起码需要三幕。这并不是因为人为的常规，只是为了达到故事的深层目的。一个三幕故事要求4个重大场景。
第一幕是一个戏剧性的行为单元，通常耗费整个讲述过程25%的时间，在一部长度为110分钟的影片中，并且被一个称之为建立的情境脉络所紧密结合。
前十分钟：电影编剧的责任就是在前十分钟之内将剧本故事建立起来，从而能使故事的基本信息得以确立。这前10分钟的设计需要技巧、耐心和想象力。
推动：推动可以是任何偶然事件、插曲或事情。为了生活，所有人都会遇到那种时刻。改变生命历程的事件通常以坏消息的方式出现。
争执： 争执出现在推动事件后。
第二幕：发展故事通过精确地界定了主要人物的戏剧性需求来进入第二幕的。如果故事中人物的需求发生了变化，它应该发在第一幕中的情节点。第二幕是故事中最长的一幕，假设一部影片全长110分钟，第一幕的长度是25分钟左右，第三幕的长度是20分钟左右，这一节奏创造出了一个至少长达65分钟左右的第二幕。1）增加次清洁。2）增加幕。
衔接点：任何剧本中都有暗地里延伸的地方。通常都在“大转折”之后，如第一幕衔接点，还有第二幕结尾这种动作逐渐消失的地方。这是利用第二主人公或一些次要角色帮助故事过度这些地方的时候。
第二故事：第二故事一般开始于影片30分钟左右。多数剧本中的第二故事是“爱情故事”。同时第二故事也是承载电影主题的故事。
娱乐游戏：娱乐游戏部分是剧本中提供“大前提约定的部分。这是电影海报中的核心本质部分。这是电影预告片中的主要镜头来源。
中间点：中间点发生在在第二幕的中间点55分钟左右，并且将第二幕拆分成为两个戏剧性行为单元，即第二幕的前半部分和第二幕的后半部分。
一无所有：在一个优秀的剧本中，“一无所有”发生在第75分钟左右。这是“顶峰”与“低谷”相对的，这也是很多具有“伪失败”剧本中的重点。表面上看起来主人公必须像是彻底失败，他生活中各个方面都已经一团糟了，伤痕累累没有希望。
黎明前的黑夜：主人公刚刚经历过“一无所有”的失落感和内心深处的恐惧感，一定要在剧本中找到这种“黎明前的黑夜”部分。
假结尾：在某些影片中，还会在倒数第二幕高潮处，或在最后一幕的进展过程中，创造出一个假结尾。一个看似已经完成，以至于观众一时认为故事已经结束的场景。
第三幕：结局最后一幕必须是最短的一幕，一般不超过20分钟。
闭合式结局：一个表达绝对而不可逆转的变化的故事高潮回答了故事讲述过程中所提出的所有问题并满足了观众的所有情感，则被称为闭合式结局。
开放式结局：一个故事高潮留下一两个未解答的问题和一些没有满足的情感，则被称为开放式结局。
剧作格式剧作格式：字体和行间距：使用微软word软件来进行编写。选用宋体5号字，A4纸的规格。通常行与行之间的间距设置为单倍行距。
片名标题页设置：标题是用来标记剧本名字的，所以它必须显得正确而整洁。标题使用3号字体，加上书名号“《》”然后居中放置。在标题的右下角，用4号字单倍行间距写下自己的名字、住址、电话和电子邮箱。
场景的写作： 一个故事由三幕组成，有的甚至更多。而每一幕由若干个场景组成，场景里面包括人物动作、对白、事件发生的时情境等要素。
场景标题： 场景标题其实就是一个场景的简介，它必须短而精炼，而且要用粗黑字体。场景标题以场景的大致地点为开始——“内”，意思为室内场景，或者是“外”，意为室外场景。
写作动作段落： 一个动作段落必须短小精炼得像一个列表，而不是描述。在段落内容中，必须表现场景中“假定情境”。
设计场面： 介绍人物：当我们第一次介绍出场人物时，用黑体字标出他的名字。然后，用正文字体。
写作对话： 从页面左边边缘起，留出12个空格来，然后用居中、黑体表示正在说话的人物名。每个人物名及其对话间留出单倍行间距。  
转场：最频繁的转场是在地点或时间转变，其次是增加或减少人物时，最后是改变场景的戏剧目时，转场最为合适。
声效：当人物或者观众听到特殊的声响，就需要写声效。声效只在动作段落内出现，而且永远应该用黑体字标出。
写作技巧1.从里到外写作。
2.展示、不要告知。 “展示，不要告知”这一著名的原理便是问题的关键，千万不要将话语强行塞入人物的口中，令他们告诉观众有关世界、历史人物的一切。而是要展示出诚实而自然的场景，其中的人物以诚实而自然的方式动作言谈，而与此同时却间接地将必要的事实传递给观众。
3.对抗的原理  ：主人公及其故事的智慧魅力和情感魅力取决于对抗力量对他们的影响，应与之相当。
4.伏笔、分晓：铺设伏笔是指，将知识一层一层铺垫好；分晓是指，将铺设的知识传达给观众以闭合鸿沟。
5.因果与巧合： 故事要尽早引入巧合，以给予它充分的时间来构建其意义。其次千万不要利用巧合来转折一个结局，巧合不能突然弹入一个故事，转折一个场景，然后又突然弹出。
6.闪回：闪回不过是另一种形式的解说。就像其他一切因素一样，这种手法也是用好即好，用坏即坏。
7.噱头、反复的噱头：影片讲得是什么内容？”好的噱头回答了这个问题。好的噱头会抓住人们的眼球，让人们想跑到电影院里。噱头必须绽放于观众的脑海，勾引观众去进一步了解。
晚餐测试：剧本创作中的晚餐测试是—种用于评估剧本质量和逻辑连贯性的方法。在这个测试中，剧本作者会设想—个虚拟的晚餐场景，然后观察角色之间的对话和互动是否自然、真实,并且是否符合角色设定和剧情发展。
视听语言视听语言视听语言既是电影的画面、 声音艺术表现形式的代名词，又是电影艺术表现手法的总称。
电影语言就是蒙太奇。 
人们用“视听语言” 统称电影的艺术表现手段。 
视听语言的基础是电影的两大基本元素： 活动影像和同步声音。它涉及镜头内容、 镜头形式、 分镜头规则和声画关系处理4个方面的内容。
视听语言是表现电影内容的基本方式，与剧作、 表演一起，共同构成导演创作的三大艺术手段。 
视听语言既是电影作为艺术的表现手法，又是电影作为大众传播媒体的符号系统。 作为艺术形式，视听语言贵在独创性；作为传媒符号系统，视听语言必须规范化。
动画艺术是从 “实验动画” 开始的，也称其为艺术性动画片。 
新型的文化产业模式 “商业动画”。
仍然保持自我风格形式技巧以及制作方式的动画艺术家的作品为 “实验动画”，内涵到形式更倾向本体元素的极限发挥，“商业动画” 则更加趋向多元文化的相互渗透。
实验动画片的形式多种多样，最突出的形式特征之一是没有具体背景，以背景留白的写意手法来象征特定空间。 用假定的手法表现一个被夸张和变形的现实，来揭示真实人物的心里特征，或者表现生活中的一个的哲理。表现一些隐藏在生活中的，难以表达的事实，是实验动画片的创作动机。实验动画片的技术特点是随意性强，具有非标准化工艺，还带有很强的偶然性。 
叙事动画片的结构与经典戏剧的叙事结构基本相符，有明确的因果关系、 固定模式的开头、 情节的展开、 起伏、 高潮以及一个完整的结局。 
动画片的传播方式动画片的传播方式主要有两种：影院动画片、电视动画片。区别是影片播放的时间长度、制作周期、制作成本和制作工艺，一般影院动画片的制作成本要高于电视动画片。
影院动画片的长度一般为90分钟左右。影院动画就是用动画的手段制作电影。
电视动画片电视动画片是指在电视上播出的动画片。电视动画片分为系列动画片和连续动画片两类。讲述相对独立的故事版本称为剧场版。
1.系列动画片 ：系列动画片通常是由生活中的一些小故事组成的大的系列，每一集的故事情节都是完整独立的，也可2~3集组成一个小单元。 人物性格和人物关系固定，不会转变，故事演绎套路化。 《蜡笔小新》《猫和老鼠》。
2.连续动画片：连续动画片从始至终是由一个完整的故事情节构成的，每一集都相互关联。 它相当于一部影院动画的加长版。 人物性格和人物之间的关系会随着故事情节的发展产生变化，以描写主人公某个阶段的成长经历为主。 
动画片 (Animation) 它以绘画或其他造型艺术形式作为人物造型和环境空间的主要表现手段，不追求故事的逼真效果，而运用夸张、 神似、 变形的手法，借助于幻想、 想象和象征反映人们的生活、 理想和愿望，是一种高度假定性的电影艺术。
二维动画又称传统动画。 它是用水彩颜料画到透明的长方形赛璐珞片上，角色及对象可以画在不同的赛璐珞片上，然后将其重叠在场景的背景中。
偶动画顾名思义就是人偶动画，指由黏土偶、 木偶或混合材料的角色来演绎的动画，这种动画通常是用定格动画方式拍摄出来的。定格动画 ( Stop-motion Animation ) 正如它的名称所示，它是一种古老的电影拍摄技术。
1995—2000年是第一阶段，此阶段是三维动画的起步以及初步发展时期（ 1995年皮克斯的《玩具总动员》 标志着动画进入三维时代 ）。在这一阶段，皮克斯、 迪士尼是三维动画影片市场中的主要玩家。
2001—2003年为第二阶段，三维动画迅猛发展时期。
IMAX 3D动画是加拿大的IMAX 集团所研发的一种巨型银幕电影。一般商业用35mm底片，IMAX 影片为了增加影像的解析度，采用了特殊的65mm底片及其专用摄影机，冲印成长度为70mm胶片，传统70mm胶片的影像尺寸为48.5mm x 22.1mm, 而IMAX 胶片的影像尺寸为69.6mm x 48.5mm, 即15&amp;#x2F;7。格式胶片每格上有15个齿孔。 
镜头又称“画面”，是影片结构的基本单位。一个镜头是指摄影机从开机到关机连续不断地拍摄一次，是电影造型语言的基本视觉元素。 一部影片是由所含信息、 延续时间长短、 景别、 角度、 运动方式等众多镜头按照特定的顺序组接而成的。
镜头镜头按景别可分为远景、 全景、中景、近景、 特写等； 按摄影机与被摄物体的角度可分为鸟瞰、 俯拍、 水平、 仰拍、 倾斜镜头等。 按照运动方式的不同可分为横摇、 上下直摇、 升降、 推轨、伸缩镜头、手提摄影、 空中摇摄等； 过肩镜头、 主观镜头、 客观镜头、 反应镜头、 空镜头等。
制作动画前都会编写分镜头剧本。一个镜头中又包括很多的元素： 景别、 镜头的运动方向、 角度、 光影、 色彩、 场景中的陈设道具，以及演员的表演和服饰。要想拍好一个镜头，首先要充分考虑上述的所有元素。
主观镜头：摄影机的视点直接代表某一部动画片中以人物的视角所拍摄的镜头。 
客观镜头：客观镜头也称“中立镜头” 。
反应镜头 ：反应镜头所表现的内容必须和上一个镜头或者上一组镜头中的内容有严密的逻辑关系和时间的延续性。 
空镜头：空镜头又称 “景物镜头”，即画面中没有人物的镜头，提供银幕视觉信息，与有角色（包括人或动物等） 的镜头可以互补但不能替代，是导演阐明思想内容、 叙述故事情节、 抒发感情意境的重要手段之一，在银幕时空的转换和调节影片节奏等方面也有独特的作用。 
过场镜头：过场镜头指在两场戏之间加入一个或者几个过渡性的镜头，其主要目的是为了交代两场戏在空间或者时间上的变化。 过场镜头通常由内容为景物的空镜头组成。主要目的是为了使相邻的两场戏在时空的变化过程中不会引起观众的疑惑，并旦以此调整影片的节奏。 
长镜头：长镜头能保持电影时间与电影空间的统一性和完整性，能表达人物动作和事件发生的连续性和完整性。长镜头的出现，被认为是 “电影美学的革命”。
巴赞则标新立异，把电影的特性归结为照相性，并从这一特性出发，强调电影的逼真性和纪实性，推动了电影语言的发展。没有长镜头，就不会有现代电影。
固定长镜头、 景深长镜头和运动长镜头。
1.固定长镜头：机位固定不动、 连续拍摄一个场面所形成的镜头称固定为长镜头。 
2.景深长镜头：使处在纵深处不同位置上的景物（从前景到后景） 都能看清，用大景深镜头，可以使火车出现在远处（相当于远景）、 逐渐驶近（相当于全景、 中景、 近景、 特写） 都能看清。 
3.运动长镜头：用摄影机的推、 拉、 摇、 移、 跟等运动拍摄的方法形成多景别、多角度（方位、 高度） 变化的拍摄方法，称为运动长镜头。 
景别景别是指在电影中被摄物体在画面中呈现的范围，一般分为远景、 全景、 中景、 近景和特写。 在一些分镜头剧本中，也常出现中近景、 大全景、 大远景以及大特写等名称。
景别取决于摄影机与被摄主体之间的距离和所使用的镜头焦距的长短这两个因素。划分方法有两种： 一种以被摄主体在画面中所占比例的大小为准，凡拍摄其局部则为中景和近景；另一种以画框截取人身体部位多少为标准。一般多采用后一种划分法。 
远景常用来展示事件发生的环境和规模，并在抒发情感、 渲染气氛方面发挥作用。 这种镜头经常出现在史诗类电影中，如战争片、 历史片、 太空科幻片等。  远景镜头的长度一般不应少于10秒。
全景是表现人物的全身或场景全貌的电影画面 ，全景往往是拍摄一场戏的总画面，它制约着该场戏中切换镜头时的光线、 影调、 色调、 人物方向和位置，使之衔接，全景可容纳角色的整个身体。全景镜头的长度一般不应少于6秒。 
中景是表现人物膝盖、 腰部以上或场景局部的画面。 可使观众看清人物半身的形体动作和情感交流，有利于交代人与人、 人与物之间的关系，是表演场景中的常用镜头，也可以用来做叙事性镜头。 中景是具有较强功用性的镜头，占有较大的比例。 
近景是表现人物胸部以上或物体局部的电影画面。运用近景时，可以使观众看清演员展示人物心理活动的面部表情和细微动作，使观众仿佛置身于事件中，容易产生共鸣。 
特写镜头是表现人物肩部以上的头像或某些被摄对象细部的电影画面。 可把人或物从周围环境中强调出来。 特写镜头往往能将演员细微的表情和某一瞬间的心灵信息传达给观众，常被用来细腻地刻画人物性格，表现其情绪，有时也用来突出某一物体细部特征，揭示特定含义。 
特写是电影中刻画人物、 描写细节的独特表现手法，也是电影艺术区别于戏剧艺术的重要因素之一。 特写镜头一般较短，在视觉上贴近观众，容易给人以视觉上、心理上的强烈感染力。 特写镜头因具有极其鲜明、 强烈的视觉效果，在一部影片中不宜多用。 影片中还会经常使用特写镜头作为转场画面。
大特写是特写镜头的演变。 
角度角度由 “摄影机” 的位置所决定，与被摄物体无关。 一般而言，电影中有7种常用的镜头角度，即鸟瞰角度、俯角度、水平角度、 正面角度、 仰角度、 侧面角度及斜侧角度。 由拍摄距离、 拍摄方向和拍摄高度3个因素决定。 
仰角度又称 “仰拍” ，景物的地平线在画面中处于下部画外，有净化背景的作用。 画面中竖向的线条有向上方透视集中的趋势。 仰角镜头常被用于表现崇高、 庄严、 伟大的气势。有时为了达到某种艺术效果，也可利用透视变形打造夸张效果。
俯角度又称 “俯拍”。画面中竖向的线条有下方透视集中的趋势。 俯角度镜头常被用来描述环境特色，有时也用来表现压抑、 低沉的气氛，处理群众场面可产生壮观宏伟的气势。 也可利用透视变形产生夸张的效果。 
鸟瞰角度是一种以在天空中飞翔的鸟类视角为镜头视角的摄像位置。 鸟瞰镜头使观众对视野中的事物产生极具宏观感。 因为利用高高在上的视角进行拍摄充满了主宰性，会引发被摄物产生一种若有若无的悲壮宿命感。 
水平角度 画面中的地平线处于画面中央，易造成画面分割的感觉。 采用一些水平视线角度拍摄的画面，以便用于叙述场景。 
斜侧角度：摄影机处于被摄物体的正面和侧面之间的位置。 可以表现其侧面的部分特征，可产生鲜明的立体感和较好的透视效果。
运动摄影运动摄影亦称“运动拍摄”，即摄影机在推、 拉、 摇、 移、 跟、升、降、 旋转和晃动等不同形式的运动中进行拍摄。 运动摄影是以逐渐依次扩展或集中为展示形式表现客观事物的。这有助于突破电影的固定画幅比例的界限，能够扩展视野增强画面的动感和空间感，丰富画面的造型，还有助于描绘事件发生、 发展的真实过程，表现事物在时空转换中的因果关系和对比关系，增强逼真性。 既有利于表现人物在动态中的精神面貌，又可为演员表演的连贯性提供有利条件。 运动摄影所产生的时间和空间上的内在联系，在影片中可更好地体现出其寓意、 对比、 强调、 联想、 反衬等多种艺术效果。
推镜头简称 “推” ，使观众有视线前移的感觉。 可在一个镜头中了解到 整体与局部的关系，主体与背景、 环境的关系，并可增强画面的真实感和可信度，给人身临其境之感。 
拉镜头简称 “拉” ，特点是不让观众马上看到景物和环境的整体，而是逐步扩展视野的范围，并可在同一镜头内逐渐了解到局部与整体的关系，可产生悬念、 对比、 联想等艺术效果。 
摇镜头也称“摇摄”、 “摇拍”，简称“摇外0 ，只有机身做上下、 左右、 旋转等运动。 摇摄的方向可与动体的方向相同，也可相反，画面均呈现出动态构图，它逐一展示、 逐渐扩展景物，产生巡视环境，展示规模，揭示动态中人物的精神面貌和内心世界，烘托情绪与气氛等多种艺术效果。 
移动镜头又称“移摄”，简称 “移”，它既可突出运动中的主体，又能交代物体的运动方向、 速度、 体态及其与环境的关系，使物体的运动保持连贯。 
升降镜头简称“升、 降”，如果能巧妙地利用前景，则能加强空间深度的幻觉，产生高度感。 它常用以展示事件的规模、 气势，或表现处于上升或下降运动中人物的主观视角。 与推、 拉、 横移和变焦距镜头结合使用，能产生变化多端的视觉效果。 
甩镜头又称 “闪摇镜头”，即速度极快地摇摄镜头。 有多种闪摇形式： 从一个景物闪摇到另一个景物； 旋转的闪摇； 有起幅而无落幅的闪摇； 从左摇到右，又从右摇到左； 上下闪摇； 斜线闪摇等。 
晃动镜头是指拍摄过程中摄影机机身做上下、 左右、 前后摇摆运动进行的拍摄。 常用于主观镜头，如酒醉、 精神恍惚等，或产生乘船、 乘车摇晃、 颠簸等效果，可创造特定的艺术气氛。 
旋转镜头是指被摄主体或背景呈旋转效果的画面。 
常用的拍摄方法1.沿镜头头光轴或接近镜头光轴仰角旋转拍摄，相机超过360°
 2.摄像机超过360°快速环摇拍摄；
3.被摄主题语摄影机位置转盘上做超过360°快速还移拍摄
4.摄影机围绕被摄物体做360°快速环移拍摄；
5.使用可旋转的光学镜头，在摄影机不动的条件下，将胶片上的影像倒转、倒置或转到360°圆中的任何角度。 转动时可沿顺时针或逆时针两个方向； 
6.使用技巧印片机，印制旋转的画面。 
除以上几种方法外，利用可旋转的运载工具拍摄也可以获得旋转效果。 
旋转镜头多用于表现人物在旋转中的主观视线或晕眩感，或以此烘托及渲染气氛。 
升格镜头是指提高摄影机运转频率的一种拍摄方法。 频率可用胶片每秒通过的画幅格数来表示，正常频率为24格&amp;#x2F;秒，高于24格即为升格。 可以根据需要升至32格&amp;#x2F;秒、 40格&amp;#x2F;秒、 48格&amp;#x2F;秒、 64格&amp;#x2F;秒、80格&amp;#x2F;秒、 96格&amp;#x2F;秒、 128格&amp;#x2F;秒等。在影片中它能产生幻觉、 迷离、 柔情、 腾越等艺术效果。 
降格镜头是指降低摄影机运转频率的一种拍摄方法。正常频率为24格&amp;#x2F;秒，低于24格&amp;#x2F;秒即为降格。 可以根据不同要求降到16格&amp;#x2F;秒、 12格&amp;#x2F;秒、 8格&amp;#x2F;秒、 4格&amp;#x2F;秒、2格&amp;#x2F;秒、 1格&amp;#x2F;秒，甚至可以降到几个小时或几个小时拍一格，格数降得越少，放映时（24格&amp;#x2F;秒不变）画面上的物体运动速度越快。
焦距焦距是镜头的中央点到光线聚集的焦点之间的距离。 不同的焦距会产生不同的透视效果。
通常我们以不同的透视效果来区分3种镜头，即短焦距镜头、 中焦距镜头和长焦距镜头。
短焦距镜头又称广角镜头，焦距小于35mm的镜头就是广角镜头。
中焦距镜头又称标准镜头，现在常用的镜头是35~50mm。 标准镜头在一部影片中运用的次数也是最多的。 
长焦距镜头又称长焦镜头，假如角度改变空间，长焦距镜头则以摄影机为轴心，将四周景物扁平化。 现在使用的长焦镜头大约在75-250mm之间，或更长。长焦镜头也会影响主体事物的变化，由于它将距离扁平化，因此物体朝向镜头方向运动时，会显得需要更长时间才能到达。
焦距的长度不仅会影响事物的形状和大小，同时还能决定画面的景深效果。 变焦镜头是指在同一场景中改变场景的透视关系。 变焦能产生有趣而独特的大小与景深变形。
景深镜头，是指在摄影机镜头沿着能够取得清晰图像的成像景深相机轴线所测定物体的距离。在对焦完成后，在焦点前后都能形成清晰的图像，这一前一后的距离便叫做景深。  被摄体所在的这段空间的长度就叫景深。景深就是对好焦距的范围。 
移焦是指镜头可以先对焦在前景物体，而使后面模糊，之后则移焦到后景物体，而使前景模糊。 另外，移焦也可以从后景转到前景。
场面调度一词借自法国剧场，原意是“舞台上的布位”。 舞台上的演员与布景陈设、 走位，均以三维空间观念设计。
电影场面调度电影场面调度基本上包括两个层次，即演员调度和镜头调度。 
演员调度指导演通过演员的运动方向、 所处的位置的更动，以及演员与演员之间发生交流时的动态与静态的变化等。 造成画面的不同造型、 不同景别，揭示人物关系及其情绪的变化，以获得银幕效果。 
演员调度与镜头调度的结合构成了电影的场面调度。 
场面调度的依据主要是剧本提供的内容，作者描述的人物性格与心理活动、 人物之间的矛盾纠葛、 人物与环境的关系等。 
导演根据自己对剧本的理解和对生活的独特发现，产生场面调度的构思，并在影片摄制过程中逐步实现这一构思。除了能产生银幕画面的构成作用，传递富于表现力的造型美之外，它对刻画人物性格、 揭示人物内心活动、 演染环境气氛、 寄寓哲理思想、 创作特殊意境等方面，都可以产生积极的审美作用，增强艺术的感染力量，活跃和推动观众的联想，从而满足观众的审美感受。 
人类学家爱德华 ・霍尔将人类使用距离的关系分为4种即亲密的、 个人的、 社会的、 公众的。
爱德华 • 霍尔从人的皮肤至18英寸远称之为 “亲近距离” ，这种距离有人与人间身体的爱、 安慰和温柔关系。 “亲密距离”比较接近特写和大特写镜头。 
“个人距离” 大概是18英寸到4英尺的距离（约手臂长）。 “个人距离” 约是中近景镜头。 
“社会距离” 约为4英尺到12英尺。 通常是非私人间的公事距离，或是社交场合的距离，“社会距离” 约在中景和全景距离内。 
“公众距离” 则是12英尺至25英尺或更远的距离。 “公众距离” 则在全景和大全景内。
空间的造型处理手法很多： 如设置前、 中、 后景，构成有纵深感的三度空间； 运用透视合成与假透视远离扩展有限空间； 使用烟、 雾、 气等手法造成虚幻空间； 用阶层梯级高低错落形成空间的节奏感； 用曲折迂回、阻隔叠嶂、 借景映衬等布局，使空间环境变幻无穷。
灯光几乎可以决定一个影像的震撼力。 亮光可吸引我们的注意，或泄露一个重要的举动； 而阴影则能掩饰某些细节，制造悬疑。 
艺术家用黑暗来象征恐惧、 邪恶、 未知之事，光明则代表了安全、 美德、 真理和欢愉。 
三点式布光也常用于低反差布光，低反差布光不强调明暗对比，主要着重在全面打亮的设计。
色彩基调从属于影片总的情绪基调, 是总的视觉氛围的主要组成部分，是形成影片情绪基调的主要视觉手段。 影响一部影片色彩基调的客观因素主要有： 环境色调的选择，化妆、 服装和道具色彩的配置，光线的处理，后期电脑调色。  
根据影片的主体、 题材、 风格、 样式，运用各种表现手段和材料工艺，描绘角色的外部形象，以诱发演员的心里、 神态的变化，塑造人物形象。 
场面调度中除了演员调度和镜头调度之外，导演还应注意控制和选择画面的空间造型、 光影、 色彩、 道具、 演员的服装和化妆等重要造型因素。 
化妆造型形象具有认识功能和审美功能。 特点是强调直观的真实性，不甚采取装饰性的手法和假定性的色彩。 
场面调度的方法多种多样，没有固定的模式。 常见的有纵深场面调度、 重复性场面调度、 对比性场面调度、 象征性场面调度等。 
纵深性场面调度是指导演通过演员或摄影机的运动利用一个镜头内景别、 构图、 光影、 场面、 环境气氛、 人物动作等造型因素的变化来加强导演赋予这个镜头的思想含义。 
重复性场面调度一般指重复出现两次或两次以上相同或相似的演员调度和镜头调度。 不仅可以给观众造成情绪的冲击力量，还能使之由情向理的方向转化，使观众进入思考，获得新的认识价值。
对比性场面调度是指把相同或相反的事物加以比较或衬托，可以使对比的双方相互辉映，能够更生动、 更鲜明地显示出各自的性格和特点。 如将动与静、快与慢、 明与暗、 强与弱、 冷色与暖色、 前景与后景、 开放与封闭等强烈的对比因素纳入到场面调度之中，以增强艺术的反差和对比度。 
象征性场面调度，是指导演借助场面调度寄托某种寓意或象征某种事物的内在含义口 把深层次的思想隐藏在浮露的形象之下，将一些不便直说的情理转化为婉转含蓄的形象，让观众去感知、 去思索、 去意会，从而产生耐人寻味的艺术魅力。 
轴线轴线，被摄对象的视线方向、 运动方向和对象之间关系所形成的一条假定的直线。 根据导演的场面调度，在同一场景中拍摄相连镜头时，为了保证被摄对象在画面空间中的正确位置和方向的统一，摄影角度的处理要遵守轴线规则，即在轴线一侧180° 之内设置摄影角度。 这是构成画面空间统一感的基本条件。 
越轴的方法 ：
\1. 利用对象的运动改变轴线，下一个连接的镜头按照已改变的轴线设置角度 
\2. 利用摄影机的运动越过轴线 
\3. 用无明确方向的中性镜头或特写镜头来间隔轴线两边的镜头,以缓和由于越轴给观众造成视觉上的跳跃。
\4. 用对象的细部特写镜头来过渡。 这种方法与第3种方法相似，其区别在于景别不同 
\5. 利用插入镜头改变方向。
\6. 利用双轴线，越过一个轴线，由另一个轴线完成空间的统一 
反拍也称 “反打”，是电影摄影角度的一种。 处于前一个镜头拍摄方向的反面或反侧面的角度。 
以拍摄人物为例： 前一镜头从正面拍摄，后一镜头从反面或反侧面拍摄。 电影的反拍可以使人看不到环境的完整性，赋予真实感。 反拍镜头的运用还有助于表现主体对象的多面和立体形态，为塑造人物和演员表演提供条件。 由于反拍镜头可以拍摄对象的另一面，在一组镜头中可以起到对比、 暗示、 强调和渲染的作用。
总角度又称“总方向”、 “主要角度”，这是为保证景物空间关系的统一和正确表达场面调度所确定的全景拍摄角度。 多用于早期电影中，一般总角度用全景镜头来表现。 
内反拍角度是电影摄影角度的一种。 在轴线的一侧两个方向相背的摄影角度。 常用于主观视点的镜头。
外反拍角度是电影摄影角度的一种。 在轴线的一侧两个方向相对的摄影角度。 在以这种角度构成的画面中，两个人物可以互为前景和后景，具有明显的透视效果。这是一种客观角度。 
影片的声音影片的声音包括音乐、 音响、 语言3大部分。电影是视听艺术，导演在处理声音与声音的关系的同时，又要充分考虑声音与画面的关系。
用以处理人物、 烘托环境、 揭示画外空间等，并在总体上形成影片的节奏感和风格样式。 在表现手法上，声音处理可以运用淡入淡出、 主观音、 自然声、 非自然声等；在声画关系上，可采用音画对位、 音画分立、 音画对比、 非同步声、无声等。
音响通常用于还原生活真实、 渲染气氛，然而也可通过改变音量、 声调等发挥表情达意的作用，甚至可以作为一个声音主题，具有象征意义。
对白可以塑造人物、 揭示剧情、 延伸视觉空间。 画外音独白也是语言处理的一种方法。 
音量又称声强。 音量是由空气中的振动感觉到声音的存在，而振幅决定了音量的大小。 在影片中更是经常要控制音量。 音量的大小影响距离感，通常声音越大，我们就会认为距离越近。 衡量音量的单位为分贝（ db ）。 
声音振动的频率控制着音调，即声音的“高音” 和“低音”。 在生活与电影中，大部分的声音都是混合声，有不同频率的组合。 
声音各部分的调和赋予声音特定的风味或声调，音乐家们称之为音色。 它是形成声音“感觉” 及“质地” 的依据。 
节奏是表现声音的时间特色，可以分为有节奏和无节奏。 
声音的规律性可以产生一定的宁静感、 安全感，或者会让人觉得很唠叨、 很烦人。 而不规则的声音可以让人警觉、 受惊吓、 困惑或者忍俊不禁。 
节奏、 音量、 音调、 音色可以帮助观众感受整部影片。
空间和时间是由视听结合决定的，场景的连续或分割也是如此。 通常，声音和画面能够同步，但为了叙事需要，声音和画面也可以不同步。
在声画关系中，无声处理是较极端的手法，但如果运用得恰当，就能造成“此时无声胜有声” 的效果，使观众高度集中注意，常用来表达紧张、 恐怖或肃穆的气氛 。
画内声音：画内声音是指画面上我们看得到的声源所发出的声音。 典型画内声音包括与口形同步的语言声、 关门声、 脚步声、 海浪声、 孩子们的戏耍声等等。 
画外声音：画外声音是指画面上观众看不到声源的声音。 画外声音的另一个区别是声音是主动还是被动的。 主动声音引起问题和好奇心，被动声音营造气氛和环境，包装并稳定剪辑点前后的画面，使剪辑点变得流畅。 
主观声音：主观声音是深入到影片中人物内心世界，展示其心理状态的非银幕场景空间内的声音。
客观声音：客观声音是画面空间内和空间外存在的声源所发出的声音。 剧中人的对白、 歌唱等。 这些声音会起到叙事的作用，使画面空间变得真实，使影片获得逼真的艺术效果。 
电影音乐是专为影片找来音乐人创作（原创音乐），或选用已有音乐作品（挪用音乐）为影片编配音乐。 
音乐是对白以外另一个叙事空间，但音乐不像对白，对白多以人物的语气、 语调组成。音乐却拥有多种多样的先天特性，包括透过其旋律、 曲式、 歌词及其历史背景等，可以具象呈现，也可以抽象表达，它们既可如同旁白属于直接的叙事线索，比如作为一种时代氛围的表达；也可以成为隐含的叙事工具。
旋律：旋律是由不同高低、 不同长短、 不同强弱的乐音组成，是塑造音 乐形象、 抒发音乐情感的主要手段。 是体现影片主题、 塑造人物形象、 抒发内心情感的重耍手段。 人物通过类型（乐器）、 目标（ 音调中心 ） 、能力（范围） 和情绪等级（音色）来表现。
和声：和声结构为要表现的音乐提供情绪和空间背景。
不和谐音可以形成张力和戏剧，使观众产生对解决冲突的向往。
节奏：音乐和电影都是时间表现的艺术形式（与绘画和雕塑相对） 。节奏和速度的感知是通过所发生事件的实际频率，时间段内传送的信息多少，在我们内心深处、 理智上、情感上的卷入程度来实现的。 
乐句：一个乐句包括一个由旋律、 和声、 节奏、 意图组成完整的思想，乐句是整个乐曲的组成单位。 同样地，剧本或影片也有； 场景里面表现单一思想的回合，作为组成单位； 情节里面的完整场景，其目的是把单一的思想连接成为物质流； 一系列的场景，其连接组合的目的是使故事朝新的戏剧方向发展。
音乐的作用 ：有情感表现、 连贯性、 叙事提示以及完整性这几种功能。
音乐的抽象性给电影留出了很多空间，引发更多使人利用幻想力创造的思考空间。 曲式、 旋律、 节奏成就了构筑音乐的一个无形思维空间。
1.情感表现：音乐可以催眠，使观众感受到看不见的和听不到的事物、表现人物的精神过程和情感过程。
2.连贯性：当声音或画面有间断的时候，音乐可以填补这个缺口。 
3.叙事提示：音乐可以帮助观众确定背景、 人物以及叙事事件，让观众有一个特定的视角。 
4.叙事完整性：音乐通过运用重复、 变奏、 对位等手段，能够帮助形成影片的形式统一，这也是对叙事的支持。 
音画关系是指音乐与画面在影片中的结合关系。一般分为音画同步和音画对位两种形式，其中音画对位又包括音画并行和音画对立。
音画同步：音画同步是音画关系的一种。音乐强调了画面提供的视觉内容，起着烘托、 渲染画面的作用 。
音画对位：音画对位也是音画关系的一种。 指音乐作品中若干个相对独立的旋律声部结合为和谐整体。这个概念是苏联导演爱森斯坦、 普多夫金和亚历山大洛夫与1928年在《未来的有声影片》 （创言宣言） 一文中首次提出的。 普多夫金在1933年导演的影片《逃兵》 中，第一次有意识地运用了这一原则。 
音画并行是指音乐以自身独特的表现形式从整体上揭示影片的思想内容和人物的情绪状态，在听觉上为观众提供更多的联想和潜台词，从而扩大影片在单位时间的内容容量。 
音响音响是除语言和音乐之外电影中所有声音的统称。 音响不只是重复画面上已出现的事物，而旦是作为剧情元素纳入影片的结构中，成为艺术创作的手段之一。 
自然音响。
背景音响。
机械音响。
枪炮音响。
特殊音响 ：音响在影片中能够增加生活气息、 烘托气氛、 扩大视野、 赋予画面以具体的深度和广度。 
语言包括对白和旁白两大类。 性格通常是通过语言模式的类型来表现的。
在电影中所有说出的台词都叫对白，亦称 “台词”。影视语言作为人类思想交流的媒介，它既有表意功能，同时又能创造出艺术美感。对白要与影像相互配合，否则观众会感到困惑及不和谐。
电影语言是口说而非书写的形式，而表演的演员常能利用声音的高低抑扬甚至断句造成不同的效果。
旁白是电影艺术中以“画外音” 形式出现的解说性、 评论性语言。 通常以剧作者“第三人称式” 的客观观点或以某剧中人物“第一人称式” 的主观观点出现。 通常被作为剧作结构的一种辅助手段应用于说明剧情发展的时间、 地点、 时代背景； 对剧情大幅度的时空跨越； 介绍人物； 对剧情的某些内容做必要的解释或发表具有哲理性和柔情性的议论等方面。旁白大多不追求口语化。 相反，它追求书面语言那种较为严密的语法结构和逻辑性，具有一定的文学性。 旁白能够使电影产生主观色彩，旦通常带有宿命意味。 
动画片的发展壮大也促使了拟音领域的发展和创新。角色和物体都跟形成该场戏中情绪上紧张关系的动作相关。 环境的声音包括内景和外景，通过不同的声音使人对所处环境产生的感知，也可以用音乐来烘托影片的环境气氛。 转场声音是电影中用于衔接前后两场戏或两个段落的音乐。这种音乐既可以用整段的乐曲，也可以用短小的乐句。 
剪辑剪辑是影片制作过程中一项必不可少的工作，也是影片艺术创作过程中最后的一次再创作。 “剪辑” 在英文中是editing, 和“编辑” 是同一个词。 剪辑” 原意为安装、 组合、 构成，音译成中文就是 “蒙太奇”。 
剪辑工作包括画面剪辑和声音剪辑两个方面，是技术同时也是艺术工作。 
蒙太奇思维蒙太奇思维是电影创作的一种思维方法。编剧和导演进行创作构思时，在想象中形成的连续不断、 结构独特、 合乎逻辑、 节奏准确的画面与声音形象的思维活动。  通过这种思维方法来表达影片的内容与思想、 塑造人物、 描绘场景。蒙太奇句子是一组镜头经有机组合构成逻辑连贯、 富于节奏、 含义相对完整的电影片段。蒙太奇段落是影片中由若干蒙太奇句子或场面有机组合成的可以表现相当完整内容的大单元。 
平行蒙太奇：在故事情节发展过程中，通过二三件事同时在异地进展着，互相有呼应又有联系，彼此起着促进刺激的作用，这种表现方式就是平行蒙太奇。 
交叉蒙太奇：交叉蒙太奇是利用同一时间和不同空间内容的镜头交叉地组接起来，使两种动作构成紧张的气氛和强烈的节奏感，造成惊险的戏剧效果。 
复现蒙太奇：从内容到性质完全一致的镜头画面反复出现。 这种画面总是在剧情发展的关键时刻出现，其用意是加强影片主题思想或不同历史时期的转折，从而唤起观众对影片主题和主人公的深刻印象或认识。
对比蒙太奇：对比蒙太奇是通过镜头（ 或场面、 段落 ） 之间在内容上（ 如贫与富、 苦与乐、 生与死、 成功与失败、 高尚与卑下等） 或形式上的（如景别的大小、 角度的俯仰、 光线的明暗、 色彩的冷暖浓淡、 声音的强弱、 动与静等） 的强烈对比产生相互强调，相互冲突的作用，以表达创作者的某种寓意强化所表现的内容、 情绪和思想。 
积累蒙太奇：利用从内容到性质上相同的一些类型的画面，而在这一类画面里面表现的主体是不一致的，按照动作和造型特征，取其不同的长度组接起来，构成一种紧张的场面，造成预想的气氛和节奏。 这种剪辑方法就是积累蒙太奇。
联想蒙太奇：用内容截然不同的一些镜头画面，连续地组接起来，造成一种意义，使人们去推测这个意义的本质。 
象征蒙太奇：按照剧情的发展和情节的需要，利用景物镜头直接说明影片主题和人思想活动。 
错觉蒙太奇：这种构成方法首先是故意使观众猜想到情节的必然发展，但忽然来一个180度大转弯，结果不是人们所预料的镜头，而是恰恰相反,出乎意料。 
扩大与集中蒙太奇：由近景或特写逐渐扩大到全景或远景，使观众从细部看到整体，造成一种特定的气氛。 
剪辑剪辑可通过相似性或差异性使两个镜头内的图形产生关系，相互影响。 画面的造型因素包括构图、 方位、 景别、 角度、 光影、 色彩、镜头运动、 主体活动，这8个方面构成了画面的造型要素。 
节奏是剪辑对镜头长短等有逻辑性和规律性的安排。 逻辑性主要体现在结构中。 规律性则更多地体现在节奏处理中。 
对镜头有规律有起伏张弛的安排皆可称节律。 这种镜头形成的合理安排，就是剪辑节奏的全部工作。 
镜头组接与时空的关系是指在剪辑创作中，对处理镜头组接时间空间关系的规律性的把握。 
剪辑涉及到镜头之间的时间空间关系时，通常有4种情况，即时空压缩处理、 时空延伸处理、 时空跳跃处理、空间方向处理。
时空压缩处理。在镜头组接中利用人物的动作、 镜头的运动、 视距和视角的变化、 光学技巧、 插入镜头以及音响、 音乐等因素来压缩时间过程或空间距离。 不仅可以取得流畅的镜头转换效果，并能使观众很自然的接受这种假定的时空连贯性。
时空延伸处理：时空延伸处理。 影片中某个关键性的段落，当需要展开来进行细致描写或需要造成特殊的强烈印象时，往往在镜头组接中有意识地延长时间或扩大空间。 不过这样的处理只适用于影片中个别段落，运用不当则会产生动作繁琐、 节奏拖沓等效果。 这种方法常被用在动画片里。 
时空跳跃处理：时空跳跃处理。 在镜头组接或段落转换中，有时需要观众明显地感觉到时间或空间的大幅度跳跃，使各个有意义的戏剧动作片段相互队列，产生创造性的联想效果。 同时，影片中的时空跳跃也是一种艺术上的省略手段。
空间方向处理 ：镜头之间的方向关系，包括画面主体的运动方向、 人物之间的位置关系和视线交流关系等，都要有一定的逻辑性，通常称为画面的方向性。 一般场面的方向关系都应严格按照电影摄影轴线的规律来处理。 为了制造某种特殊的冲击效果，有些影片在特定的情况下也可以跳轴。 
人物动作的连续性动作分解法：人物形体动作剪辑技法之一。特点是上下镜头的动作长度大致保持相等，即上一个镜头留多少下一个镜头也留多少。一般来说，人物的起坐、握手、拥抱、走路、开关门窗等动作都可以采用分解法。 
动作错觉法 ：动作错觉法是人物形体动作剪辑技法之一。 通过恰当地运用电影特性的某些错觉，加强动作性和节奏感的剪辑方法。 
动作增减法:动作增减法既耍使人物形体动作符合生活的逻辑，更要体现出戏剧动作的艺术真实。 
固定镜头和运动镜头的衔接 :静接静 :在视觉上没有明显动感的镜头切换方法。因此静接静也同样是保证镜头转换流畅的一种组接方法。静接静还包括在场景段落转换处和各种运动镜头之间在头尾静处的组接，它更多注重镜头的连贯性，不强调运动的连续性。 
动接动:在两个视觉上都有明显动态的相连镜头的切换方法。 不同主体镜头的切换方法。动接动也包括各种运动镜头的组接。 
静接动:动感不明显的镜头紧接动感十分明显的镜头的衔接方法。 前面镜头的静止画面中往往蕴含着强烈的内在情绪。 
动接静:在镜头动感明显时紧接静感明显的镜头的衔接方法，是镜头组接的特殊方式。
动作转场剪辑 :动作转场剪辑是剪辑技法之一。 借助人物、 动物、 交通工具或战争工具等动作和动势的可衔接性以及动作的相似性作为场景或时空转换的手段。
特写转场剪辑 ：用特写镜头来结束一场戏或从特 写镜头开始一场戏的剪辑手法。 用特写镜头结束一场戏或用特写镜头开展一场戏都是为了强调人物的内心活动或情绪，有时是为了表示某一物件、 道具（如钟表、闪动着的红灯、 十字架等） 所含有的时空概念和象征性含义，以造成完整的段落感。 
语言转场剪辑：利用后一场戏对白首句与前一场戏对白末句的衔接，或重复的有机联系来达到场景转换的自然过渡。 
音乐转场剪辑 ：有时它能使人沉浸在对美好事物的回味中，有时则能给人造成对即将降临的灾难和不幸的预感。 
音响转场剪辑 ：有时还用这种转场的音响效果作为唤起人物和观众回忆与联想的艺术手段。 
景物转场剪辑 ：景物镜头包括两个方面，一种是以景物为主、 物为陪衬的镜头，用这类镜头作转场剪辑，既展示不同的地理环境和景物风貌，也表示时间和季节变化，又是以景抒情的表现手段。 另一种是以物为主，景为陪衬的镜头。
情绪转场剪辑：利用情绪渲染的延续性作转场处理，借助情绪的贯穿性来转换场面，起到承上启下、 一气呵成的作用。 
光学技巧转场剪辑 ：传统的电影手法 ，省略时间和空间过程的作用 ，诸如 “叠印”、 “化出”、 “化入”、 “渐隐”、“渐显”、 等技巧。渐显，渐隐，化出，化入，划出，划入，帘出，帘入，圈出，圈入。
无技巧转场剪辑是： “切出”、 “切入”，又称 “跳切”。
漫画创作参考书籍：《理解漫画-Understanding Comics》斯科特·麦克劳德（Scott McCloud）
漫画作为“连续的艺术”。
漫画大师：威尔·艾斯纳。
漫画的艺术形成——媒介。
漫画——连续视觉艺术——有意识排列的并置图画及其他图像。
1519年左右科尔维特发现的玛雅绘卷原稿——最初的漫画。与之像似的作品：巴约挂毯。
埃及的漫画阅读顺序Z字形——自下而上。
霍加斯的作品先作为一系列油画展出，随后做成版画成套出售——油画和版画的展示都被设计成一幅接一幅并排的——也就是连续的。
现代漫画之父——罗多尔夫·托普弗，在十九世纪初的轻讽刺连环画，使用了卡通绘画和分割框，在欧洲是将文字和图画结合起来的第一人。
木板画家——林德·沃德。比利时的弗兰兹·麦绥莱勒。
马克思·恩斯特——《一周行善》。
图标：用来再现某一对象的图形。
对于非象形图标来说他们的意思是固定的绝对的。
普遍观念是照片和现实主义绘画是图标中最近似于它们的实际对照物的。
卡通把注意力放在了特定的细节上，有目的的简化人物和图像在任何媒体形式。
卡通将自己定位在了观念的世界里。卡通风格生来具备这种产生观者身份认同感的特点。
观众是不是有参与感取决于观众对于故事人物身份代入感的程度。
不可见的自我认知也在一定程度上可以代表我们的整个身体。
我们在生活中的一切体验都可以划分为两个领域：观念领域和官能领域。
艺术家想要描绘物质世界的复杂和美就需要用现实主义手法。
其他任务被画的更接近现实以便将他们变得客观起来，从而强调他们与读者的界限。
文字是抽象的极致。文字，图画，和其他图标，就是漫画这种语言的词汇。
一种统一的语言需要有一个统一的词汇表。
图画是一种接收式的信息，讯息是即时的。
写作是一种理解式的信息，它需要花时间和特定的知识以解码语言的抽象符号。
当文字变得更为醒目更直接时，它们要求的理解力降低，并能更快被接受，变得接近图画。
我们对现实的感知是一种信念作用，仅仅是建立在残缺的片段之上。这种将观察到的部分理解为整体的现象有一个名称——知觉的封闭性。
某些封闭直觉是叙事者故意制造出来的，制造悬念或挑战观众，而另一些是自发产生的。在辨认和关联他人的时候靠的都是这种封闭自觉能力。对电子媒体来说，自觉封闭是其不间断的强效动力。
直觉封闭是变化、时间和动态间的中介。
水沟指两页之间用于装订的留白空间，漫画用来表示格与格之间留出的间距——格间距。
视觉的图标阐释是漫画的词汇，封闭性知觉就是漫画的语法——漫画就是一种封闭的知觉。
读者有准备的主动地封闭知觉是漫画模拟时间和动态的基本手段。
时间——时间过渡。
动作——动作过渡。杰克·科比最常用。
对象——对象过渡。
视角——视角过渡。
日本漫画家手冢治虫——日本漫画主流。
无关联过渡。没有任何事件和叙事性目的。
传统西方艺术和文学是一种目的导向的文化，但在东方有着丰富的迂回曲折的艺术传统——艺术作品里的留白与实际包含内容同样是作品的一部分——间隔的艺术。在视觉艺术领域，东方观念的冲击强烈而持久。
漫画是一种单一感官的媒介。它值依赖于视觉传达经验中的世界——只能传达视觉信息。
现实主义图像基本的视觉性存在不能简单地进入思想领域。
时间和维度的长度更多是由画格的内容决定的而不是画格本身。画格形状不同并不会影响到时间上的意义，改变的是阅读体验。
出血位——一个画格超出页面边缘。漫画中的时间和空间是紧密相关的，时间和运动也相关。
可以在一格中通过图画来表现一段时间——漫画的运动线。
时间和漫画的互动通常引出两个主题：声音和运动。
声音可以分为两类：文字气球和音效。两种都能增加单元格的时间长度，部分是因为时间本身的天性可以引入行为和反应。
运动也分两类：单元格的封闭知觉或单元格内的运动。
爱德华·蒙克和文森特·梵高——表现主义。瓦西里·康定斯基。
愤怒红色，和平蓝色，焦虑的质感，喧闹的形状，安静的线条，冰冷的绿色——1912年。
全体美感——联觉。艺术制造可见的形体——保罗·克利。
查理德·瓦格尔和法国诗人波德莱尔。罗里·海斯，地下坐着，表现主义者。
符号是语言的基础。视觉隐喻——一种符号。符号最终成为完全抽象化的语音体系。任何形式的艺术或信息存在的时间越久，所积累的符号就越多。
特定的图案可以制造出观众的心理作用。
漫画里最常用最复杂也最万能的联觉图标就是文字气球。文字可以扒看起来中性的图像变得富有感觉和体验。图画可以引起读者的强烈感觉，但缺少文字具有的明确性。
文字虽然有明确的意指，但缺少图画的直接冲击，效果是逐渐积累的。漫画里展现的全部其实都属于不可见的艺术。
最早的文字实际上就是格式化了的图画。文字变得越来越抽象越来越专业越来越复杂。
大多数现代书写体都只是表现声音而失去了与视觉世界的任何相似特性。
图画越来越少的抽象和符号化，越来越多的具象和细节化。
西方美学对再现光线和色彩这些可见事物着迷。
印象主义将西方美术的方向指向了抽象的顶点。印象主义的位置仍处在过去对光线色彩的研究终点处。
表现主义，未来主义，达达，超现实，野兽派，立体派，抽象表现主义，新造型主义，构成主义。
当一系列场景展示出了全部“需要”展示的东西时，脚本的自由度就增加了。
反之当文字固定了表达的意义时，图画就真正摆脱限制了。
文字特质（图画示意但没有补充）、图画特质（给视觉配音）相互依存式、双重特质、平行式、附加式（互相扩展和阐释）、蒙太奇式（文字被处理为图画内的一部分）一切媒介中一切作品的创作都遵循特定的路径。
1.概念&amp;#x2F;目的 2.形式 3.风格 4.结构 5.工艺 6.外观。
第一步：作品的动力，概念，感情，哲学体系，目的性，即作品的内容。
第二步：采用的形式。
第三步：主题，画风或表现的方式，作品的类型。
第四步：组织到一起，要包括什么去掉什么如何安排协调这件作品。
第五步：构建作品，应用技巧，实践知识，创造，排除问题。
第六步：成品价值。表面。在所有艺术中人们最容易接受的就是它的外表。
漫画和色彩关系之间最大的原因：商业和技术。
红绿蓝——三色光可以被加成为纯粹的白色光，也被称为加成色。
法国钢琴家迪克奥龙提出了减色法三原色。
黄青紫也可以混合出可见光谱中的任何色调，他们使用的是过滤光线。四色印刷。
三原色的亮度分为100%，50%和20%。
只有理解的力量可以打破艺术家和观众之间的壁垒，无需妥协就可以被广泛倾听。现实主义艺术捕捉可见世界的美与复杂。
电影史运动规律数字艺术数字动画制作速写概念设计Maya3ds Max</content>
    <url>/2025/05/03/ACG%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%AE%8C%E8%AE%A1%E5%88%92/</url>
  </entry>
  <entry>
    <title>Exercism.org-Java-Log Levels</title>
    <content>Exercism.org-Java-Log Levels


InstructionsIn this exercise you’ll be processing log-lines.
Each log line is a string formatted as follows: &amp;quot;[&amp;lt;LEVEL&amp;gt;]: &amp;lt;MESSAGE&amp;gt;&amp;quot;.
There are three different log levels:

INFO
WARNING
ERROR

You have three tasks, each of which will take a log line and ask you to do something with it.
1. Get message from a log lineImplement the (static) LogLevels.message() method to return a log line’s message:
LogLevels.message(&amp;quot;[ERROR]: Invalid operation&amp;quot;)// =&amp;gt; &amp;quot;Invalid operation&amp;quot;

Any leading or trailing white space should be removed:
LogLevels.message(&amp;quot;[WARNING]:  Disk almost full\r\n&amp;quot;)// =&amp;gt; &amp;quot;Disk almost full&amp;quot;

2. Get log level from a log lineImplement the (static) LogLevels.logLevel() method to return a log line’s log level, which should be returned in lowercase:
LogLevels.logLevel(&amp;quot;[ERROR]: Invalid operation&amp;quot;)// =&amp;gt; &amp;quot;error&amp;quot;

3. Reformat a log lineImplement the (static) LogLevels.reformat() method that reformats the log line, putting the message first and the log level after it in parentheses:
LogLevels.reformat(&amp;quot;[INFO]: Operation completed&amp;quot;)// =&amp;gt; &amp;quot;Operation completed (info)&amp;quot;


Methods


Modifier and Type
Method and Description







int
indexOf(int ch)Returns the index within this string of the first occurrence of the specified character.


int
indexOf(int ch, int fromIndex)Returns the index within this string of the first occurrence of the specified character, starting the search at the specified index.


int
indexOf(String str)Returns the index within this string of the first occurrence of the specified substring.


int
indexOf(String str, int fromIndex)Returns the index within this string of the first occurrence of the specified substring, starting at the specified index.


String
substring(int beginIndex)Returns a new string that a substring of this string.


String
substring(int beginIndex,int endIndex)Returns a new string that a substring of this string.


String
trim()Returns a copy of the string, with leading and trailing whitespace omitted.


String
toLowerCase()Converts all of the characters in this String to lower case using the rules of the default locale.


String
toLowerCase()Converts all of the characters in this String to lower case using the rules of the given Locale.


Question Answerspublic class LogLevels &amp;#123;    // Method for task 1    public static String message(String logLine) &amp;#123;        // Extract message part by using substring method        String message = logLine.substring(logLine.indexOf(&amp;#x27;:&amp;#x27;) + 1).trim();        return message;    &amp;#125;    // Method for task 2    public static String logLevel(String logLine) &amp;#123;        // Extract level part by using substring method, then convert it to lowercase        String level = logLine.substring(logLine.indexOf(&amp;#x27;[&amp;#x27;) + 1, logLine.indexOf(&amp;#x27;]&amp;#x27;)).toLowerCase();        return level;    &amp;#125;    // Method for task 3    public static String reformat(String logLine) &amp;#123;        // Use above two methods to extract message and level, then reformat the log line        String message = message(logLine);        String level = logLevel(logLine);        return message + &amp;quot; (&amp;quot; + level + &amp;quot;)&amp;quot;;    &amp;#125;&amp;#125;

Word
processn.(为达到某一目标的)过程;进程;流程;工序;工艺流程;(事物发展，尤指自然变化的)步骤;做事方法v.处理(文件、请求等);加工;数据处理;审核;审阅v.列队行进;缓缓前进adj.(用化学方法等)处理过的;照相制版的;经过特殊加工的;三色版的


processingv.处理;审阅，审核，处理(文件、请求等);加工;数据处理v.列队行进;缓缓前进n.加工；处理；运算process的现在分词


formattedv.格式化;安排…的版式adj.格式化（的）；格式化了的；有格式的format的过去分词和过去式


Implementvt.实施;执行;贯彻;使生效n.工具;器具;(常指)简单的户外用具


lowercasen.小写字母;小写字体


occurrencen.发生;出现;存在;发生的事情;存在的事物

</content>
    <url>/2023/08/10/Exercism-org-Java-Log-Levels/</url>
  </entry>
  <entry>
    <title>Github Page博客搭建</title>
    <content>前提介绍：写了比较详细的Github Page博客搭建相关过程！为方便查阅，特地把本篇内容放在博客置顶。本篇前半部分写于2021年，后半部分写于2023年，截至2025年本搭建过程仍可全流程速通。
已经非常了解Git与Github可直接跳转到：【电脑本地安装：Node.js】或【电脑本地安装：Hexo】目录观看。



GitGit是一个分布式版本控制系统，用来跟踪文件和项目的变化，可以记录文件的修改历史，使多个开发者能够协同工作并管理代码的版本，常用于个人或多人软件开发。就像游戏存档？
GitHubGitHub是一个基于 Git 的代码托管平台，提供了集中式的远程代码仓库托管服务。开发者可以将他们的代码存储在 GitHub 上，并与其他开发者协作、分享代码以及管理项目。
GitHub PagesGitHub Pages是 GitHub 提供的静态网页托管服务，允许用户创建和托管静态网站。用户可以通过 GitHub Pages 将自己的代码仓库中的静态文件自动部署为可访问的网站。
Github Page的官方介绍页
Markdown和md文件MD文件是一种使用纯文本格式编写的标记语言文件，扩展名为.md。MD是Markdown的缩写，Markdown是一种轻量级的标记语言，用于以易读易写的方式编写文档。
可以使用任何文本编辑器，例如记事本、Sublime Text、Visual Studio Code等。只需使用纯文本编写，然后使用Markdown语法来标记文本的格式。一些常用的将MD文件转换为HTML的工具包括Markdown编辑器（例如Typora、Dillinger、StackEdit、Obsidian等）和命令行工具（例如pandoc）。
参考：
Markdown语法说明（中文版）：https://markdown-zh.readthedocs.io/en/latest/
Markdown Guide：https://www.markdownguide.org/
YAML配置文件YAML是一种人性化的数据序列化语言，适用于所有编程语言，专门为常见用例而创建的，例如：配置文件、日志文件、进程间消息传递、跨语言数据共享、对象持久化和调试复杂数据结构。
YAML 文件使用 .yml 或 .yaml 扩展名，并遵循特定的语法规则。
YAML是一种简单、表达力强的、以数据为导向的语言，它不是一种标记语言 (YAML)，作为配置格式时非常易读。它具有直观的可视化结构，并且其逻辑非常简单：缩进的项目继承父项目的属性。
YAML使用缩进来确定结构并表示嵌套。为了保持跨系统的可移植性，设计时不允许使用制表符，因此改用空格（字面意义的空格字符）
在_config.yml配置文件中：
deploy:  type: git  repo: git@github.com:KiraraKira/Kirara.github.io.git  branch: main

相当于：
deploy.type: gitdeploy.repo: git@github.com:KiraraKira/Kirara.github.io.gitdeploy.branch: main



有关YXML的教程可以参考：


YAML教程
YAML Ain’t Markup Language (YAML™) version 1.2
YAML 语言教程
YAML for beginners
What is YAML?
YAML Glossary
# YAML教程（快速入门版）
## YAML 入门教程


注册 GitHub 账号在游览器打开 GitHub 的官方网站。网址：https://github.com
点击右上角 “Sign up”（注册）按钮，进入注册页面。


下图就是注册页面了。
在注册页面，填写用户名（Username）、电子邮件地址（Email address）和密码（Password）


全部填写完毕后，点击 “Create account”（创建账号）按钮。


根据提示完成其他必要的信息，例如选择计划（免费或付费）、是否开启学生优惠和接受相关条款等等，根据自己的需要选择。
完成注册后，会在邮箱内收到一封确认电子邮件，邮箱内有验证码。
点击邮件中的确认链接和相应验证码，激活GitHub 账号。
电脑本地安装：Git下载Git这里是Windows系统下载git的方式。
打开 Git 的官方网站：https://git-scm.com/download/win
点击左侧的 ”Downloads“（下载）。
根据电脑的系统选择下载32位和64位。






安装Git双击下载的安装程序文件（通常是一个 .exe 文件），启动 Git 的安装向导。
Git-2.41.0.3-64-bit.exe 
根据提示开始下载，通常情况下选择默认即可
但是需要注意的是，有两个务必选择的选项：

“Use Git from the Windows Command Prompt”（在 Windows 命令提示符中使用 Git）

“Checkout Windows-style, commit Unix-style line endings”（检出 Windows 风格，提交 Unix 风格的行尾）








后面的内如果没有特别要改的需求，可以全部按照默认格式  
Tips：关于安装的更多详情可参考：  超详细之Git 2.41.0版本安装教程
配置Git环境在之前的git安装中，会默认配置电脑环境变量，如果没有默认配置的话，按照下面的步骤手动配置环境变量：右键点击打开 “此电脑” 或 “我的电脑” ，点击 “属性”  




点击右侧的 “高级系统设置”




点击 “环境变量”






找到 “系统变量” 中的 “Path”，双击打开




查看系统环境变量中是否有git安装地址 。如果没有，手动点击右侧的“新建”添加 。
添加成功后，原路返回的顺序依次点击 “确定”。




确认git安装无误后，来看看git能不能正常使用吧！  
打开cmd窗口或桌面上的git图标：






输入：
where git 

或
git --version



可以查看git安装地址和git版本。
显示了git的版本表示git已经成功安装。






配置用户信息已经安装好Git后，寻找一个没什么重要文件的文件夹，鼠标右键点击空白处，点击Open Git Bash here，打开git bash。




在命令行中输入以下命令，设置全局的用户名和电子邮件地址。
引号内的内容记得替换为Github账号中实际的用户名和电子邮件地址。
实际的用户名是在注册的时候使用的Username。
git config --global user.name &amp;quot;Your Name&amp;quot;git config --global user.email &amp;quot;your_email@example.com&amp;quot;



例如：
git config --global user.name &amp;quot;Kirara&amp;quot;git config --global user.email &amp;quot;kirara@Rhodes.com&amp;quot;



验证Git 配置使用下面的命令查看自己有没有配置成功名字和邮箱：
git config user.namegit config user.email



第一个命令 git config user.name 用于检索配置的用户名，第二个命令 git config user.email 用于检索配置的邮箱地址。
在命令行或终端中执行这两个命令时，将输出您当前本地 Git 配置中设置的用户名和邮箱地址。
如果输出了之前配置的内容，表示配置成功。
还可以使用：
git config --global --list

来查看git的全局配置




配置SSH协议Github向仓库推送代码时，可以使用 SSH 协议进行推送。
SSH（Secure Shell）是一种网络协议，用于在不安全的网络中安全地进行远程登录和数据传输。它通过对网络连接进行加密和身份验证来保护通信的安全性。
SSH 私钥（Private Key）是一种加密密钥，用于身份验证和加密数据。私钥通常存储在本地计算机上，并且必须保持私密和安全。每个用户都会有自己的私钥。
SSH 公钥（Public Key）是与私钥相关联的公共密钥。它可以安全地与他人共享，而不会泄露私钥的内容。公钥可以用于验证与其对应的私钥，从而实现安全的身份认证和加密通信。
配置SSH协议需要配置相关的私钥和公钥。






生成SSH私钥生成SSH私钥有很多种方法
例如：在git bash窗口中输入：
ssh-keygen -t rsa -C &amp;quot;邮件地址&amp;quot;

或者打开cmd窗口，输入：
ssh-keygen -t rsa -C &amp;quot;邮件地址&amp;quot;

上面两条命令生成密钥的命令是RSA（Rivest-Shamir-Adleman）加密算法，默认使用较短的 2048 位。
生成密钥可以任意选择自己想用加密方式，例如，下面的密钥也是使用了算法，但使用-b 4096 参数指定了生成的 RSA 密钥的长度为 4096 位：
ssh-keygen -t rsa -b 4096 -C &amp;quot;邮件地址&amp;quot;



除了RSA加密算法以外，还有DSA（Digital Signature Algorithm）等等许多种都可以使用，相关具体的使用方法可以自己在网上查找。
例如：下图中使用的是Ed25519 算法。
ssh-keygen -t ed25519 -C &amp;quot;邮件地址&amp;quot;

下图显示密钥已经生成完毕了。






获取 SSH 公钥在生成 SSH 密钥对后，需要获取公钥的内容。
找到公钥文件生成的位置，打开公钥文件（通常文件默认在 ~/.ssh/id_rsa.pub），使用记事本打开，复制全部内容。






添加 SSH 密钥登录到你的 GitHub 帐户，点击右上角的头像，点击Settings，也就是设置




在左侧的菜单中，选择选择 “SSH and GPG keys”（SSH 和 GPG 密钥）




点击 “New SSH key”（新建 SSH 密钥）。




添加密钥信息：在 “Title”（标题）字段中，为该 SSH 密钥提供一个描述性的名称，可随意填写。
然后，在 “Key”（密钥）字段中，粘贴之前复制的 SSH 公钥内容。




保存 SSH 密钥：点击 “Add SSH key”（添加 SSH 密钥）按钮，将 SSH 密钥保存到 GitHub 账号中







测试SSH配置为了确保 SSH 密钥正确配置，确保电脑可以与 GitHub 进行连接，使用下面的命令来验证SSH是否配置成功：
ssh -T git@github.com



如果一切设置正确，会收到一条像下面这样的欢迎消息：
Hi KiraraKira! You&amp;#x27;ve successfully authenticated, but GitHub does not provide shell access.









电脑本地安装：Node.js因为Hexo 是一个基于 Node.js 的静态网站生成器，所以需要安装Node.js。
而Node.js 是一个运行时环境，让 JavaScript 可以在服务器端运行。
需要用到Hexo，在安装Hexo之前，还需要先下载安装Node.js。
安装Node.js访问 Node.js 官方网站：在您的浏览器中打开：(https://nodejs.org/en)
在node.js官网下载安装，和Git一样，基本按照默认配置安装就可以了。




查看npm版本npm（Node Package Manager）是一个由 Node.js 的包管理器，与 Node.js 一起安装提供。主要功能是允许开发者在 Node.js 环境中查找、安装、更新和管理 JavaScript 包（也称为模块）。
也就是说，安装好Node.js后，理论上会自动安装好npm。
使用下列命令查看 npm 和 Node.js 的安装版本：
npm -vnode -v







可查看版本即为npm安装成功。
如果不显示版本，参考之前的《配置Git环境》：右键点击”此电脑“，点击”属性“，点击”高级系统设置“，点击”环境变量“，在”系统变量“中找到 ”Path“，查看环境变量中是否有 node.js，如果没有，手动找到 node.js 的安装路径，手动将路径添加进Path，并按原路径确认。
电脑本地安装：HexoHexo 是一个基于 Node.js 的静态博客框架，它使用 Markdown 文件来创建和管理内容，并生成静态网页供发布，Hexo 需要依赖 npm 安装。
Hexo 官方文档：https://hexo.io/zh-cn/docs/commands
安装Hexo在当前项目目录下安装 Hexo 及其相关依赖项：
npm install hexo



全局安装 Hexo 的命令行工具（CLI）使用 npm 在全局范围安装 Hexo 的命令行工具（Hexo CLI），安装好后可以在任何目录下通过命令行使用 Hexo 相关命令，不仅限于特定的项目目录。
npm install -g hexo-cli



在全局范围内强制重新安装 Hexo CLI如果之前下载过Hexo，电脑中已经存在旧版本的 Hexo CLI，默认情况下，为了防止意外覆盖或破坏现有的配置或数据， npm 会而是保留原来的旧版本，不会安装。
但是如果想要强制安装新版本的Hexo，或单纯想要重新安装，可使用 --force 标志，强制 npm 忽略现有的 Hexo ，开始安装全新的Hexo。
这个命令会删除旧版本的 Hexo CLI，并用最新版本进行替换。强制重新安装可以确保Hexo CLI 是最新版。
npm install -g hexo-cli --force









查看Hexo版本下面两个命令都可以显示 Hexo 的版本信息：
hexo -vhexo -version

如果查看版本时只显示“hexo-cli: 4.3.1”，是正常情况，是因为hexo没有初始化，之后使用 hexo init 文件夹名 初始化后就可以看到 hexo 的版本。




正式创建Github Page现在，准备好了Github账号，配置好了Git，安装好了Node.js环境和Hexo，可以正式创建Github Page了！
创建Github仓库点击右上角的加号，选择“New repository”。
Repository（仓库）是用于存储和管理代码项目的地方。
一个 Repository 可以包含项目的所有文件、文件夹、版本历史记录、分支、标签以及与项目相关的其他资源。




在Create a new repository页面，找到：Repository name *。这里的星号表示必填项。
填入新建的仓库名字。
注意：仓库的名字一定要填：
博客名字.github.io

不可以省略后面的 github.io ，否则无法建立正确的Github Page。




创建好后，修改一下仓库的配置。
点击 Seetings （设置），进入仓库的设置页。
&amp;quot;Pages&amp;quot;（页面）选项提供了配置和管理项目的静态网页的功能，






如下图所示：默认的分支为：main。
分支名需要记住，后面的网站配置中需要使用。




点击左侧的Pages。




找到：Buile and deployment（构建和部署）
Source（源）：

Github Actions（Github操作）最适合使用框架和自定义构建过程
适合需要灵活性和自定义性的项目，可以根据特定的框架、工具和构建流程来执行自动化任务。

Deploy from a brance（从分支部署）经典页面体验
只有经过验证的代码被部署到生产环境，提供稳定和可靠的页面体验。


两种构建和部署方法都可以支持使用Hexo ，但Hexo 更适合使用 Deploy from a branch 。
例如，可以将 Hexo 生成的静态网页文件所在的分支（通常是 gh-pages 分支，在下图中我使用了默认的的 main 分支）作为部署源。
启用 Deploy from a branch 并选择该分支后，每次推送代码到该分支时，GitHub Pages 会自动构建并部署分支上的静态网页。












初始化Hexo在电脑容易找到的位置新建一个文件夹，尽量与自己的Github 仓库同名，例如：D:\Kirara\Kirara.github.io
这个文件夹就作为存放代码的地方。
进入文件夹：
cd 文件夹名cd Kirara.github.io



初始化一个新的 Hexo 网站：
hexo init

Hexo 将创建一个新的文件夹，其中包含用于构建和管理网站的基本文件和目录结构。








_config.yml：Hexo 网站的主要配置文件，包含网站的各种设置选项，如标题、URL、主题等，可以在这个文件中进行自定义配置。
package.json：Node.js 的包管理文件，用于管理 Hexo 网站所需的依赖包和插件，可以使用 npm 或 yarn 命令来安装、更新和管理依赖项。
scaffolds 目录：包含用于生成新文章、页面和草稿的模板文件，在命令行中使用 Hexo 提供的相应命令，可以使用这些模板快速创建新的内容。
source 目录：用于存储 Hexo 网站的源文件，包括 Markdown 格式的文章和页面。您可以在这里编写和管理网站的内容。
themes 目录：用于存放主题文件的目录。Hexo 支持使用不同的主题来定制网站的外观和样式。在此目录中，您可以将下载或自定义的主题放置在相应的子目录中。
安装Hexo的依赖包运行 npm install 命令，会根据项目中的 package.json 文件中的依赖项列表，将所有所需的软件包和模块下载并安装到当前项目的 node_modules 文件夹中。这些依赖包通常是项目所需的第三方库、框架、工具或插件。
npm install



运行npm install命令后，会自动下载一些依赖文件到Kirara这个目录，下载到node_modules中。
node_modules文件夹内的依赖文件不要轻易删除




安装Hexo需要的插件Hexo 默认已经包含了下列的渲染引擎插件，大多数情况下不需要手动安装。
但如果在使用 Hexo 过程中遇到了相关的渲染问题或错误，可以尝试使用下面的安装插件命令重新安装。
在本地文件夹中打开git bush，输入命令即可安装插件：
EJS 渲染引擎插件npm install hexo-renderer-ejs --save

安装 Hexo 博客框架中的 EJS 渲染引擎插件，并将其作为项目的依赖保存。hexo-renderer-ejs 是 Hexo 的一个渲染引擎插件，它用于将 EJS（Embedded JavaScript）模板语言转换为 HTML 页面。EJS 允许在 HTML 页面中嵌入 JavaScript 代码，以实现动态内容的渲染和生成。
Stylus 渲染引擎插件npm install hexo-renderer-stylus --save

命令的作用是安装 Hexo 博客框架中的 Stylus 渲染引擎插件，并将其作为项目的依赖保存。hexo-renderer-stylus 是 Hexo 的一个渲染引擎插件，用于处理 Stylus 样式表语言。
Tips：Stylus 是一种基于缩进的样式表语言，类似于 Sass 和 Less，它提供了更简洁灵活的语法来编写 CSS。
如果希望在 Hexo 项目中使用其他的样式预处理器（如 Sass 或 Less），可以安装对应的渲染引擎插件，并相应地修改 Hexo 配置文件中的样式相关配置。
Marked 渲染引擎插件npm install hexo-renderer-marked --save

安装 Hexo 博客框架中的 Marked 渲染引擎插件，并将其作为项目的依赖保存。hexo-renderer-marked 是 Hexo 的一个渲染引擎插件，用于将 Markdown 文档转换为 HTML 页面。
三个插件同时安装：npm install hexo-server hexo-browsersync hexo-renderer-pug --save



安装服务器、浏览器同步和 Pug 渲染引擎插件插件解释服务器插件npm install hexo-server --save

提供了一个本地服务器，可以在开发环境中预览和调试生成的静态页面。安装 hexo-server 插件后，可以使用 hexo server 命令来启动本地服务器，并通过浏览器访问 Hexo 博客的预览页面。
浏览器同步插件npm install hexo-browsersync --save

浏览器同步插件，它基于 BrowserSync 技术，可以在多个浏览器和设备上同步刷新页面。安装 hexo-browsersync 插件后，可以在使用 hexo server 启动的本地服务器上实现浏览器同步，从而在实时编辑博客内容时，各个浏览器会自动更新并显示最新的页面。
渲染引擎插件npm install hexo-renderer-pug --save

渲染引擎插件，用于处理 Pug（以前称为 Jade）模板语言。Pug 是一种简洁而强大的模板语言，它提供了更简洁的语法来编写 HTML 页面。
安装 hexo-renderer-pug 插件后，Hexo 将使用 Pug 渲染引擎来处理包含 Pug 语法的模板文件，并将其转换为最终的 HTML 页面。
生成静态页面hexo g 和 hexo generate 用于生成静态页面的命令，完全等价的，可以互换使用。运行 hexo g 或 hexo generate 命令时，Hexo 会根据博客内容和配置，将 Markdown 文件转换为 HTML 页面，并生成相应的静态页面，将页面生成在public文件夹下。




这些静态页面可以用于发布到服务器或托管平台上，以供访问和阅读。这两个命令的作用相同，只是 hexo g 是 hexo generate 的简写形式，方便用户记忆和使用。可以根据个人喜好选择使用哪个命令来生成静态页面，效果是一样的。
hexo ghexo generate









本地运行预览效果hexo s 和 hexo server 是 Hexo 博客框架中用于启动本地服务器的命令，同样完全等价的，可以互换使用，没有区别。
运行 hexo s 或 hexo server 命令时，Hexo 会启动一个本地服务器，用于在您的计算机上预览和测试生成的静态页面。您可以通过访问指定的本地地址（默认为 http://localhost:4000）来查看您的博客。
hexo shexo server











看到这样的默认页面就代表本地配置成功。
关闭本地运行键盘同时按下：Ctrl 和C
通过Git部署配置安装Git部署插件安装 Hexo 博客框架中的 Git 部署插件，并将其作为项目的依赖保存。hexo-deployer-git 是 Hexo 的一个部署插件，它通过 Git 版本控制系统来将生成的静态页面部署到远程服务器或托管平台上。
npm install hexo-deployer-git --save



通过执行命令后，安装插件到 Hexo 项目中，并添加到项目的 package.json 文件中的依赖列表中。
在执行 hexo deploy 或 hexo d 命令时，Hexo 将使用 Git 部署插件来将生成的页面提交到预先配置的远程 Git 仓库。
需要注意的是：在安装 hexo-deployer-git 插件之前，需要先在 Hexo 配置文件中进行相应的配置，包括指定部署的 Git 仓库地址、分支信息、用户名密码等。
也就是说，在安装 hexo-deployer-git 插件之前，提前在_config.yml文件中的deploy :type:中 填入git：








指定部署方式和相关配置打开目录下的_config.yml文件。
可以使用VS Code打开，或者记事本、Notepad++都可以。






找到文件最下方的 deploy，添加下列内容：
deploy:  type: 部署类型  repo: git@github.com:Github账号用户名/仓库名.git  branch: 分支名


type: 部署类型：指定部署的类型为 Git，表示使用 Git 作为部署的方式。
repo: git@github.com:Github账号用户名/仓库名.git：指定要部署到的仓库的 Git URL。
branch: 分支名：指定要将静态网页部署到的 Git 分支。在这个例子中，静态网页将被部署到名为 “main” 的分支。

例如：


deploy:  type: git  repo: git@github.com:KiraraKira/Kirara.github.io.git  branch: main

仓库所在的 GitHub 用户是 “KiraraKira”，部署目标是名为 “Kirara.github.io” 的仓库。通过配置，GitHub Pages 会将生成的静态网页部署到仓库中。
远程部署Github Pagehexo deploy 和 hexo d 命令是 Hexo 博客框架中用于部署生成的静态页面的命令，它们是完全等价的，可以互换使用，没有区别。
运行 hexo deploy 或 hexo d 命令时，Hexo 会根据您在配置文件中设置的部署信息，将生成的静态页面部署到相应的远程服务器或平台上，以便将博客内容发布到互联网上。
hexo dhexo deploy










查看远程部署效果在Github Pages页面找到 Visit site，点击就可以查看部署到远程的网页






如果远程的链接也能正常打开，就代表配置成功。










修改主题（以Arknights主题为例）Kiraraの游戏城使用了Arknights主题。具体配置请看github原作者的教程：https://github.com/Yue-plus/hexo-theme-arknights
下载主题在项目文件夹下打开git bash，输入：
git cloen 想要的主题链接

例如：
git clone https://github.com/Yue-plus/hexo-theme-arknights.git themes/arknights



修改配置文件以下引用自Arknight原作者的教程：


1.参照 Hexo 官网 修改 Hexo/ 目录下的 _config.yml。

2.把 theme: 的值改为 arknights

3.开启代码高亮：
highlight:  hljs: true



4.剪切 Hexo/themes/arknights/_config.yml 到 Hexo 目录下，并重命名为 _config.arknights.yml。

建议参考：

使用代替主题配置文件


主题的配置文件可参照中文注释修改。



教程解释：第一步和第二步
下载好主题文件后，打开根目录，找到_config.yml
修改_config.yml中的theme: landscape改为theme: arknights






教程解释：第四步
如下图，剪切主题文件夹中的_config.yml，重命名为：_config.arknights.yml，并粘贴至根目录文件夹下






然后重新执行hexo g来重新渲染静态页面：










修改网站介绍使用文本编辑器打开 Hexo 项目目录中的 _config.yml 文件，修改站点配置、主题配置、部署配置等
网站介绍相关配置解释
title：设置博客的标题。如：Kiraraの游戏城

subtitle：设置博客的副标题。例如：Kirara

description：设置博客的描述。例如：Kirara的个人主页

author：设置博客的作者。例如：Kirara

language：设置博客的语言。英文为en，中文为zh-CN，需要查看相应的主题使用。

timezone：设置博客的时区。

url：设置博客的 URL 地址。这里的博客URL地址为Github Page页面显示的地址




root：设置博客的根目录。

permalink：设置博客文章的永久链接格式。

date_format：设置博客文章日期的格式。








其他配置都可以自定义，可以按照需要自由修改
本地预览主题依次执行下面的命令，可以启动本地服务器预览：
hexo clean # 清除public文件夹下的所有文件hexo g # 将网页生成在public文件夹下hexo s # 启动本地服务器预览



hexo clean的命令是：清除public文件夹下的所有文件。

清除生成的静态页面：Hexo 在生成静态页面时会将生成的 HTML、CSS、JavaScript 等文件保存在指定的目录中，以便部署到服务器或托管平台上。hexo clean 命令会清除之前生成的静态页面，以便在下一次执行 hexo generate 命令时重新生成新的页面。

清除缓存文件：Hexo 在生成页面时会使用一些缓存文件来提高生成速度和效率。这些缓存文件存储在 .hexo 或 .cache 目录中。执行 hexo clean 命令会清除这些缓存文件，以便下次生成时重新计算和生成缓存。


执行 hexo clean 命令可以清理旧的生成文件和缓存，确保下一次生成的静态页面和缓存文件是基于最新的内容和配置。
在更新博客内容或更改 Hexo 配置时特别有用。
需要注意的是，执行 hexo clean 命令会删除之前生成的静态页面和缓存文件，因此请确保在执行该命令之前备份重要的数据








远程预览主题能够正常看到主题就代表主题安装成功








其他个性化设置个性化页面配置



更详细的个性化页面配置请参考：Hexo 博客美化合集（不断更新）
在Github Page发布文章创建一篇新文章hexo new &amp;quot;文章名&amp;quot;

创建成功后，可以在source文件夹的 _posts文件夹中找到新建的md文件。










打开md文件，在文件中写入文章内容。例如可以使用Typora来写入文章内容。
记得按 Ctrl  S 保存！
渲染静态页面hexo ghexo generate

(两个命令作用一样，任选一个使用即可)
在本地运行hexo shexo server

(两个命令作用一样，任选一个使用即可)
部署到远程站点hexo dhexo deploy

(两个命令作用一样，任选一个使用即可)
生成静态页面并将其部署到指定的远程服务器（快捷方式）hexo g -d 命令的效果等同于先运行 hexo g 命令生成静态页面，然后再运行 hexo d 命令将生成的静态页面部署到远程服务器。这个命令组合的便捷性在于省去了手动执行这两个命令的步骤，使得生成和部署过程更加简洁和快捷。
hexo g -d



刷新一下网站，就能看到新写的文章啦。
其他静态网站生成器除了 Hexo，还有其他类似的静态网站生成器可供选择，只不过因为Hexo有罗德岛的主题所以才选择用了Hexo。
例如：
Jekyll：Jekyll 是 GitHub Pages 的默认选择，它使用 Ruby 编程语言，具有强大的主题和插件。
Gatsby：Gatsby 是一个基于 React 的静态网站生成器，使用 GraphQL 查询语言来获取数据。
Hugo：Hugo 是一个快速的静态网站生成器，使用 Go 编程语言编写。
感兴趣想尝试的话可以试试这些静态网站生成器
GitHub Page自定义域名 (阿里云域名)参考文章：GitHub Pages个性化域名配置
DNS 解析域名购买完成之后，点击右上角 控制台，进入 域名 界面，选择域名列表，在你的域名一栏选择解析，进入 DNS 解析界面

在 DNS 解析界面添加如下两条记录

这样无论用户输入 www.emoryhuang.cn 还是只输入 emoryhuang.cn 都可以直接定位到网站了，记录值修改为你自己的 GitHub Pages 地址。
添加 CNAME 文件在 Hexo 本地目录中的 source 文件夹里，添加一个命名为 CNAME 的无后缀文件，文件中的填写你的域名
例如：
emoryhuang.cn

复制
hexo cleanhexo d -g

复制
Github Pages 添加自定义域名进入你的 GitHub 仓库，选择Setting -&amp;gt; Page，在 Custom domain 处添加你的自定义域名。


在完成上述步骤之后，就可以输入你的自定义域名访问你的网站了。
绮良Github Page网址https://kirarakira.github.io/Kirara.github.io/
值得参考的教程Tutorial:基于Hexo框架的GitHub个人主页搭建教程（前篇）
部署到 git 后 打开 GitHub Pages 为 404
上传内容以后页面一直是404？
网友的补充</content>
    <url>/2050/01/01/Github-Page%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
  </entry>
  <entry>
    <title>Electron学习笔记</title>
    <content>Electron学习笔记


Electron 简介Electron（官网：https://www.electronjs.org/zh/）是由Github开发，用HTML，CSS和JavaScript来构建跨平台桌面应用程序的一个开源框架。
官网消息2023.822.x.y 持续支持​正如再见 Windows 7&amp;#x2F;8&amp;#x2F;8.1 所述，Electron 22（Chromium 108）的计划寿命终止日期将从 2023 年 5 月 30 日延长至 2023 年 10 月 10 日。 Electron 团队将会继续向 Electron 22 提供本计划中的任何安全修复，直到 2023 年 10 月 10 日。 十月 支持日期遵循 Chromium 和 Microsoft 的延长支持日期。 10 月 11 日，Electron 团队将支持回退到最新的三个稳定主要版本，将不再支持 Windows 7&amp;#x2F;8&amp;#x2F;8.1。



E25（23 年 5 月）
E26（23 年 8月）
E27（23 年 10 月）



25.x.y
26.x.y
27.x.y


24.x.y
25.x.y
26.x.y


23.x.y
24.x.y
25.x.y


22.x.y
22.x.y
–


时间表


Electron
Alpha
Beta
Stable
EOL
Chrome
Node
Supported



26.0.0
2023-Jun-01
2023-Jun-27
2023-Aug-15
TBD
M116
TBD
√


25.0.0
2023-Apr-10
2023-May-02
2023-May-30
2024-Jan-02
M114
v18.15
√


24.0.0
2022-Feb-09
2023-Mar-07
2023-Apr-04
2023-Oct-10
M112
v18.14
√


摘自：Electron 25.0.0
Electron 特点Electron提供了易用的标记语法解析、绑定支持、灵活的布局排版、图形能力、数据处理、模板支持以及图形处理管线和插件拓展等功能。

易用性和标记语法解析：Electron使用HTML和类似于HTML的标记语法，让你可以轻松创建用户界面。它与Web技术紧密集成，你可以使用熟悉的标记语法来构建界面和布局。

支持绑定和组件：Electron可以使用JavaScript框架（如Vue.js、React等）来实现绑定和组件化开发。你可以使用这些框架实现数据绑定和构建可复用的组件，类似于Vue或React。

布局排版和插件拓展：Electron提供了灵活的CSS布局排版，你可以使用CSS进行多种布局。此外，Electron还允许你通过插件系统来进行布局的拓展，使你能够自定义和扩展布局功能。

图形能力和后处理管线：Electron支持强大的图形能力，你可以使用Canvas API或WebGL来实现延迟渲染和后处理管线（例如使用着色器）。这使得你可以处理复杂的图形渲染和效果。

数据处理和模板：通过JavaScript框架，你可以实现数据处理、触发器和数据前后期处理。此外，你可以使用JavaScript的动态特性来实现动态模板，根据设备数据的变化选择不同的模板。

图形处理管线和图形插件：Electron允许你使用图形处理管线和图形插件来增强渲染器的图形功能。你可以使用现有的图形库或编写自定义的图形插件来满足你的需求。


如何学习 Electron
Electron官方网站：Electron的官方网站是一个重要的学习资源，提供了全面的文档、API参考和示例代码。你可以在官方网站上找到最新的Electron版本、教程和社区资源。访问Electron的官方网站：https://www.electronjs.org/ ↗

Electron文档：Electron官方提供了详细的文档，涵盖了Electron的核心概念、API参考、应用程序架构和开发流程等内容。你可以在文档中找到关于窗口管理、文件系统访问、进程间通信等方面的信息。访问Electron的文档：https://www.electronjs.org/docs ↗

Electron API演示应用程序：Electron官方提供了一个API演示应用程序，其中包含了许多示例代码，涵盖了Electron的各种功能和用法。你可以通过浏览这些示例代码来学习Electron的具体用法和最佳实践。访问API演示应用程序：https://github.com/electron/electron-api-demos ↗

Electron Fiddle：Electron Fiddle是一个交互式的学习工具，它允许你在浏览器中编写和运行Electron代码片段。你可以使用Electron Fiddle来实验和学习Electron的各种功能和API。访问Electron Fiddle：https://www.electronjs.org/fiddle ↗

Electron社区资源：Electron拥有活跃的开发者社区，你可以通过访问Electron的论坛、GitHub存储库、Stack Overflow和其他开发者社区来获取帮助、参与讨论和分享经验。在Electron的官方网站上可以找到相关链接和资源。


安装 Electron (国内)安装 Node.js：首先，确保你的电脑上已经安装了 Node.js。你可以从 Node.js 官方网站（https://nodejs.org ↗）下载安装程序，并按照安装向导进行安装。
查看node和npm版本安装完成后，你可以在命令提示符或 PowerShell 中验证 Node.js 是否安装成功，通过运行以下命令：
node -v

如果成功显示 Node.js 的版本号，则表示安装成功。



创建Electron 项目在任意位置创建一个新的文件夹作为你的 Electron 项目目录。



进入项目目录：在命令提示符或 PowerShell 中，使用 cd 命令进入你的 Electron 项目目录。例如，如果你的项目目录在桌面上的一个名为 HelloWorld 的文件夹中，你可以运行以下命令进入该目录：
:Dcd D:\electorn\HelloWorld


更换npm国内源若原本的npm下载失败，尝试更换国内源
npm install -g cnpm --registry=https://registry.npm.taobao.org

（或）
npm config set registry https://registry.npm.taobao.org


使用 npm 进行全局安装在终端中运行以下命令来安装 Electron 作为项目的依赖项：这将在项目目录中安装最新版本的 Electron。
npm install electron -g

非全局安装：
npm install electron


这将下载并安装 Electron 及其相关依赖项。安装完成后，你的项目目录中将出现一个名为 node_modules 的文件夹，其中包含了 Electron 及其依赖项的文件。
检测是否安装成功安装好后，我们可以通过 -v 命令检测 electron 是否安装成功，命令如下所示：
electron -v

显示版本即为安装成功



其他命令：查看可提供的版本
npm view electron versions

初始化 npm在项目目录中运行以下命令，初始化 npm 项目，并按照提示填写项目相关信息：
npm init

这将生成一个 package.json 文件，其中包含了你的项目的配置信息。



创建入口main.js文件在项目目录中创建一个新的 JavaScript 文件，例如 main.js，作为 Electron 应用程序的入口文件。在 main.js 文件中编写你的 Electron 应用程序的代码。
const &amp;#123; app, BrowserWindow &amp;#125; = require(&amp;#x27;electron&amp;#x27;);function createWindow() &amp;#123;    const win = new BrowserWindow(&amp;#123;        width: 800,        height: 600,        webPreferences: &amp;#123;            nodeIntegration: true        &amp;#125;    &amp;#125;);    win.loadFile(&amp;#x27;index.html&amp;#x27;);&amp;#125;app.whenReady().then(createWindow);

这段代码创建了一个 Electron 窗口，并加载了一个名为 index.html 的文件。
创建html文件在项目目录中创建一个新的 HTML 文件，例如 index.html。打开 index.html 文件，并将以下代码粘贴到文件中：
&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;html&amp;gt;   &amp;lt;head&amp;gt;     &amp;lt;meta charset=&amp;quot;UTF-8&amp;quot;&amp;gt;     &amp;lt;title&amp;gt;Hello World&amp;lt;/title&amp;gt;   &amp;lt;/head&amp;gt;   &amp;lt;body&amp;gt;     &amp;lt;h1&amp;gt;Hello World!&amp;lt;/h1&amp;gt;   &amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;

这是一个简单的 HTML 文件，其中包含一个标题为 “Hello World!” 的 &amp;lt;h1&amp;gt; 元素。
运行 Electron 应用程序在项目目录中执行以下命令来启动 Electron 应用程序：
npx electron .

这将在 Electron 中打开一个窗口，并加载 index.html 文件。你应该能够看到一个包含 “Hello World!” 的窗口。
恭喜！你已经成功创建并运行了一个简单的 Electron HelloWorld 程序。你可以根据需要修改 index.html 文件来实现更复杂的界面和功能。



“Hello World” 文件结构 “Hello World” Electron 应用程序的文件结构通常如下所示：
my-electron-app/├── index.html├── main.js├── package.json






每个文件的作用：

index.html: 这是应用程序的主要 HTML 文件，用于定义应用程序的用户界面。你可以在其中添加 HTML、CSS 和 JavaScript 代码来创建你想要的界面和功能。

main.js: 这是 Electron 应用程序的主要启动文件。它包含了创建 Electron 窗口、加载 index.html 文件等核心功能代码。

package.json: 这是应用程序的配置文件，其中包含了应用程序的元数据、依赖项和脚本等信息。通过运行 npm init 命令可以生成这个文件，并在其中添加你的应用程序的相关信息。


这是一个最简单的 Electron 应用程序的文件结构，它包含一个 HTML 文件和一个 JavaScript 文件。
你可以根据需要对文件结构进行扩展和修改，例如添加其他的 HTML、CSS 和 JavaScript 文件，或者将资源文件（如图像、样式表等）放在适当的位置。
查看 Electron 版本号如果您的Electron应用程序已打包成可执行文件，则可以通过在命令行或PowerShell窗口中运行该文件，并添加–version参数来获取Electron的版本号。例如：
my-electron-app.exe --version

这将输出您的Electron应用程序所使用的Electron版本号。
升级 Electron 版本要升级Electron的版本，请按照以下步骤操作：

打开您的Electron应用程序的根目录并备份您的代码和配置文件。

在package.json文件中将Electron的版本号更新为您想要升级到的版本号，例如：


&amp;quot;dependencies&amp;quot;: &amp;#123;	&amp;quot;electron&amp;quot;: &amp;quot;^26.0.0&amp;quot;&amp;#125;



在命令行中运行以下命令，以安装新版本的Electron：

npm install

这将会安装package.json文件中指定的所有依赖项，包括新版本的Electron。

更新您的Electron应用程序的代码和配置文件，以适应新版本的Electron。在新版本的Electron中可能会有一些API更改或功能更新，因此您可能需要相应地更改您的应用程序代码和配置文件。

测试您的应用程序，确保它在新版本的Electron中正常运行。


请注意，升级Electron版本可能会导致应用程序出现不兼容或错误。因此，在升级之前，请确保备份您的代码和配置文件，并在测试之前进行更改。
清除 npm 缓存验证代理设置如果你在代理后面，请确保代理设置正确。你可以使用npm config命令检查和更新代理设置。在终端中运行以下命令：
npm config get proxynpm config get https-proxy

如果这些命令返回一个值，表示已配置代理。如果返回null，表示未设置代理
删除代理缓存如果代理设置不正确或者你不需要代理，可以使用以下命令删除它们：
npm config delete proxynpm config delete https-proxy

临时禁用代理：如果你正在使用代理，并怀疑它导致了问题，可以尝试临时禁用它，以查看npm能否正常连接注册表。
使用不同的注册表默认情况下，npm使用官方注册表（registry.npmjs.org）。尝试切换到其他注册表，看看是否可以解决问题。运行以下命令更改注册表：
npm config set registry https://registry.npmjs.org/

更改注册表后，再次尝试运行npm命令。
清除npm缓存有时，npm缓存的问题可能导致连接问题。你可以尝试通过运行以下命令来清除npm缓存：
npm cache clean --force

清除缓存后，再次尝试运行npm命令。
卸载 Electron要卸载 Electron，你可以按照以下步骤进行操作：
全局卸载
如果你在全局范围内安装了 Electron，请使用以下命令将其卸载：

使用 npm：
npm uninstall -g electron

如果你没有在全局范围内安装 Electron，则可以跳过此步骤。
本地卸载
如果你在你的项目目录中使用了本地安装的 Electron，请在项目目录下执行以下命令卸载 Electron：

使用 npm：
npm uninstall electron

这将从你的项目的 node_modules 目录中移除 Electron。
请注意，以上命令将仅移除 Electron 包本身，而不会删除你的应用程序代码和其他依赖项。
如果你想完全删除 Electron 相关的文件，你可以手动删除以下文件和目录：

从全局范围内安装的情况下，删除对应的 Electron 可执行文件的路径（例如 Windows 中的 C:\Users\your-username\AppData\Roaming\npm\node_modules\electron）。

从项目目录中删除 node_modules 目录中的 Electron 相关文件。

如果你使用了其他构建工具或打包工具（如 webpack、Parcel 或 Electron Builder），请根据相应工具的文档，删除和清理相关的配置文件和构建输出目录。


通过执行上述步骤，你将能够卸载 Electron。
报错信息及解决方式【查看版本时报错】’electron’ 不是内部或外部命令，也不是可运行的程序或批处理文件。
‘electron’ 不是内部或外部命令，也不是可运行的程序或批处理文件。

使用 electron -v 查看版本时显示：



这个错误表明你尝试在命令行中执行 electron 命令时，系统无法找到 electron 命令。
这通常是由于 Electron 没有正确安装或没有在全局范围内配置导致的。

安装 Electron：首先确保你已经在你的项目目录中通过 npm 或 yarn 安装了 Electron。在命令行中进入你的项目目录，并运行以下命令来安装 Electron：

npm install electron


检查全局安装：如果你希望在命令行中直接运行 electron 命令，你需要全局安装 Electron。使用以下命令来全局安装 Electron：

npm install -g electron

请注意，全局安装可能需要管理员权限。

检查环境变量：如果你已经正确安装了 Electron，但仍然无法在命令行中执行 electron 命令，可能是因为系统的环境变量配置不正确。确保你的系统环境变量中包含 Electron 的可执行文件的路径。

对于 Windows 用户，你可以检查以下路径是否在系统的 PATH 环境变量中：
C:\Users\your-username\AppData\Roaming\npm\node_modules\electron\dist

如果路径不在 PATH 环境变量中，可以手动将它添加进去。

使用 npx 运行：如果你只是想在命令行中临时运行 Electron，而不进行全局安装，你可以使用 npx 命令来执行 Electron。在命令行中进入你的项目目录，并执行以下命令：

npx electron

这将临时下载并运行最新版本的 Electron。
【安装时报错】npm ERR! RequestError: connect ETIMEDOUT 20.205.243.166:443npm ERR! code 1npm ERR! path D:\Electron\test1\node_modules\electronnpm ERR! command failednpm ERR! command C:\WINDOWS\system32\cmd.exe /d /s /c node install.jsnpm ERR! RequestError: connect ETIMEDOUT 20.205.243.166:443

这个错误表明在尝试安装 Electron 时，npm 遇到了连接超时的问题。
解决此问题的一种常见方法是切换 npm 的下载源。默认情况下，npm 使用的是官方的 npm registry，但有时该源可能遇到连接问题。
你可以尝试将 npm 源切换为国内的源，例如淘宝的 npm 镜像。请按照以下步骤进行操作：

打开命令行工具，并进入到你的 Electron 项目目录下。

运行以下命令，将 npm 源切换为淘宝的 npm 镜像：


npm config set registry https://registry.npm.taobao.org

这将把 npm 源设置为淘宝的源。

然后，再次运行 npm install 命令来安装 Electron：

npm install

这将使用淘宝的 npm 镜像来下载 Electron，以避免连接问题。
请注意，切换源可能会导致下载速度变慢，但能够解决连接超时的问题。如果仍然遇到问题，请确保你的网络连接正常，并检查防火墙或代理设置是否会阻止 npm 的网络访问。
【安装时报错】npm ERR! RequestError: read ECONNRESETnpm ERR! code 1npm ERR! path C:\Users\15234\AppData\Roaming\npm\node_modules\electronnpm ERR! command failednpm ERR! command C:\WINDOWS\system32\cmd.exe /d /s /c node install.jsnpm ERR! RequestError: read ECONNRESETnpm ERR!     at ClientRequest.&amp;lt;anonymous&amp;gt; (C:\Users\15234\AppData\Roaming\npm\node_modules\electron\node_modules\got\source\request-as-event-emitter.js:178:14)npm ERR!     at Object.onceWrapper (node:events:628:26)npm ERR!     at ClientRequest.emit (node:events:525:35)npm ERR!     at origin.emit (C:\Users\15234\AppData\Roaming\npm\node_modules\electron\node_modules\@szmarczak\http-timer\source\index.js:37:11)npm ERR!     at TLSSocket.socketErrorListener (node:_http_client:502:9)npm ERR!     at TLSSocket.emit (node:events:513:28)npm ERR!     at emitErrorNT (node:internal/streams/destroy:151:8)npm ERR!     at emitErrorCloseNT (node:internal/streams/destroy:116:3)npm ERR!     at process.processTicksAndRejections (node:internal/process/task_queues:82:21)npm ERR! A complete log of this run can be found in: C:\Users\15234\AppData\Local\npm-cache\_logs\2023-08-03T15_13_34_305Z-debug-0.log

这个错误消息表明在尝试安装Electron时，npm遇到了连接错误。具体来说，它显示了“RequestError: read ECONNRESET”错误，这意味着npm无法从服务器读取数据。
以下是一些可能的解决方案：

检查您的网络连接是否正常。尝试访问其他网站来确保您的网络连接正常。

尝试清除npm缓存，并重新运行npm install命令：


npm cache clean --forcenpm install


如果您使用的是代理，请确保npm已正确配置以使用代理服务器。您可以使用以下命令来设置代理：

npm config set proxy http://proxy.company.com:8080npm config set https-proxy http://proxy.company.com:8080

请将“proxy.company.com”替换为您的代理服务器地址和端口号。

如果您使用的是较旧版本的npm，请尝试升级npm版本并重新运行npm install命令。您可以使用以下命令来升级npm版本：

npm install -g npm@latest

这将会安装最新版本的npm。然后，您可以再次尝试运行npm install命令，查看是否已经解决了该问题。
请注意，如果您在尝试解决这个问题时对npm进行了更改，请注意备份您的代码和配置文件，并在测试之前仔细检查它们。
【安装时报错】npm ERR! path D:\electron&amp;#x2F;package.jsonD:\electron&amp;gt;npm installnpm ERR! code ENOENTnpm ERR! syscall opennpm ERR! path D:\electron/package.jsonnpm ERR! errno -4058npm ERR! enoent ENOENT: no such file or directory, open &amp;#x27;D:\electron\package.json&amp;#x27;npm ERR! enoent This is related to npm not being able to find a file.npm ERR! enoentnpm ERR! A complete log of this run can be found in: C:\Users\15234\AppData\Local\npm-cache\_logs\2023-08-03T11_58_08_529Z-debug-0.log


这个错误消息表明在D:\electron目录中找不到package.json文件，因此npm无法运行npm install命令。
请确保您在D:\electron目录中已经创建了一个package.json文件，并指定了您的Electron应用程序的名称、版本、依赖项等信息。如果没有创建该文件，请使用以下命令来创建它：
npm init

该命令将会引导您创建一个新的package.json文件，并询问您的应用程序的名称、版本、作者、许可证等信息。完成后，您可以在D:\electron目录下找到生成的package.json文件。
如果您已经创建了package.json文件，请确保文件名和路径名称是正确的，并且该文件位于D:\electron目录下。如果它不在该目录中，请将其移动到该目录下。
如果问题仍然存在，请尝试运行以下命令来清除npm的缓存，并重新运行npm install命令：
npm cache clean --force

然后再次尝试运行npm install命令。
请确保您在运行npm install命令之前已经在D:\electron文件夹中创建了一个package.json文件。您可以在该文件中指定您的应用程序的名称、版本、依赖项等信息。
如果您已经创建了package.json文件，那么可能是文件名或路径不正确。请检查文件名和路径是否正确，并确保您正在运行npm install命令的文件夹路径与package.json文件所在的路径相同。
此外，如果您使用的是较旧的npm版本，请尝试升级npm版本，并再次运行npm install命令。您可以使用以下命令来升级npm版本：
npm install -g npm@latest

这将会安装最新版本的npm。然后，您可以再次尝试运行npm install命令，查看是否已经解决了该问题。
【安装时报错】npm WARN cleanup Failed to remove some directoriesnpm WARN cleanup Failed to remove some directories [npm WARN cleanup   [npm WARN cleanup     &amp;#x27;D:\\Electron\\test1\\node_modules\\extract-zip&amp;#x27;,npm WARN cleanup     [Error: EPERM: operation not permitted, rmdir &amp;#x27;D:\Electron\test1\node_modules\extract-zip\node_modules&amp;#x27;] &amp;#123;npm WARN cleanup       errno: -4048,npm WARN cleanup       code: &amp;#x27;EPERM&amp;#x27;,npm WARN cleanup       syscall: &amp;#x27;rmdir&amp;#x27;,npm WARN cleanup       path: &amp;#x27;D:\\Electron\\test1\\node_modules\\extract-zip\\node_modules&amp;#x27;npm WARN cleanup     &amp;#125;npm WARN cleanup   ]npm WARN cleanup ]

在尝试安装 Electron 时，npm 遇到了：
npm WARN cleanup：在清理过程中无法删除某些目录。具体是 D:\Electron\test1\node_modules\extract-zip\node_modules 目录无法被删除，导致了警告。这可能是由于权限不足或其他操作系统相关的问题导致的。

权限问题：确保你有足够的权限来删除目录。你可以尝试在命令行中以管理员权限运行安装命令，或者手动删除 D:\Electron\test1\node_modules\extract-zip\node_modules 目录。

【运行时报错】npm ERR!  Missing script: “start”npm ERR! Missing script: &amp;quot;start&amp;quot;npm ERR!npm ERR! Did you mean one of these?npm ERR!     npm star # Mark your favorite packagesnpm ERR!     npm stars # View packages marked as favoritesnpm ERR!npm ERR! To see a list of scripts, run:npm ERR!   npm runnpm ERR! A complete log of this run can be found in:npm ERR!     C:\Users\15234\AppData\Local\npm-cache\_logs\2023-08-03T08_07_03_419Z-debug-0.log

缺少脚本：“start”错误信息提示缺少名为 “start” 的脚本，同时给出了一些可能的替代命令。

确认你在正确的目录中运行 npm 命令。你应该在包含 package.json 文件的应用程序根目录下运行 npm 命令。

检查你的 package.json 文件，确保其中包含了一个名为 “start” 的脚本。 &amp;quot;scripts&amp;quot; 部分应该包含 &amp;quot;start&amp;quot; 字段，并且对应的值应该是你启动应用程序的命令。


示例 package.json 文件中的 &amp;quot;scripts&amp;quot; 部分：
&amp;quot;scripts&amp;quot;: &amp;#123;	&amp;quot;start&amp;quot;: &amp;quot;electron .&amp;quot;&amp;#125;

如果你的 package.json 文件中没有 “start” 脚本，你可以根据你的需求添加它。



如图，启动应用程序的命令为：
npx electron .



【运行时报错】Unable to find Electron app at D:\ElectronError launching appUnable to find Electron app at D:\ElectronCannot find module &amp;#x27;D:\Electron&amp;#x27;Require stack:C:\Users\15234VAppData\LocalNnpm-cachel_npx\1323dbbc85759269\node... main.js






根据提供的错误信息，出现了一个与 Electron 应用程序启动相关的错误。错误信息显示了以下内容：
Error launching appUnable to find Electron app at D:\ElectronCannot find module &amp;#x27;D:\Electron&amp;#x27;Require stack:C:\Users\15234VAppData\LocalNnpm-cachel_npx\1323dbbc85759269\node... main.js

这个错误表明 Electron 无法找到位于 D:\Electron 目录下的应用程序，并且在 D:\Electron 目录中找不到名为 D:\Electron 的模块。
请注意，根据提供的错误信息，似乎存在一个路径错误。错误信息中的路径为 D:\Electron，它被认为是一个模块路径，而不是一个应用程序路径。
请按照以下步骤检查和解决这个问题：

检查应用程序路径：确认应用程序所在的路径是否正确。检查路径中的拼写错误、缺少斜杠等问题。

检查启动命令：确保你在启动 Electron 应用程序时使用了正确的命令。常见的启动命令是 electron . 或者 electron main.js。确保命令中的路径和文件名与你的项目结构一致。

确认应用程序目录结构：在应用程序的目录中，确保存在一个有效的 package.json 文件和一个入口文件（通常命名为 main.js 或 index.js）。package.json 文件应包含一个有效的 &amp;quot;main&amp;quot; 入口字段，指向你的应用程序的入口文件。


【运行时报错】Unable to find Electron app at D:\Electron\my-electron-appError launching appUnable to find Electron app at D:\Electron\my-electron-appCannot find module &amp;#x27;D:\Electron\my-electron-app\index.js&amp;#x27;. Please verify that the package.json has a valid &amp;quot;main&amp;quot; entry




错误启动应用程序无法在 D:\electron\my-electron-app 找到 Electron 应用程序无法找到模块 ‘D:\electron\my-electron-app\index.js’。请验证 package.json 文件中是否有有效的 “main” 入口
这个错误提示表明在指定的路径 D:\Electron\my-electron-app 下找不到 Electron 应用程序。同时，它还指出需要验证 package.json 文件中是否有有效的 &amp;quot;main&amp;quot; 入口。
请确保以下几点：

检查指定的路径是否正确，确保你的 Electron 应用程序确实存在于 D:\Electron\my-electron-app 目录中。

验证 package.json 文件是否存在，并且确保其中包含了有效的 &amp;quot;main&amp;quot; 入口。&amp;quot;main&amp;quot; 入口应该指向 Electron 应用程序的主要启动文件（通常是 index.js 或 main.js）。

可能是 Electron 版本不匹配。最新的 Electron 版本可能已经更新，因此旧版本的 Electron 可能无法正常工作。


为了解决这个问题，你可以尝试更新 Electron 的版本，或者使用一个更稳定的版本。以下是更新 package.json 文件的示例，将 Electron 版本更新为最新版本：
&amp;#123;  &amp;quot;name&amp;quot;: &amp;quot;test1&amp;quot;,  &amp;quot;version&amp;quot;: &amp;quot;1.0.0&amp;quot;,  &amp;quot;description&amp;quot;: &amp;quot;&amp;quot;,  &amp;quot;main&amp;quot;: &amp;quot;index.js&amp;quot;,  &amp;quot;scripts&amp;quot;: &amp;#123;    &amp;quot;start&amp;quot;: &amp;quot;electron .&amp;quot;  &amp;#125;,  &amp;quot;keywords&amp;quot;: [],  &amp;quot;author&amp;quot;: &amp;quot;&amp;quot;,  &amp;quot;license&amp;quot;: &amp;quot;ISC&amp;quot;,  &amp;quot;dependencies&amp;quot;: &amp;#123;    &amp;quot;electron&amp;quot;: &amp;quot;^25.4.0&amp;quot;  &amp;#125;&amp;#125;

在这个示例中，我将 Electron 版本更新为 &amp;quot;^25.4.0&amp;quot;，这是一个较新且稳定的版本。请注意，你也可以使用其他版本号，但建议使用较新的稳定版本。
更新 package.json 文件后，运行 npm install 命令来安装最新版本的 Electron：
npm install

然后，尝试再次启动 Electron 应用程序：
npm start


示例 package.json 文件：
   &amp;#123;	&amp;quot;name&amp;quot;: &amp;quot;my-electron-app&amp;quot;,    &amp;quot;version&amp;quot;: &amp;quot;1.0.0&amp;quot;,    &amp;quot;main&amp;quot;: &amp;quot;index.js&amp;quot;,    &amp;quot;scripts&amp;quot;: &amp;#123;	    &amp;quot;start&amp;quot;: &amp;quot;electron .&amp;quot;	&amp;#125;,    &amp;quot;dependencies&amp;quot;: &amp;#123;	    &amp;quot;electron&amp;quot;: &amp;quot;^25.4.0&amp;quot;    &amp;#125;&amp;#125;

请确保 &amp;quot;main&amp;quot; 字段的值正确指向你的应用程序的主要启动文件。

确保你已经在应用程序的根目录下运行了正确的命令来启动 Electron 应用程序。通常，可以使用如下命令来启动应用程序：

electron .

这将在当前目录下查找 package.json 文件，并使用 &amp;quot;main&amp;quot; 字段指定的入口文件来启动 Electron 应用程序。
Hello World示例package.json&amp;#123;    &amp;quot;dependencies&amp;quot;: &amp;#123;        &amp;quot;electron&amp;quot;: &amp;quot;^25.4.0&amp;quot;    &amp;#125;,    &amp;quot;name&amp;quot;: &amp;quot;helloworld&amp;quot;,    &amp;quot;version&amp;quot;: &amp;quot;1.0.0&amp;quot;,    &amp;quot;main&amp;quot;: &amp;quot;main.js&amp;quot;,    &amp;quot;devDependencies&amp;quot;: &amp;#123;&amp;#125;,    &amp;quot;scripts&amp;quot;: &amp;#123;        &amp;quot;start&amp;quot;: &amp;quot;electron .&amp;quot;    &amp;#125;,    &amp;quot;author&amp;quot;: &amp;quot;mor&amp;quot;,    &amp;quot;license&amp;quot;: &amp;quot;ISC&amp;quot;,    &amp;quot;description&amp;quot;: &amp;quot;^25.4.0&amp;quot;&amp;#125;



index.html&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;html&amp;gt;&amp;lt;head&amp;gt;    &amp;lt;meta charset=&amp;quot;UTF-8&amp;quot;&amp;gt;    &amp;lt;title&amp;gt;Hello World&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt;&amp;lt;body&amp;gt;    &amp;lt;h1&amp;gt;Hello World!&amp;lt;/h1&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;


main.jsconst &amp;#123; app, BrowserWindow &amp;#125; = require(&amp;#x27;electron&amp;#x27;);function createWindow() &amp;#123;    const win = new BrowserWindow(&amp;#123;        width: 800,        height: 600,        webPreferences: &amp;#123;            nodeIntegration: true        &amp;#125;    &amp;#125;);    win.loadFile(&amp;#x27;index.html&amp;#x27;);&amp;#125;app.whenReady().then(createWindow);


参考资料
Electron详解（一）：基本介绍Electron详解（二）：基本使用与项目打包Electron简介、安装、实践React使用Electron开发桌面端

</content>
    <url>/2023/08/03/Electron%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
  </entry>
  <entry>
    <title>HTML学习笔记</title>
    <content>HTML学习笔记


前置知识Web结构 : HTML(超文本标记语言)
表现 : CSS(层叠样式表)
行为 : JavaScript(脚本语言)
参考文章 : Web 和 Web标准
文档参考网站 :MDN(推荐)
W3School(推荐)
菜鸟教程
书籍推荐 ( 英文原版 ) :Head First - HTML with CSS &amp;amp; XHTML
Head First HTML5 Programming Building Web Apps with JavaScript
(添加桌面pdf文件)
基本快捷键Ctrl + C 复制
Ctrl + V 粘贴
Ctrl + X 剪切
Ctrl + Z 撤销
Ctrl + &amp;#x2F; 注释
Ctrl + S 保存
Ctrl + F 查找
基本快捷键
常用快捷键
编辑器Sublime Text
HbuliderX
visual studio code
WebStorm10
DWCS6
浏览器分类IE  内核Trident
Firefox(火狐)  内核Gecko
Safari  内核Webkit
Chrome(谷歌)  Oprea  内核Blik
Edge  内核Chromiun和Blink
网络协议http
参考文章 : HTTP
https
参考文章 : HTTPS
怪异模式和标准模式参考文章 : 怪异模式和标准模式
标准浏览器Web标准&amp;#x2F;W3C(万维网联盟)
参考文章 : W3C标准
W3C简介
VScode快捷键快速生成HTML骨架快捷键

英文”!” + Tab
英文”!” + Enter
html + : (既英文冒号) + 5

Ctrl + Enter 双标签中转为下一行
Shift + Alt + ↓ 双标签中向下复制整行
HTML定义超文本标记语言
HTML 标记标签通常被称为 HTML 标签 (HTML tag)
参考文章 : 开始学习HTML
HTML简介
基本结构&amp;lt;html&amp;gt;    &amp;lt;head&amp;gt;        &amp;lt;title&amp;gt;网页标题&amp;lt;/title&amp;gt;    &amp;lt;/head&amp;gt;    &amp;lt;boby&amp;gt;    网页内容    &amp;lt;/boby&amp;gt;&amp;lt;/html&amp;gt;

参考文件 : HTML头部
语言&amp;lt;html lang=&amp;quot;en&amp;quot;&amp;gt;    &amp;lt;!-- en英文  zh-CN中文  fr法文--&amp;gt;&amp;lt;/html&amp;gt;

参考文章 : HTML语言代码参考手册
字符集Charset&amp;lt;head&amp;gt;    &amp;lt;meta Charset=&amp;quot; &amp;quot;&amp;gt;    &amp;lt;!-- GB2312简体中文  BIG5繁体中文  GBK简体繁体中文  UTF-8(utf-8)所有语言--&amp;gt;    &amp;lt;/head&amp;gt;

参考文章 : HTML编码(字符集)
注释&amp;lt;html&amp;gt;     &amp;lt;!-- 注释 --&amp;gt;&amp;lt;/html&amp;gt;

参考文章 : HTML注释
基本约定参考文章 : HTML(5)样式指南和代码约定
元素元素( Element )指的是从开始标签（start tag）到结束标签（end tag）的所有代码
参考文章 : Element元素
HTML元素
HTML5 语义元素
块级元素(块元素)独占一行 , 只能出现在&amp;lt;body&amp;gt; &amp;lt;/body&amp;gt;元素内。
例 : 
 &amp;lt;h1&amp;gt;~&amp;#96;&amp;#96; &amp;lt;form&amp;gt; dl   &amp;lt;dd&amp;gt; &amp;lt;hr&amp;gt;  &amp;lt;ol&amp;gt; &amp;lt;ul&amp;gt;  &amp;lt;p&amp;gt; &amp;lt;table&amp;gt; &amp;lt;div&amp;gt; &amp;lt;adress&amp;gt; , &amp;lt;article&amp;gt; , &amp;lt;aside&amp;gt; , &amp;lt;bolckquote&amp;gt; , &amp;lt;fieldest&amp;gt; , &amp;lt;figcaption&amp;gt; , &amp;lt;figure&amp;gt; , &amp;lt;footer&amp;gt;, &amp;lt;header , &amp;lt;hgroup&amp;gt;, ,&amp;lt;pre&amp;gt; , &amp;lt;section&amp;gt; , 
参考文章 : 块级元素
行内元素(内联元素)只占据它对应标签的边框所包含的空间。
例 : &amp;lt;b&amp;gt; &amp;lt;strong&amp;gt; —— 字体加粗 
&amp;lt;big&amp;gt;  &amp;lt;small&amp;gt; —— 字体改变大小
 &amp;lt;i&amp;gt;  &amp;lt;em&amp;gt;  —— 字体倾斜
&amp;lt;u&amp;gt; &amp;lt;ins&amp;gt; —— 字体添加下划线
&amp;lt;s&amp;gt;  &amp;lt;del&amp;gt;  —— 字体添加删除线
&amp;lt;br&amp;gt; —— 换行
&amp;lt;input&amp;gt;  &amp;lt;textarea&amp;gt; &amp;lt;img&amp;gt; —— 添加图片&amp;lt;span&amp;gt;
 &amp;lt;q&amp;gt;  ——引用标签
&amp;lt;label&amp;gt;—— 定义标注标签 , 配合&amp;lt;input&amp;gt;按钮使用增加用户体验 
 &amp;lt;tt&amp;gt; , &amp;lt;abbr&amp;gt; , &amp;lt;acronym&amp;gt; , &amp;lt;cite&amp;gt; , &amp;lt;code&amp;gt; , &amp;lt;dfn&amp;gt; ,  &amp;lt;kbd&amp;gt; ,  &amp;lt;samp&amp;gt;, &amp;lt;var.a&amp;gt; , &amp;lt;bdo&amp;gt;,  , &amp;lt;map&amp;gt; , &amp;lt;object&amp;gt; ,,  &amp;lt;script&amp;gt;,  , &amp;lt;sub&amp;gt; , &amp;lt;supbutton&amp;gt; ,&amp;lt;select&amp;gt; 
参考文章 : 行内元素
HYMLdiv和span
标签声明标签&amp;lt;head&amp;gt;    &amp;lt;!DOCTYPE&amp;gt;    &amp;lt;!-- 文档类型声明标签 --&amp;gt;    &amp;lt;!-- doc文档,type类型 --&amp;gt;&amp;lt;/head&amp;gt;

参考文章 : HTML&amp;lt;!DOCTYPE&amp;gt;
根标签&amp;lt;html&amp;gt;  &amp;lt;/html&amp;gt;
骨架标签&amp;lt;html&amp;gt;	&amp;lt;head&amp;gt;        &amp;lt;title&amp;gt;        &amp;lt;/title&amp;gt;	&amp;lt;/head&amp;gt;	&amp;lt;body&amp;gt;	&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;



&amp;lt;meta&amp;gt; 标签提供有关页面的元信息。位于文档的头部，不包含任何内容。 在 HTML 中， 标签没有结束标签。
参考文章 : HTMLmeta标签
双标签标题标签&amp;lt;h1&amp;gt;&amp;lt;/h1&amp;gt;~&amp;#96;&amp;#96;
参考文章 : HTML标题
h1–h6：HTML 区域标题元素
段落标签&amp;lt;p&amp;gt;&amp;lt;/p&amp;gt;
可根据浏览器页面大小改变每行字数
参考文章 : HTML段落
p
盒子标签&amp;lt;div&amp;gt; &amp;lt;/div&amp;gt; —— 单独占一行 , 此标签内可存放任何标签和内容
参考文章 : div：内容划分元素
&amp;lt;span&amp;gt; &amp;lt;/span&amp;gt; —— 一行可存在多个
等
参考文章 : span
有序列表标签&amp;lt;ol&amp;gt; &amp;lt;/ol&amp;gt; , &amp;lt;li&amp;gt; &amp;lt;/li&amp;gt;
&amp;lt;li&amp;gt; &amp;lt;/li&amp;gt; —— 标签内可存放任何标签和内容
&amp;lt;body&amp;gt;    &amp;lt;ul&amp;gt;        &amp;lt;li&amp;gt;内容&amp;lt;/li&amp;gt;        &amp;lt;li&amp;gt;内容&amp;lt;/li&amp;gt;    &amp;lt;/ul&amp;gt;&amp;lt;/body&amp;gt;

参考文章 : ol
无序列表标签&amp;lt;ul&amp;gt; &amp;lt;/ul&amp;gt; , &amp;lt;li&amp;gt; &amp;lt;/li&amp;gt;
&amp;lt;li&amp;gt; &amp;lt;/li&amp;gt; —— 标签内可存放任何标签和内容
&amp;lt;body&amp;gt;    &amp;lt;ol&amp;gt;        &amp;lt;li&amp;gt;内容&amp;lt;/li&amp;gt;        &amp;lt;li&amp;gt;内容&amp;lt;/li&amp;gt;    &amp;lt;/ol&amp;gt;&amp;lt;/body&amp;gt;

参考文章 : ul
自定义列表标签&amp;lt;dl&amp;gt; &amp;lt;/dl&amp;gt; , &amp;lt;dt&amp;gt; &amp;lt;/dt&amp;gt; , &amp;lt;dd&amp;gt; &amp;lt;/dd&amp;gt;
dt只有一个 , dd有很多个
&amp;lt;body&amp;gt;    &amp;lt;dl&amp;gt;        &amp;lt;dt&amp;gt;&amp;lt;/dt&amp;gt;        &amp;lt;dd&amp;gt;&amp;lt;/dd&amp;gt;        &amp;lt;dd&amp;gt;&amp;lt;/dd&amp;gt;    &amp;lt;/dl&amp;gt;&amp;lt;/body&amp;gt;

参考文章 : 
参考文章 : HTML列表
单标签&amp;lt;br&amp;gt;或&amp;lt;br/&amp;gt;—— 换行 ( 只能在HTML5中去掉 “&amp;#x2F;“ ) ,
&amp;lt;nobr&amp;gt;或&amp;lt;nobr/&amp;gt; —— 不换行 , 
&amp;lt;hr&amp;gt;或&amp;lt;hr/&amp;gt; —— 水平线 , 
&amp;lt;img&amp;gt; —— (必带属性 : src=&amp;quot; ”) 插入图片 , 
&amp;lt;input&amp;gt; —— 输入，表单控件 ,  
&amp;lt;link&amp;gt; —— 链接，关联
等
实体参考文章 : HTML字符实体
HTML符号
空格实体&amp;amp;nbsp; —— 不换行空格 , 既空格键 
&amp;amp;ensp; ——半角空格 , 字体度的一半
&amp;amp;emsp; —— 全角空格 , 16px 
&amp;amp;thinsp; ——窄空格 
&amp;amp;zwnj; ——零宽不连字 
&amp;amp;zwj;  —— 零宽连字 
参考文章：HTML中的&amp;amp; nbsp; &amp;amp; ensp; &amp;amp; emsp;等6种空格标记
路径相对路径(常用)../ —— 向上一个文件夹返回查找文件 , 不能跨储存盘
./ —— 可查找当前根目录所有文件
绝对路径\ ——可跨储存盘
或直接输入文件地址
参考文章 : HTML文件路径
路径
图片直接插入图片 : 
&amp;lt;body&amp;gt;    &amp;lt;img src=&amp;quot;&amp;quot;&amp;gt;&amp;lt;/body&amp;gt;

图片替换的文字 : alt=&amp;quot; &amp;quot;
提示文本 : title=&amp;quot;  &amp;quot;
修改图片大小 : 图片的width(宽)和height(高)可一起修改 , 若只写其中一个 , 图片等比例缩放
参考文章 : HTML图像
img：图像嵌入元素
链接链接外地网址 :&amp;lt;body&amp;gt;    &amp;lt;a href=&amp;quot;&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;    &amp;lt;!--不写target属性则默认在当前网页打开--&amp;gt;    &amp;lt;!--target=&amp;quot;_self&amp;quot;在当前网页打开--&amp;gt;    &amp;lt;!--target=&amp;quot;_blank&amp;quot;在新的网页打开--&amp;gt;&amp;lt;/body&amp;gt;



链接内部网址
添加其他的html文件 : &amp;lt;a href=&amp;quot;&amp;quot;(文件位置)&amp;gt;&amp;lt;/a&amp;gt;

回到顶部 : &amp;lt;a href=&amp;quot; &amp;quot;&amp;gt; 或 &amp;lt;a href=&amp;quot;#&amp;quot;&amp;gt;

不回顶部 : &amp;lt;a href=&amp;quot;javascript:;&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;


下载链接添加zip文件 : &amp;lt;a href=&amp;quot; &amp;quot;(zip文件位置)&amp;gt;&amp;lt;/a&amp;gt;
锚链接寻找 : &amp;lt;a href=&amp;quot;#+锚链接名字&amp;quot;&amp;gt;名字&amp;lt;/a&amp;gt;
定位 : &amp;lt;id = &amp;quot;锚链接名字&amp;quot;&amp;gt;
参考文章 : HTML链接
表格表格标签&amp;lt;table&amp;gt; &amp;lt;/table&amp;gt;——表格
&amp;lt;tbody&amp;gt; &amp;lt;/tbody&amp;gt; ——表格主体
&amp;lt;thead&amp;gt; &amp;lt;/thead&amp;gt; ——表格头部
&amp;lt;th&amp;gt; &amp;lt;/th&amp;gt; ——表头单元格
&amp;lt;tr&amp;gt; &amp;lt;/tr&amp;gt; ——行
&amp;lt;td&amp;gt; &amp;lt;/td&amp;gt;——单元格
&amp;lt;ul&amp;gt;&amp;lt;lul&amp;gt;——无序的列表
&amp;lt;li&amp;gt;&amp;lt;/li&amp;gt;——列表项
表格属性height ——表格高
width ———表格宽
border ———表格边框——默认1 , “ “——代表没有边框
align ———表格对齐方式
lift——居左
center ———居中
right ——居右
cellpadding ——像素值——单元格与内容的距离——默认1像素
cellspacing ——像素值——单元格之间距离——默认2像素
合并表格跨行合并——rowspan=&amp;quot;——从上到下合并，最上面开始，以下删除跨列合并——colspan=&amp;quot; &amp;quot;——从左到右合并，最左边开始，以右删除
参考文章 : table 
HTML表格
表单表单在网页中主要负责数据采集的功能，和向服务器传送数据
表单标签 : 包含了处理表单数据所用 CGI 程序的 URL, 以及数据提交到服务器的方法
 表单域 : 包含了文本框、密码框、隐藏域、多行文本框、复选框、单选框、下拉选择框、和文件上传框等。
表单按钮 :包括提交按钮，复位按钮和一般按钮；用于将数据传送到服务器上的 CGI 脚本或者取消输入，还可以用表单按钮来控制其他定义了处理脚本的处理工作。
后台地址 : xxx.php
参考文章 : HTML表单
HTML表单属性
HTML表单元素
HTML输入类型
HTML input属性
input
表单控件 :&amp;lt;input&amp;gt; : 输入列表  &amp;lt;input type=&amp;quot;属性值&amp;quot;&amp;gt; 
默认属性值为text , 即 &amp;lt;input type=&amp;quot;text&amp;quot;&amp;gt; , 文本框 , 单行 , 默认20个字符
password : 密码框
value : 规定input元素的值 , 用户自定义
placehloder : 占位符 , 提示作用
select : 下拉列表
&amp;lt;body&amp;gt;    &amp;lt;form&amp;gt;        &amp;lt;select&amp;gt;            &amp;lt;option&amp;gt;&amp;lt;/option&amp;gt;            &amp;lt;option&amp;gt;&amp;lt;/option&amp;gt;            &amp;lt;!--至少要含有一对option标签--&amp;gt;        &amp;lt;/select&amp;gt;    &amp;lt;/form&amp;gt;&amp;lt;/body&amp;gt;

&amp;lt;textare&amp;gt; : 文本域 : 文本框可放大缩小
&amp;lt;textare cols=&amp;quot; &amp;quot;(每行的字数)&amp;gt;(一般用css制作)
&amp;lt;textare rows=&amp;quot;  &amp;quot;(显示的行数)&amp;gt;(一般用css制作)
参考文章 : input
textarea
只能在表单内使用的按钮(可放入图标&amp;#x2F;图片)
&amp;lt;input type=&amp;quot;submit&amp;quot;&amp;gt; : 默认按钮内文字 “ 提交 “ 
&amp;lt;input type=&amp;quot;reset&amp;quot;&amp;gt; : 默认功能重置 , 清除以上所有信息
按钮没有位置限制的按钮 : 
&amp;lt;input type=&amp;quot;button&amp;quot;&amp;gt; : 普通按钮 , 没有实质作用 , 需后期js添加功能
&amp;lt;button&amp;gt; &amp;lt;/button&amp;gt; 
参考文章 : button
上传文件的按钮 : 
&amp;lt;input type=&amp;quot;file&amp;quot;&amp;gt;





图片按钮 : 
`&amp;lt;input type=&amp;quot;image src=&amp;quot; &amp;quot; &amp;quot;&amp;gt;







隐藏域
hidden : 属性 , 隐藏的输入字段 , 不给用户使用 , 程序员写给后台进行其他用途
参考文章 : hidden
思维导图



</content>
    <url>/2021/01/23/HTML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
  </entry>
  <entry>
    <title>Hello</title>
    <content>你好！我是馍馍，今天是2020-08-01日，我部署了个人博客。
期待日后发布各种内容。
</content>
    <url>/2020/08/01/Hello/</url>
  </entry>
  <entry>
    <title>JavaScript 数据类型转换-JS中的字符串是不是对象</title>
    <content>这个问题困扰了很久，在阅读了大量文献和参与了众多讨论后终于寻得了一个可靠合理的解释。
本文在解释 “JS中的字符串是不是对象” 这个问题之前铺垫了许多前置知识，例如JS数据类型、JS对象、JS数据类型转换。
若想直接获得问题的答案，寻找目录中的“总结”查看即可。



JavaScript 数据类型在MDN官网中，对于“数据结构和类型（Data structures and types）”这一概念是这样介绍的：
MDN
Data typesThe latest ECMAScript standard defines eight data types:

Seven data types that are primitives:


Boolean. true and false.
null. A special keyword denoting a null value. (Because JavaScript is case-sensitive, null is not the same as Null, NULL, or any other variant.)
undefined. A top-level property whose value is not defined.
Number. An integer or floating point number. For example: 42 or 3.14159.
BigInt. An integer with arbitrary precision. For example: 9007199254740992n.
String. A sequence of characters that represent a text value. For example: &amp;quot;Howdy&amp;quot;.
Symbol. A data type whose instances are unique and immutable.


and Object



Although these data types are relatively few, they enable you to perform useful operations with your applications. Functions are the other fundamental elements of the language. While functions are technically a kind of object, you can think of objects as named containers for values, and functions as procedures that your script can perform.


最新的 ECMAScript 标准定义了 8 种数据类型：

七种基本数据类型：
布尔值（Boolean），有 2 个值分别是：true 和 false。
null，一个表明 null 值的特殊关键字。JavaScript 是大小写敏感的，因此 null 与 Null、NULL或变体完全不同。
undefined，和 null 一样是一个特殊的关键字，undefined 表示变量未赋值时的属性。
数字（Number），整数或浮点数，例如： 42 或者 3.14159。
任意精度的整数（BigInt），可以安全地存储和操作大整数，甚至可以超过数字的安全整数限制。
字符串（String），字符串是一串表示文本值的字符序列，例如：&amp;quot;Howdy&amp;quot;。
代表（Symbol，在 ECMAScript 6 中新添加的类型）。一种实例是唯一且不可改变的数据类型。
以及对象（Object）。



虽然这些数据类型相对来说比较少，但是通过他们你可以在程序中开发有用的功能。对象和函数是这门语言的另外两个基本元素。你可以把对象当作存放值的一个命名容器，然后将函数当作你的程序能够执行的步骤。


在MDN的描述中，JavaScript的数据类型分类如下：
基本数据类型（Seven data types）：Boolean， null， undefined， Number， Bigint， String， Symbol对象（Object）：包含Array，Function等

再来看W3C对于数据类型的解释：
W3C
JavaScript 数据类型字符串值，数值，布尔值，数组，对象。
JavaScript 数据类型JavaScript 变量能够保存多种数据类型：数值、字符串值、数组、对象等等：

var length = 7;                             // 数字var lastName = &amp;quot;Gates&amp;quot;;                      // 字符串var cars = [&amp;quot;Porsche&amp;quot;, &amp;quot;Volvo&amp;quot;, &amp;quot;BMW&amp;quot;];         // 数组var x = &amp;#123;firstName:&amp;quot;Bill&amp;quot;, lastName:&amp;quot;Gates&amp;quot;&amp;#125;;    // 对象

数据类型的概念在编程过程中，数据类型是重要的概念。为了能够操作变量，了解数据类型是很重要的。
ECMAScript 有 5 种原始类型（primitive type），即 Undefined、 Null、 Boolean、 Number 和 String。原始数据原始数据值是一种没有额外属性和方法的单一简单数据值。typeof 运算符可返回以下原始类型之一：

string
number
boolean
undefined请不要把字符串、数值和布尔值声明为对象！如果通过关键词”new”声明JavaScript量，则该变 量会被创建为对象:


var X = new String();//把x声明为String 对象&amp;gt;var y = new Number();//把y声明为Number 对象var z = new Boolean();//把z声明为Boolean对象

请避免字符串、数值或逻辑对象。他们会增加代码的复杂性并降低执行速度。您将在本教程的稍后章节学到更多有关对象的知识。
复杂数据typeof 运算符可返回以下两种类型之一：

function
objecttypeof 运算符把对象、数组或 null 返回 object。typeof 运算符不会把函数返回 object。

引用类型通常叫做类（class）。 也就是说，遇到引用值，所处理的就是对象。本教程会讨论大量的 ECMAScript 预定义引用类型。从现在起，将重点讨论与已经讨论过的原始类型紧密相关的引用类型。
注意：从传统意义上来说，ECMAScript 并不真正具有类。事实上，除了说明不存在类，在 ECMA-262 中根本没有出现“类”这个词。ECMAScript 定义了“对象定义”，逻辑上等价于其他程序设计语言中的类。提示：本教程将使用术语“对象”。对象是由 new 运算符加上要实例化的对象的名字创建的。
Object 对象Object 对象自身用处不大，不过在了解其他类之前，还是应该了解它。因为 ECMAScript 中的 Object 对象与 Java 中的 java.lang.Object 相似，ECMAScript 中的所有对象都由这个对象继承而来，Object 对象中的所有属性和方法都会出现在其他对象中，所以理解了 Object 对象，就可以更好地理解其他对象。


在W3C的描述中，JavaScript的数据类型分类如下：
原始类型（primitive type）：Undefined、 Null、 Boolean、 Number 和 String引用类型（对象）（Object）：Object
尽管MDN官网和W3C的官网描述并不完全一致，但可以明确的一点是：尽管在JavaScript中有着 “万物皆对象” 的说法，但依然有非对象的数据类型存在，且原始类型没有属性和方法。最没有争议的原始类型是：Undefined、 Boolean、 Number 和 String。
值得注意的是，虽然 null 有时被认为是一个对象（例如，typeof null 的结果是 &amp;#39;object&amp;#39;），但在实际上，它并不是对象，而是一个原始值。这是JavaScript的一个已知错误。
W3C对于null的解释：

注释：您也许会问，为什么 typeof 运算符对于 null 值会返回 “Object”。这实际上是 JavaScript 最初实现中的一个错误，然后被 ECMAScript 沿用了。现在，null 被认为是对象的占位符，从而解释了这一矛盾，但从技术上来说，它仍然是原始值。


再来看一下MDN和W3C关于“对象”这个概念的介绍：
JavaScript 对象MDNMDN对于“对象”的解释：

Introducing JavaScript objects
In JavaScript, most things are objects, from core JavaScript features like arrays to the browser APIs built on top of JavaScript. You can even create your own objects to encapsulate related functions and variables into efficient packages and act as handy data containers. The object-based nature of JavaScript is important to understand if you want to go further with your knowledge of the language, therefore we’ve provided this module to help you.


在 JavaScript 中，大多数事物都是对象，从作为核心功能的字符串和数组，到建立在 JavaScript 之上的浏览器 API 。你甚至可以自己创建对象，将相关的函数和变量高效地封装打包成便捷的数据容器。对于进一步学习 JavaScript 语言知识而言，理解这种面向对象（object-oriented, OO）的特性是必不可少的，所以，我们提供了这个模块来帮助你了解这一切。这里我们会先详细介绍对象的理论和语法，再介绍如何创建对象。对象基础对象是一个包含相关数据和方法的集合（通常由一些变量和函数组成，我们称之为对象里面的属性和方法）
每次我们学习的示例使用浏览器内建的 API 和 JavaScript 的一些对象时，我们就在使用对象，因为，这些功能是由跟我们所看到的对象同样的结构来构建的，尽管比我们自己定义的示例要复杂许多。


W3CW3C对于“对象”的解释：

JavaScript 对象定义

JS 历史
JS 对象属性在 JavaScript 中，对象是王。如果您理解了对象，就理解了 JavaScript。在 JavaScript 中，几乎“所有事物”都是对象。
布尔是对象（如果用 new 关键词定义）
数字是对象（如果用 new 关键词定义）
字符串是对象（如果用 new 关键词定义）
日期永远都是对象
算术永远都是对象
正则表达式永远都是对象
数组永远都是对象
函数永远都是对象
对象永远都是对象所有 JavaScript 值，除了原始值，都是对象。

JavaScript 原始值_原始值_指的是没有属性或方法的值。_原始数据类型_指的是拥有原始值的数据。JavaScript 定义了 5 种原始数据类型：

string
number
boolean
null
undefined原始值是一成不变的（它们是硬编码的，因此不能改变）。

面向对象术语
对象ECMA-262 把对象（object）定义为“属性的无序集合，每个属性存放一个原始值、对象或函数”。严格来说，这意味着对象是无特定顺序的值的数组。尽管 ECMAScript 如此定义对象，但它更通用的定义是基于代码的名词（人、地点或事物）的表示。
类每个对象都由类定义，可以把类看做对象的配方。类不仅要定义对象的接口（interface）（开发者访问的属性和方法），还要定义对象的内部工作（使属性和方法发挥作用的代码）。编译器和解释程序都根据类的说明构建对象。
实例程序使用类创建对象时，生成的对象叫作类的实例（instance）。对类生成的对象的个数的唯一限制来自于运行代码的机器的物理内存。每个实例的行为相同，但实例处理一组独立的数据。由类创建对象实例的过程叫做实例化（instantiation）。在前面的章节我们提到过，ECMAScript 并没有正式的类。相反，ECMA-262 把对象定义描述为对象的配方。这是 ECMAScript 逻辑上的一种折中方案，因为对象定义实际上是对象自身。即使类并不真正存在，我们也把对象定义叫做类，因为大多数开发者对此术语更熟悉，而且从功能上说，两者是等价的。
对象的构成在 ECMAScript 中，对象由特性（attribute）构成，特性可以是原始值，也可以是引用值。如果特性存放的是函数，它将被看作对象的方法（method），否则该特性被看作对象的属性（property）。
在 ECMAScript 中，所有对象并非同等创建的。一般来说，可以创建并使用的对象有三种：本地对象、内置对象和宿主对象。本地对象ECMA-262 把本地对象（native object）定义为“独立于宿主环境的 ECMAScript 实现提供的对象”。简单来说，本地对象就是 ECMA-262 定义的类（引用类型）。它们包括：

Object
Function
Array
String
Boolean
Number
Date
RegExp
Error
EvalError
RangeError
ReferenceError
SyntaxError
TypeError
URIError



补充（Java中的数据类型）如果有了解过Java语言的数据类型会知道：Java有八种基本类型，有byte，short，int，long，double，float，boolean，char。
而在引用数据类型中，定义了它们的包装类，即八种包装类：Byte（java.lang.Byte（父类Number））Short（java.lang.Short（父类Number））Integer（java.lang.Integer（父类Number））Long（java.lang.Long（父类Number））Double（java.lang.Double（父类Number））Float（java.lang.Float（父类Number））Boolean（java.lang.Boolean（父类Object））Character（java.lang.Character（父类Object））
需要注意的一点是：Java的基本类型中没有String，String本身就是一个引用数据类型的类。基本数据类型没有属性和方法，无法进行调用操作，而它们的包装类具有属性和方法，可以调用包装类的属性和方法使用。

当你认为JavaScript的数据类型有对象和Undefined、 Boolean、 Number、 String几个非对象，而对象拥有属性和方法，可以调用，但其他非对象类型则没有属性和方法，不能调用。
别急。还记得JavaScript中的数据类型有隐式转换吗？

JavaScript 数据类型的转换MDN下面是MDN对于数据类型转换的解释：

Data type conversionJavaScript is a dynamically typed language. This means you don’t have to specify the data type of a variable when you declare it. It also means that data types are automatically converted as-needed during script execution.
Numbers and the ‘+’ operatorIn expressions involving numeric and string values with the + operator, JavaScript converts numeric values to strings.With all other operators, JavaScript does not convert numeric values to strings.
Converting strings to numbersIn the case that a value representing a number is in memory as a string, there are methods for conversion.

parseInt()
parseFloat()parseInt only returns whole numbers, so its use is diminished for decimals.Note: Additionally, a best practice for parseInt is to always include the radix parameter. The radix parameter is used to specify which numerical system is to be used.An alternative method of retrieving a number from a string is with the + (unary plus) operator.



数据类型的转换JavaScript 是一种动态类型语言 (dynamically typed language)。这意味着你在声明变量时可以不必指定数据类型，而数据类型会在代码执行时会根据需要自动转换。
数字转换为字符串在包含的数字和字符串的表达式中使用加法运算符（+），JavaScript 会把数字转换成字符串。
在涉及其他运算符时，JavaScript 语言不会把数字变为字符串。
字符串转换为数字有一些方法可以将内存中表示一个数字的字符串转换为对应的数字。

parseInt() (en-US)
parseFloat()parseInt 方法只能返回整数，所以使用它会丢失小数部分。另外，调用 parseInt 时最好总是带上进制（radix）参数，这个参数用于指定使用哪一种进制。将字符串转换为数字的另一种方法是使用一元加法运算符。


W3CW3C对于数据类型转换的解释：

JavaScript 拥有动态类型，这意味着相同变量可用作不同类型。W3C中详细介绍数据类型转换的相关链接：https://www.w3school.com.cn/js/pro_js_typeconversion.asp


现在已经知道了JavaScript中的数据类型、对象、以及数据类型转换的概念后，再来看看下面这个例子：
示例一在VSCode中输入以下代码：
&amp;lt;script&amp;gt;    var a = &amp;quot;abcdefg&amp;quot;;    console.log(a);    var b = a.substring(2);    console.log(a);    console.log(b);&amp;lt;/script&amp;gt;

在这个例子中，变量a为一个基本类型的字符串，a此时应当为一个基本类型的string。后面调用了a的substring方法。
运行后得到的结果为：
abcdefgabcdefgcdefg

由结果第三行可知，调用a的方法成功了。似乎和前面的结论相悖：一个基本类型的a竟可以调用方法。
示例二JS中有“原型”和“原型链”这样的概念。我们利用原型链的特性再来看一个例子。
在浏览器的开发者模式中，可以在控制台输入JS代码并运行。
在控制台中输入下面的内容：
a=&amp;quot;aaa&amp;quot;a.__proto__

输入完毕后回车，可以得到下面的结果：
String &amp;#123;&amp;#x27;&amp;#x27;, constructor: ƒ, anchor: ƒ, at: ƒ, big: ƒ, …&amp;#125;anchor: ƒ anchor()at: ƒ at()big: ƒ big()blink: ƒ blink()bold: ƒ bold()charAt: ƒ charAt()charCodeAt: ƒ charCodeAt()codePointAt: ƒ codePointAt()concat: ƒ concat()constructor: ƒ String()endsWith: ƒ endsWith()fixed: ƒ fixed()fontcolor: ƒ fontcolor()fontsize: ƒ fontsize()includes: ƒ includes()indexOf: ƒ indexOf()isWellFormed: ƒ isWellFormed()italics: ƒ italics()lastIndexOf: ƒ lastIndexOf()length: 0link: ƒ link()localeCompare: ƒ localeCompare()match: ƒ match()matchAll: ƒ matchAll()normalize: ƒ normalize()padEnd: ƒ padEnd()padStart: ƒ padStart()repeat: ƒ repeat()replace: ƒ replace()replaceAll: ƒ replaceAll()search: ƒ search()slice: ƒ slice()small: ƒ small()split: ƒ split()startsWith: ƒ startsWith()strike: ƒ strike()sub: ƒ sub()substr: ƒ substr()substring: ƒ substring()sup: ƒ sup()toLocaleLowerCase: ƒ toLocaleLowerCase()toLocaleUpperCase: ƒ toLocaleUpperCase()toLowerCase: ƒ toLowerCase()toString: ƒ toString()toUpperCase: ƒ toUpperCase()toWellFormed: ƒ toWellFormed()trim: ƒ trim()trimEnd: ƒ trimEnd()trimLeft: ƒ trimStart()trimRight: ƒ trimEnd()trimStart: ƒ trimStart()valueOf: ƒ valueOf()Symbol(Symbol.iterator): ƒ [Symbol.iterator]()[[Prototype]]: Object[[PrimitiveValue]]: &amp;quot;&amp;quot;



在输出信息的导数第二行中看到这样一条：
[[Prototype]]: Object
也就是在a=&amp;quot;aaa&amp;quot;中，a的类型为String，但String却属于Object。
这是为什么呢？这个String到底是不是对象呢？如果是对象，为什么会将String称为基本类型&amp;#x2F;原始类型？如果不是对象，为什么能够调用它的方法呢？
JS中的字符串是不是对象这个问题可以先参考下面这样一个帖子：《js中的字符串是对象吗？》
在第一个回答中：（以下为摘录）

为了便于操作基本类型值，ECMAScript 还提供了 3 个特殊的引用类型：Boolean、Number 和 String。这些类型与本章介绍的其他引用类型相似，但同时也具有与各自的基本类型相应的特殊行为。
实际上，每当读取一个基本类型值的时候，后台就会创建一个对应的基本包装类型的对象，从而让我们 能够调用一些方法来操作这些数据。来看下面的例子。

var s1 = &amp;quot;some text&amp;quot;;var s2 = s1.substring(2);

这个例子中的变量 s1 包含一个字符串，字符串当然是基本类型值。而下一行调用了 s1 的subString()方法，并将返回的结果保存在了 s2 中。我们知道，基本类型值不是对象，因而从逻辑上讲它们不应该有方法（尽管如我们所愿，它们确实有方法）。
其实，为了让我们实现这种直观的操作，后台已经自动完成了一系列的处理。当第二行代码访问 s1 时，访问过程处于一种读取模式，也就是要从内存中读取这个字符串的值。
而在读取模式中访问字符串时，后台都会自动完成下列处理。(1) 创建 String 类型的一个实例；(2) 在实例上调用指定的方法；(3) 销毁这个实例。
可以将以上三个步骤想象成是执行了下列 ECMAScript 代码：

var s1 = new String(&amp;quot;some text&amp;quot;); var s2 = s1.substring(2); s1 = null; 

经过此番处理，基本的字符串值就变得跟对象一样了。而且，上面这三个步骤也分别适用于 Boolean 和 Number 类型对应的布尔值和数字值。
引用类型与基本包装类型的主要区别就是对象的生存期。使用 new 操作符创建的引用类型的实例， 在执行流离开当前作用域之前都一直保存在内存中。而自动创建的基本包装类型的对象，则只存在于一 行代码的执行瞬间，然后立即被销毁。
这意味着我们不能在运行时为基本类型值添加属性和方法。来看 下面的例子：

var s1 = &amp;quot;some text&amp;quot;; s1.color = &amp;quot;red&amp;quot;; alert(s1.color); //undefined

在此，第二行代码试图为字符串 s1 添加一个 color 属性。但是，当第三行代码再次访问 s1 时， 其 color 属性不见了。
问题的原因就是第二行创建的 String 对象在执行第三行代码时已经被销毁了。第三行代码又创建自己的 String 对象，而该对象没有 color 属性。当然，可以显式地调用 Boolean、Number 和 String 来创建基本包装类型的对象。
不过，应该在 绝对必要的情况下再这样做，因为这种做法很容易让人分不清自己是在处理基本类型还是引用类型的 值。对基本包装类型的实例调用 typeof 会返回”object”，而且所有基本包装类型的对象都会被转换为布尔值 true。 Object 构造函数也会像工厂方法一样，根据传入值的类型返回相应基本包装类型的实例。
例如：

var obj = new Object(&amp;quot;some text&amp;quot;); alert(obj instanceof String); //true 

把字符串传给 Object 构造函数，就会创建 String 的实例；而传入数值参数会得到 Number 的实 例，传入布尔值参数就会得到 Boolean 的实例。要注意的是，使用 new 调用基本包装类型的构造函数，与直接调用同名的转型函数是不一样的。 
例如：

var value = &amp;quot;25&amp;quot;;var number = Number(value); //转型函数 alert(typeof number); //&amp;quot;number&amp;quot; var obj = new Number(value); //构造函数 alert(typeof obj); //&amp;quot;object&amp;quot;

在这个例子中，变量 number 中保存的是基本类型的值 25，而变量 obj 中保存的是 Number 的实 例。尽管我们不建议显式地创建基本包装类型的对象，但它们操作基本类型值的能力还是相当重要的。 而每个基本包装类型都提供了操作相应值的便捷方法。
作者：Chess链接：https://www.zhihu.com/question/420346414/answer/1464146126来源：知乎著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。  


MDN中也有部分内容提到了这个特性：

JavaScript data types and data structuresProgramming languages all have built-in data structures, but these often differ from one language to another. This article attempts to list the built-in data structures available in JavaScript and what properties they have. These can be used to build other data structures.The language overview offers a similar summary of the common data types, but with more comparisons to other languages.Dynamic and weak typingJavaScript is a dynamic language with dynamic types. Variables in JavaScript are not directly associated with any particular value type, and any variable can be assigned (and re-assigned) values of all types:

let foo = 42; // foo is now a numberfoo = &amp;quot;bar&amp;quot;; // foo is now a stringfoo = true; // foo is now a boolean

JavaScript is also a weakly typed language, which means it allows implicit type conversion when an operation involves mismatched types, instead of throwing type errors.

const foo = 42; // foo is a numberconst result = foo + &amp;quot;1&amp;quot;; // JavaScript coerces foo to a string, so it can be concatenated with the other operandconsole.log(result); // 421

Implicit coercions is very convenient, but can be a potential footgun if developers didn’t intend to do the conversion, or intend to convert in the other direction (for example, string to number instead of number to string). For symbols and BigInts, JavaScript has intentionally disallowed certain implicit type conversions.
Primitive valuesAll types except Object define immutable values represented directly at the lowest level of the language. We refer to values of these types as primitive values.All primitive types, except null, can be tested by the typeof operator. typeof null returns &amp;quot;object&amp;quot;, so one has to use === null to test for null.All primitive types, except null and undefined, have their corresponding object wrapper types, which provide useful methods for working with the primitive values. For example, the Number object provides methods like toExponential(). When a property is accessed on a primitive value, JavaScript automatically wraps the value into the corresponding wrapper object and accesses the property on the object instead. However, accessing a property on null or undefined throws a TypeError exception, which necessitates the introduction of the optional chaining operator.




Type
typeof return value
Object wrapper



Null
&amp;quot;object&amp;quot;
N&amp;#x2F;A


Undefined
&amp;quot;undefined&amp;quot;
N&amp;#x2F;A


Boolean
&amp;quot;boolean&amp;quot;
Boolean


Number
&amp;quot;number&amp;quot;
Number


BigInt
&amp;quot;bigint&amp;quot;
BigInt


String
&amp;quot;string&amp;quot;
String


Symbol
&amp;quot;symbol&amp;quot;
Symbol



The object wrapper classes’ reference pages contain more information about the methods and properties available for each type, as well as detailed descriptions for the semantics of the primitive types themselves.


动态和弱类型JavaScript 是一种有着动态类型的动态语言。JavaScript 中的变量与任何特定值类型没有任何关联，并且任何变量都可以分配（重新分配）所有类型的值：

let foo = 42; // foo 现在是一个数值foo = &amp;quot;bar&amp;quot;; // foo 现在是一个字符串foo = true; // foo 现在是一个布尔值

JavaScript 也是一个弱类型语言，这意味着当操作涉及不匹配的类型是否，它将允许隐式类型转换，而不是抛出一个错误。

const foo = 42; // foo is a numberconst result = foo + &amp;quot;1&amp;quot;; // JavaScript coerces foo to a string, so it can be concatenated with the other operandconsole.log(result); // 421

强制隐式转换是非常方便的，但是如果开发者不打算转换，或者打算向另一个方向转换（例如，字符串转数值而不是数值到字符串），则会存在潜在的隐患。对于 symbol 和 BigInt， JavaScript 总是不允许某些隐式类型转换。
原始值除了 Object 以外，所有类型都定义了表示在语言最低层面的不可变值。我们将这些值称为_原始值_。除了 null，所有原始类型都可以使用 typeof运算符测试。typeof null 返回 &amp;quot;object&amp;quot;，因此必须使用 === null 来测试 null。除了 null 和 undefined，所有原始类型都有它们相应的对象包装类型，这为处理原始值提供可用的方法。例如，Number 对象提供向 toExponential() 这样的方法。当在原始值上访问属性时，JavaScript 会自动将值包装到相应的包装对象中，并访问对象上的属性。然而，在 null 或 undefined 上访问属性时，会抛出 TypeError 异常，这需要采用可选链运算符。




类型
typeof 返回值
对象包装器



Null
&amp;quot;object&amp;quot;
N&amp;#x2F;A


Undefined
&amp;quot;undefined&amp;quot;
N&amp;#x2F;A


Boolean
&amp;quot;boolean&amp;quot;
Boolean


Number
&amp;quot;number&amp;quot;
Number


BigInt
&amp;quot;bigint&amp;quot;
BigInt


String
&amp;quot;string&amp;quot;
String


Symbol
&amp;quot;symbol&amp;quot;
Symbol



对象包装器类的参考页面包含关于每个类型可用方法和属性类型的更多用法，以及原始类型本身的详细描述。


总结String，Number，Boolean类型不是对象，而是基本数据类型，但在读取这个基本类型的值的时候，JS引擎会将这些基础类型进行隐式类型转换，转换成它们相应的对象包装类型，而对象包装类型可以调用相关的属性和方法。
笔者的总结未必是准确的，了解详情还请仔细查看上文。

其他解释但W3C给出了一个与MDN完全不相关的回答。笔者也无法判断W3C的解释是否合理或正确，但也将W3C的解释贴出来，如果有了解这方面的老师还请留下评论。
W3C的解释

所有程序设计语言最重要的特征之一是具有进行类型转换的能力。ECMAScript 给开发者提供了大量简单的类型转换方法。大部分类型具有进行简单转换的方法，还有几个全局方法可以用于更复杂的转换。无论哪种情况，在 ECMAScript 中，类型转换都是简短的一步操作。转换成字符串ECMAScript 的 Boolean 值、数字和字符串的原始值的有趣之处在于它们是伪对象，这意味着它们实际上具有属性和方法。例如，要获得字符串的长度，可以采用下面的代码：

var sColor = &amp;quot;red&amp;quot;;alert(sColor.length);	//输出 &amp;quot;3&amp;quot;

尽管 “red” 是原始类型的字符串，它仍然具有属性 length，用于存放字符串的大小。总而言之，3 种主要的原始类型 Boolean 值、数字和字符串都有 toString() 方法，可以把它们的值转换成字符串。提示：您也许会问，“字符串还有 toString() 方法吗，这不是多余吗？”是的，的确如此，不过 ECMAScript 定义所有对象都有 toString() 方法，无论它是伪对象，还是真对象。因为 String 类型属于伪对象，所以它一定有 toString() 方法。相关链接：ECMAScript 类型转换https://www.w3school.com.cn/js/pro_js_typeconversion.asp

</content>
    <url>/2023/09/15/JavaScript-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2-JS%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%98%AF%E4%B8%8D%E6%98%AF%E5%AF%B9%E8%B1%A1/</url>
  </entry>
  <entry>
    <title>JavaScript对象相关笔记</title>
    <content>JavaScript对象相关笔记


原生对象ECMA-262把本地对象（native object）定义为 “ 独立于宿主环境的 ECMAScript 实现提供的对象”
“ 本地对象 ” 包含哪些内容：
Object、Function、Array、String、Boolean、Number、 Date、RegExp、Error、EvalError、RangeError、ReferenceError、SyntaxError、TypeError、 URIError
由此可以看出，本地对象就是 ECMA-262 定义的类（引用类型）

内置对象ECMA-262 把内置对象（ built-in object ）定义为“由 ECMAScript 实现提供的、独立于宿主环境的所有对象，在 ECMAScript 程序开始执行时出现”。
这意味着开发者不必明 确实例化内置对象，它已被实例化了 
同样是“独立于宿主环境”。
根据定义我们似乎很难分清“内置对象”与“本地对象”的 区别。
而ECMA-262 只定义了两个内置对象，即 Global 和 Math（ 它们也是本地对象， 根据定义，每个内置对象都是本地对象 )。如此就可以理解了。
**内置对象是本地对象的一种 **

宿主对象何为 “ 宿主对象 ” ？
主要在这个“宿主”的概念上，ECMAScript 中的 “ 宿主 ” 当然就是我 们网页的运行环境 ，即 “ 操作系统 ” 和 “ 浏览器 ”
所有非本地对象都是宿主对象（host object），即由 ECMAScript 实现的宿主环境提供 的对象 。
所有的 BOM 和 DOM 都是宿主对象。因为其对于不同的 “ 宿主 ” 环境所展示的内容不同 。
其实说白了就是，ECMAScript 官方未定义的对象都属于宿主对象，因为其未定 义的对象大多数是自己通过 ECMAScript 程序创建的对象
2对象JavaScript 中有八种数据类型。
有七种原始类型，因为它们的值只包含一种东西（字符串，数字或者其他）。
相反，对象则用来存储键值对和更复杂的实体。
对象是具有一些特殊特性的关联数组。
“普通对象（plain object）”，或者就叫对象。
JavaScript 中还有很多其他类型的对象：

Array 用于存储有序数据集合，
Date 用于存储时间日期，
Error 用于存储错误信息。
……等等。

“Array 类型”或“Date 类型”，但其实它们并不是自身所属的类型，而是属于一个对象类型即 “object”。它们以不同的方式对 “object” 做了一些扩展。
3对象 (object)对象类型的成员。
注：对象是属性的集合，并有一个原型对象。原型可以是空值。

原生对象 (native object)
ECMAScript 实现中，并非由宿主环境，而是完全由本规范定义其语义的对象。
注：标准的原生对象由本规范定义。一些原生对象是内置的，其他的可在 ECMAScript 程序执行过程中构建。

内置对象(built-in object)
由 ECMAScript 实现提供，独立于宿主环境的对象，ECMAScript 程序开始执行时就存在。
注：标准的内置对象由本规范定义，ECMAScript 实现可以指定和定义其他的。所有内置对象是原生对象。一个内置构造器 (built-in constructor) 是个内置对象，也是个构造器。

宿主对象 (host object)
由宿主环境提供的对象，用于完善 ECMAScript 执行环境。
注：任何对象，不是原生对象就是宿主对象。

4Native Object
JavaScript语言提供的不依赖于执行宿主的对象，其中一些是内建对象，如：Global、Math；一些是在脚本运行环境中创建来使用的，如：Array、Boolean、Date、Function、Number、Object、RegExp、Error。

Build-in Object
JavaScript语言提供的不依赖于执行宿主的内建对象，如：Global、Math；内建对象都是Native Object。

Host Object
 JavaScript语言提供的任何依赖于宿主环境的对象，所有非Native Object的对象都是宿主对象，如：IE中的window，WScript中的wscript实例，任何用户创建的类。

5JavaScript 标准内置对象或称全局的对象（global objects）
不要和 全局对象（global object）混淆。
这里说的全局的对象是说在全局作用域里的对象，全局作用域包含了全局对象的属性，还有它可能继承来的属性。
JavaScript 标准内置对象的分类：
\1. 值属性（Infinity、NaN、undefined、null 字面量、globalThis）这些全局属性返回一个简单值，而且这些值没有自己的属性和方法。
\2. 函数属性（eval()、uneval() 、isFinite()、isNaN()、parseFloat()、parseInt()、decodeURI()、decodeURIComponent()、encodeURI()、encodeURIComponent()、escape() 、unescape()）全局函数可以直接调用，不需要在调用时指定所属对象，执行结束后会将结果直接返回给调用者。
\3. 基本对象（Object、Function、Boolean、Symbol、Error、EvalError、InternalError、RangeError、ReferenceError、SyntaxError、TypeError、URIError）基本对象是定义或使用其他对象的基础。基本对象包括一般对象、函数对象和错误对象。
\4. 数字、数学和日期对象（Number、BigInt、Math、Date）用来表示数字、执行数学计算和日期的对象。
\5. 字符串和正则式对象（String、RegExp）用来表示和操作字符串的对象。
\6. 可索引的数组对象（Array、Int8Array、Uint8Array、Uint8ClampedArray、Int16Array、Uint16Array、Int32Array、Uint32Array、Float32Array、Float64Array、BigInt64Array、BigUint64Array）这些对象表示按照索引值来排序的数据集合，包括数组和类型数组，以及类数组结构的对象。
\7. 使用键的集合对象（Map、Set、WeakMap、WeakSet）这些集合对象在存储数据时会使用到键，支持按照插入顺序来迭代元素。
\8. 构化数据（ArrayBuffer、SharedArrayBuffer 、Atomics 、DataView、JSON）这些对象用来表示和操作结构化的缓冲区数据，或使用 JSON （JavaScript Object Notation）编码的数据。
\9. 控制抽象对象（Promise、Generator、GeneratorFunction、AsyncFunction ）
\10. 反射（Reflect、Proxy）
\11. 国际化（Intl、Intl.Collator、Intl.DateTimeFormat、Intl.ListFormat、Intl.NumberFormat、Intl.PluralRules、Intl.RelativeTimeFormat、Intl.Locale）为了支持多语言处理而加入ECMAScript的对象。
\12. WebAssembly（WebAssembly、WebAssembly.Module、WebAssembly.Instance、WebAssembly.Memory、WebAssembly.Table、WebAssembly.CompileError、WebAssembly.LinkError、WebAssembly.RuntimeError）
\13. 其他（arguments）
6编程语言中预先定义的函数。
具体：嵌入到主调函数中的函数称为内置函数，又称内嵌函数。 作用是提高程序的执行效率，大多编程语言都有自己的内置函数，如javascript内置函数等。 内置函数的存在极大的提升了程序员的效率和程序的阅读。
部分网页 :MDN-JavaScript标准内置对象
MDN-对象模型
MDN-对象
MDN-带键的集合
MDN-全局对象
ECMAScript Standard Built-in Objects
JavaScript Built-in Functions
Standard built-in objects in JavaScript
JavaScript reference
Standard built-in methods to work with Arrays
Built-in Methods in Javascript
Use built-in JavaScript objects in Office Scripts
ECMA-262, 11th edition, June 2020 ECMAScript® 2020 Language Specification

https://blog.bitsrc.io/discovering-javascript-three-objects-new-developers-must-know-fade54355383

JavaScript static code analysis
Node.js v16.6.1 documentation
标准对象分类Value Properties

https://www.w3schools.com/js/js_object_definition.asp


https://medium.com/nerd-for-tech/understanding-objects-and-prototypes-in-javascript-d847baa50f9a

The Modern JavaScript Tutorial
JS Functions Are Objects
ECMAScript2020言語仕様　私的日本語訳
Using JavaScript’s built-in objects
Explain built-in objects of JavaScript.
JavaScript Built-in Objects

https://ithelp.ithome.com.tw/m/articles/10193146

JavaScript Built-in Objects
ASP Built-in Objects
What is a built in object in Javascript? 
Built-in objects and functions
Built –In Objects - JavaScript (JS)
Using Built-in JavaScript Code with JavaScript Objects
Frameork Built-in Objects

https://www.quora.com/What-are-built-in-objects-in-python


https://medium.com/nerd-for-tech/understanding-objects-and-prototypes-in-javascript-d847baa50f9a

Built in objects in javascript
FAQ: Advanced Objects - Built-in Object Methods
builtins: Returns the Names of All Built-in Objects
Returns the Names of All Built-in Objects
List of Built-In Routines

http://google.com/search?sa=N&amp;amp;q=What+are+built-in+objects%3F&amp;amp;ved=2ahUKEwjGnMzGx5nyAhXDdd4KHajuDgEQzmd6BAgpEAU&amp;amp;biw=360&amp;amp;bih=640&amp;amp;dpr=3#ip=1

</content>
    <url>/2021/05/24/JavaScript%E5%AF%B9%E8%B1%A1%E7%9B%B8%E5%85%B3%E7%AC%94%E8%AE%B0/</url>
  </entry>
  <entry>
    <title>Java基础</title>
    <content>Java基础


其他TIOBE 编程语言排行榜
Hadoop  分布式系统基础架构
Apache Hadoop
ORALE ( 甲骨文 )
IDE(集成开发环境)
MyElipse , Eclipse , IDEA
(MyEclipse 2017 stable)

MyElipseEclipse汉化过程 :依次点击 : help , Install New Software, Add , Location 
输入：https://download.eclipse.org/technology/babel/update-site/latest/
选择Babel Language Packs in Chinese (Simplified) 后点击next , 成功后eclipse自动重启
解除汉化过程 :找到eclipse根目录 , 找到eclipse.ini文件右键编辑 , 在最后输入
-Duser.language=en保存退出 
右键eclipse.exe发送到桌面快捷方式 , 右键选择属性 , 在目标最后输入 ln zh点击确定
IDEAJavaJDK
目前版本JDK8
包含JRE和JVM
Java开发需下载完整JDK , 只运行Java只需下载JRE

JDK  Java语言的软件开发工具包
JRE  Java运行环境
JVM  Java虚拟机
Java SE(基础核心) : 

面向对象
API
JVM

Java ME : 

移动设备
游戏
通信

Java EE : 

JSP
EJB
服务

JDK文件夹中部分文件 : 
COPYRIGHT  版本;版权
LICENSE  许可证
release  发布版本
bin文件夹  : 包含JDK开发工具的可执行性文件
lib  类库
include  C语言头文件
src.zip  java源代码
path配置过程下载JDK后需配置path ( win10系统 )
复制JDK文件中bin的文件位置
依次打开 : 控制面板 , 系统 , 高级系统设置 , 高级 , 环境变量 , 选择系统变量中的Path点击编辑 , 将文件位置粘贴保存 , 并上移至第一行
参考文章 : JDK安装与环境变量配置
查看JDK是否配置成功打开windows命令处理程序 ( win+R出入cmd )
输入 : 
java -version

显示版本即为配置成功
反编译工具jad命令例 : 
Jad -s java Test.class
Jad -s java -8 Test.class(含中文时)
FrontEndPlus
图形化工具 , jad内核
需要设置 : Configuration  ,  Decompile Options , 选择convert Unicode strings into ANSI string (anti) , Update and Close

</content>
    <url>/2022/02/24/Java%E5%9F%BA%E7%A1%80/</url>
  </entry>
  <entry>
    <title>Java基础语法</title>
    <content>Java基础语法


对象
软件对象也由状态和相关行为组成。
对象将其状态存储在字段（某些编程语言中的变量）中，并通过方法（某些编程语言中的函数）公开其行为。
字段cadence、speed和gear表示对象的状态，方法（changeCadence、changeGear等speedUp）定义其与外部世界的交互
方法对对象的内部状态进行操作，并作为对象到对象通信的主要机制。隐藏内部状态并要求通过对象的方法执行所有交互被称为数据封装——面向对象编程的基本原则。
将代码捆绑到单个软件对象中提供了许多好处，包括：

模块化：一个对象的源代码可以独立于其他对象的源代码编写和维护。一旦创建，对象可以很容易地在系统内部传递。
信息隐藏：通过仅与对象的方法交互，其内部实现的细节对外界保持隐藏。
代码重用：如果一个对象已经存在（可能由另一个软件开发人员编写），您可以在您的程序中使用该对象。这允许专家实现&amp;#x2F;测试&amp;#x2F;调试复杂的、特定于任务的对象，然后您可以信任这些对象在您自己的代码中运行。
可插入性和易于调试：如果某个特定对象出现问题，您可以简单地将其从应用程序中删除，然后插入一个不同的对象作为替代。这类似于解决现实世界中的机械问题。如果螺栓断裂，则更换它，而不是整台机器。




类
在 Java 编程语言中，每个类都可以有一个直接的超类，并且每个超类都可以有无限数量的子类

接口
对象通过它们公开的方法来定义它们与外部世界的交互
方法形成对象与外界的接口
在其最常见的形式中 , 接口是一组具有空主体的相关方法
实现一个接口可以让一个类对它承诺提供的行为更加正式。接口在类和外部世界之间形成了一个契约，并且这个契约在编译时由编译器强制执行。如果您的类声称实现了一个接口，则该接口定义的所有方法都必须出现在其源代码中，然后该类才能成功编译。
(要实际编译ACMEBicycle该类，您需要将public关键字添加到已实现接口方法的开头。)

包
包是组织一组相关类和接口的命名空间
Java 平台提供了一个庞大的类库（一组包），适合在您自己的应用程序中使用。这个库被称为“应用程序编程接口”，简称“API”。它的包代表最常与通用编程相关的任务。

标识符
给包,类,方法,变量起名字的符号
标识符由字母、数字、下划线、美元符号组成
包名：全部小写，多级包用.隔开。类、接口：一个单词首字母大写，多个单词每个单词的首字母大写。方法和变量：一个单词首字母小写，多个单词从第二个单词开始每个单词的首字母大写常量：如果是一个单词,所有字母大写，如果是多个单词,所有的单词大写,用下划线区分每个单词项目名：全部用小写字母，多个单词之间用横杆-分割

关键字访问控制private访问控制修饰符，在同一类内可见protected访问控制侬饰符，对同一包内的类和所有子类可见public访问控制修饰符，对所有类可见
类、方法和变量修饰符abstract表明类或者成员方法具有抽象展性class声明一个类enum枚举(在J2SE 5.0中添加)extends表明一个类型是另一个类型的子类型final用来说明最终属性implements表明一个类实现接口interface接口native原生方法(非Java实现)new用来创建新实例对象static表明具有静态同性strictfp用于很制浮点计其的精度和舍入(在J2SE 1.2中添加)synchronized表明一段代码需要同步执行transient声明不用序列化的成员域volatile表明两个或音多个变量必须同步地发生变化
程序控制语句break用于结束当前循环体中的执行case用在switch语句之中,表示其中的一个分支continue用于在当前循环体结束时恢复程序执行default默认，例如，用在switch语句中，表明一个默认的分支do用在do-while循环结构中else用在条件语句中，表明当条件不成立时的分支for一种循环结构的引导词if条件语句的引导词instanceof用来测试一个对兔是管是指定类型的实例对象
return用于完成方法的执行。返回给调用者一个方法定义返回值switch分支语句结构的引导词while用于创建一个while循环
错误处理assert断言，用来进行程序调试(在J2SE14中添加)catch用在异常处理中，用来捕捉异常finally用来声明处理异常中肯定会被执行到的语句块throw抛出一个异常throws在方法声明中用于搭定在方法中未处理哪些异常
try定义具有异常处理的语句块
包相关
import表明引入要访问搭定的类或包package包
基本数据类型boolean基本数据类型之一，布尔类型byte基本数据类型之一，字节类型char基本数据类型之一，字符类型double基本数据类型之一，双精度浮点数类型float基本数据类型之一，单精度浮点数类型int基本数据类型之一，整数类型long基本数据类型之一，长整数类型short基本数据类型之一.短整数类型
变量引用super当前对象的父类型的引用或音父类型的构造方法this指向当前实例对象的引用void用于声明方法不返回任何值
保留关键字goto保留关键享，没有具体含义const保留关键享，没有具体含义
换行输出 :System.out.println(&amp;quot;Hello World&amp;quot;);或System.out.print(&amp;quot;Hello\nWord&amp;quot;)
System.out.print(&amp;quot;Hello\tWord&amp;quot;)
注释//单行注释/* *多 *行 *注 *释*//**JavaDoc注释*/



访问修饰符分隔符
; 分号 用来终止一个语句
&amp;#123;&amp;#125; 花括号、大括号 用来包括自动初始化的数组的值，也用来定义程序块、类、方法以及局部范围
[]方括号、中括号 用来声明数组的类型，也用来表示撤消对数组值的引用
, 逗号 在变量声明中，区分变量说明的各个变量。在for控制语句中，用来将圆括号内的语句连接起来
. 原点 用来将软件包的名字与它的子包或类分隔。也用来将引用变量与变量或方法分隔
() 圆括号 在定义和调用方法时用来容纳参数表。在控制语句或强制类型转换组成的表达式中用来表示执行或计算的优先权

进制

运算符
除了赋值运算符之外的所有二元运算符都是从左到右计算的
赋值运算符从右到左求值

算数运算符+  -  *  /  %  ++  --  

1./ 左右两端的类型需要一致

2.%最后的符号和被模数相同

3.前++；先+1，后运算
​	后++；先运算 , 后+1

4、+：当String字符串与其他数据类型只能做连接运算 , 并且结果为String类型


比较运算符==  !=  &amp;lt;  &amp;gt;  &amp;lt;=  &amp;gt;=  instanceof
运算结果都是Boolean类型
赋值运算符=  +=  -=  *=  /=  %=
逻辑运算符&amp;amp;  |  ^  !  &amp;amp;&amp;amp;  ||
&amp;amp; 逻辑与
 | 逻辑或
 ^ 逻辑异或
 !  逻辑非
 &amp;amp;&amp;amp; 短路与
 || 短路或

&amp;amp;：左边无论真假，右边都会进行运算；
&amp;amp;&amp;amp;：如果左边为假，则右边不进行运算；
| 与 || 的区别同上；在使用的时候建议使用&amp;amp;&amp;amp;和||
^与或|的不同之处是：当左右都为true时，结果为false。

位运算符&amp;lt;&amp;lt;
&amp;gt;&amp;gt;
&amp;lt;&amp;lt;&amp;lt;
&amp;amp;
|
^
~
三元运算符(条件表达式)?表达式1:表达式2;

条件运算符
条件表达式为true时,运算后的结果是表达式1条件表达式为false时,运算后的结果是表达式2

1、表达式1与表达式2的类型必须一致；
2、使用三元运算符的地方一定可以使用if…else代替，反之不一定成立；


例:
public static void main (Sting[] args)&amp;#123;    int a=1;	int b=2;	String result = a&amp;lt;b?(&amp;quot;a大&amp;quot;):(&amp;quot;b大&amp;quot;);	System.out.println(result);&amp;#125;



==与equals() 的区别Java语法—-Java中equals和&amp;#x3D;&amp;#x3D;的区别

结果为布尔类型

例 : 
String sex=&amp;quot;男&amp;quot;;sex.equals(&amp;quot;男&amp;quot;);//此种情况变量sex必须赋值

或 
&amp;quot;男&amp;quot;.equals(sex);







转义字符
支持一些特殊的转义序列char和String文字：
String.contains()方法不需要转义

\a(响铃)    \b( 退格） \f(换页)   \n(换行)   \r（回车） \t(制表符)\v (垂直制表 )    \\(反斜杠)   \&amp;#39;(单引号)   \&amp;quot;(双引号)    \0 (空字符)    \ddd (1到3位八进制所代表的任意字符)   \xhh (1到2位十六进制所代表的任意字符)
变量Java 编程语言定义了以下类型的变量：

实例变量（非静态字段）从技术上讲，对象将其各自的状态存储在“非静态字段”中，即没有static关键字声明的字段。非静态字段也称为实例变量，因为它们的值对于类的每个实例（换句话说，对于每个对象）都是唯一的
类变量（静态字段）类变量static是使用修饰符声明的任何字段；这告诉编译器存在这个变量的一个副本，不管这个类被实例化了多少次。定义特定类型自行车的齿轮数量的字段可以标记为static , 因为从概念上讲，相同数量的齿轮将适用于所有实例。该代码static int numGears = 6;将创建这样一个静态字段。此外，可以添加关键字final来表示齿轮的数量永远不会改变。
局部变量与对象在字段中存储其状态的方式类似，方法通常会将其临时状态存储在局部变量中。声明局部变量的语法类似于声明字段（例如，int count = 0;）。没有特殊关键字将变量指定为局部变量；该决定完全来自声明变量的位置——位于方法的左大括号和右大括号之间。因此，局部变量仅对声明它们的方法可见；课堂上的其他人无法访问它们。
参数您已经在“Hello World!”的Bicycle类和方法中看到了参数示例。main应用。回想一下，该main方法的签名是public static void main(String[] args). 这里，args变量是这个方法的参数。要记住的重要一点是，参数总是被归类为“变量”而不是“字段”。这也适用于您将在本教程后面了解的其他参数接受构造（例如构造函数和异常处理程序）。

成员变量( 非静态字段即没有static关键字声明的字段 , 也叫作实例变量&amp;#x2F;对象变量 , 定义在类中 , 属于对象 , 只能对象调用(类的实例调用 ? ) , 堆内存 )
​		静态成员变量(也叫类变量 , 有static关键字声明 , 属于成员变量的一种 ,  可以直接使用类名调用 , 可以对象调用 ,  共享内存)
局部变量(在方法体中定义 , 栈内存 , 生命周期只存在在方法中 , 方法结束后就会回收)
Java没有全局变量 , 但可以用静态成员变量实现全局变量效果
变量的命名
变量名区分大小写。
变量的名称可以是任何合法的标识符——一个长度不限的Unicode字母和数字序列，以字母、美元符号$或下划线字符_开头。惯例是变量名总是以字母开头，而不是$或_。
美元符号字符根本就不会被使用。在某些情况下，自动生成的名称将包含美元符号，但变量名称应该始终避免使用它。对于下划线字符也有类似的约定
虽然从技术上讲，变量名以_开头是合法的，但这种做法是不鼓励的。
空格是不允许的。
后续字符可以是字母、数字、美元符号或下划线字符。为变量选择名称时，请使用完整的单词而不是隐晦的缩写。
在许多情况下，它还会使您的代码自我记录
名称不能是关键字或保留字
如果您选择的名称仅包含一个单词，则将该单词拼写为所有小写字母。如果它包含多个单词，则将每个后续单词的第一个字母大写。
如果变量存储一个常量值，例如static final int NUM_GEARS = 6，则约定会略有变化，将每个字母大写并用下划线分隔后续单词。下划线字符从不在其他地方使用。

常量
常量名通常大写
不同字符使用下划线分隔
只能被赋值一次 , 通常定义时即对其初始化

final double PI = 3.14;



数据类型
原始类型由语言预定义并由保留关键字命名
原始值不与其他原始值共享状态
已声明但未初始化的字段将由编译器设置为合理的默认值。一般而言，此默认值将为零或null，具体取决于数据类型
局部变量略有不同；编译器永远不会为未初始化的局部变量分配默认值。如果无法在声明它的地方初始化局部变量，请确保在尝试使用它之前为其分配一个值。访问未初始化的局部变量将导致编译时错误。
如果整型字面值以字母L或l结尾，则为长型;否则为int类型。建议使用大写字母L，因为小写字母l与数字1很难区分
如果浮点字面值以字母F或f结尾，则为float类型 ; 否则，它的类型是double，它可以选择以字母D或d结尾
字符和字符串文字 : 
文字类型char，String可以包含任何 Unicode (UTF-16) 字符。也可以使用“Unicode 转义”，始终对文字使用“单引号”，对char文字使用“双引号” String。Unicode 转义序列可以在程序的其他地方使用（例如在字段名称中），而不仅仅是在char或String文字中。
null文字可以用作任何引用类型的值。null可以分配给任何变量，除了原始类型的变量。null除了测试它的存在之外，几乎无能为力。因此，null经常在程序中用作标记，表示某些对象不可用。
有一种特殊的字面量，称为类字面量，由类型名称和附加 “ 组成.class；例如，String.class. 这指的Class是表示类型本身的（类型的）对象。
在 Java SE 7 及更高版本中，任意数量的下划线字符  _)可以出现在数字文字中数字之间的任何位置。能够分隔数字文字中的数字组，提高代码的可读性。

原始数据类型Primitive Data
double此数据类型绝不应用于精确值，例如货币。


数值型
字节型(byte)
整数类型(short,int,long)
浮点类型(float,double)


字符型(char)
布尔型(boolean)

String name = &amp;quot;张三&amp;quot;;//String  双引号char sex = &amp;#x27;男&amp;#x27;;//char  单引号



引用数据类型
类(class)
接口(interface)
数组([])

String.format(&amp;quot;%.2f&amp;quot;,f1);



数组
数组是一个容器对象，它包含固定数量的单一类型的值。数组的长度是在创建数组时确定的。创建后，它的长度是固定的。
数组中的每一项都称为一个元素，每个元素都通过其数字索引访问


标识符
数组元素
元素下标 : 从0开始
元素类型

流程控制语句顺序结构分支结构
条件为布尔类型

if/*if(条件)&amp;#123; *执行代码块 *&amp;#125;*/



if-else/*if(条件)&amp;#123;	代码块1&amp;#125;else&amp;#123;	代码块2&amp;#125;*/



if-else-if/*if(条件)&amp;#123;	代码块1&amp;#125;else if(条件2)&amp;#123;	代码块2&amp;#125;else if(条件3)&amp;#123;	代码块3&amp;#125;else &amp;#123;代码块4&amp;#125;*/





switch
与if和if-else语句不同，switch语句可以有许多可能的执行路径。
switch适用于byte、short、char和int基元数据类型。还适用于枚举类型、String类和一些封装某些基本类型的特殊类 : Character、Byte、Short和Integer
语句的主体switch称为switch 块。块中的语句switch可以用一个或多个case或default标签来标记。该switch语句计算其表达式，然后执行匹配case标签后面的所有语句。
switch语句仅基于单个整数、枚举值或String对象测试表达式
每个break语句都终止封闭switch语句

continuereturn循环结构for
迭代一系列值
初始化表达式初始化循环;它在循环开始时执行一次
当终止表达式的计算结果为false时，循环终止
递增表达式在每次循环迭代后被调用;这个表达式可以对一个值递增或递减

增强for循环
or each element in arrayName do {…}
for(数据类型 变量名 :遍历的目标){ 数据类型 变量名 :声明一个变量用来接收遍历目标遍历后的元素}

for(ElementType element: arrayName)&amp;#123;&amp;#125;;

例:
int[] num = &amp;#123;1,2,3,4,5,6&amp;#125;;for(int i: num)&amp;#123;    System.out.print(i);&amp;#125;









while
while语句计算表达式，表达式必须返回一个布尔值。

do-while
do-while和之间的区别在于while它do-while在循环底部而不是顶部评估其表达式。因此，块内的语句do总是至少执行一次

表达式
表达式是由变量、运算符和方法调用组成的构造，这些构造根据语言的语法构造，计算结果为单个值。
表达式返回值的数据类型取决于表达式中使用的元素。
表达式也可以返回其他类型的值，例如booleanor String。
只要表达式的一部分所需的数据类型与另一部分的数据类型匹配，Java 编程语言就允许您从各种较小的表达式构造复合表达式。
一条语句构成一个完整的执行单元。;通过以分号 ( )结束表达式，可以将以下类型的表达式组成语句。

赋值表达式
任何使用++或--
方法调用
对象创建表达式

这样的语句称为表达式语句。
还有另外两种语句：声明语句和控制流语句 : 声明语句声明一个变量 , 控制流语句控制语句执行的顺序
块是一组位于平衡大括号之间的零个或多个语句，可以在任何允许使用单个语句的地方使用

反射语法糖注解多态
同一个引用类型使用不同的实例而执行不同操作

</content>
    <url>/2022/03/03/Java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
  </entry>
  <entry>
    <title>Java对象和类</title>
    <content>Java对象和类


对象与类面向对象程序设计概述传统的结构化程序设计通过设计一系列的过程（即算法）来求解问题。面向对象程序设计(object-oriented programming , OOP) 将数据放在第一位 , 然后再考虑操作数据的算法 , 更加适合解决规模较大的问题 .
类由类构造（construct）对象的过程称为创建类的实例。封装（encapsulation有时称为数据隐藏）是处理对象的一个重要概念。从形式上看，封装就是将数据和行为组合在一个包中，并对对象的使用者隐藏具体的实现方式。对象中的数据称为实例字段，操作数据的过程称为方法。
OOP可以通过扩展其他类来构建新类。在扩展一个已有的类时，这个扩展后的新类具有被扩展的类的全部属性和方法。通过扩展一个类来建立另外一个类的过程称为继承。
类包含的实例字段通常属于某个类类型 .
类之间的关系
依赖(uses-a)
聚合(has-a)
继承(is-a)

依赖：一个类的方法 使用或者操纵另一个类的对象聚合：类A的对象包含类B的对象继承：一个更特殊的类与一个更一般的类之间的关系
对象对象中的数据称为实例字段 , 操作数据的过程称为方法 . 作为一个类的实例 , 特定对象都有一组特定的实例字段值 . 这些值的集合就是这个对象的当前状态 . 
封装(数据隐藏  encapsulation)是处理对象的一个重要概念 
对象的状态：对着中保存着的描述当前状况的信息。对象的状态并不能完全描述一个对象，对象状态的改变必须通过调用方法实现。对象的状态影响它的行为。
所有的Java对象都是在堆中构造的 .
预定义类对象与对象变量构造对象 : 
使用构造器(或构造函数)构造新实例 : 构造器的名字应该与类名相同 
//构造一个Date对象需要在构造器前面加上 new 操作符 : new Date();//可以将对象放在一个变量中//表达式 new Date()构造了一个Date类型的对象,它的值是对新创建对象的一个引用,这个引用储存在变量deadLine中Date birthday = new Date();//可以将这个对象传递给一个方法System.out.println(new Date());//也可以对刚创建的对象应用一个方法 //Date类中有一个 toString 方法,返回日期的字符串描述String s = new Date().toString();

构造对象变量 : 
Date deadLine;

定义了一个对象变量 deadLine  , 它可以引用 Date 类型的对象 , 但变量 deadLine 不是一个对象 , 也没有引用任何对象 , 此时还不能在这个变量上使用任何 Date 方法 .
变量对象并没有实际包含一个对象 , 它只是引用一个对象 . 任何对象变量的值都是对储存在另外一个地方的某个对象的引用 .
可以显示地将对象变量设置为 null , 指示这个对象变量目前没有引用任何对象 .
必须首先初始化变量 deadLine 
//可以引用一个新构造的对象deadLine = new Date();//可以设置这个变量让它引用一个已有的对象 :deadLine = birthday;

更改器方法与访问器方法(待整理)更改器方法访问器方法：访问器方法访问器方法 (字段访问器 : 只返回实例字段值)
自定义类Employee类class ClassName&amp;#123;    //field1(字段)    //fiedl2    //...    //constructor1(构造函数)    //constructor2    //...    //method1(方法)    //method2&amp;#125;

构造器(待整理)构造器总是结合 new 运算符来调用 . 不能对一个已经存在的对象调用构造器来达到重新设置实例字段的目的 .
null引用(待整理)一个对象变量包含一个对象的引用 , 或者包含一个特殊值null , 后者表示没有引用任何对象 .
如果对null值应用一个方法 , 会产生一个  NullPointerException (空指针)异常 .
解决办法 : 

把null参数转换为一个适当的非null值
if (n--null) name = &amp;quot;unknown&amp;quot;;else name = n;

拒绝null参数
public Employee(String n,double s, int year,int month,int day)&amp;#123;Objects.requireNonNull(n,&amp;quot;The name cannot be null&amp;quot;);name=&amp;quot;n&amp;quot;;...&amp;#125;

隐式参数与显示参数(待整理)隐式参数又称为方法调用的目标或者接收者
封装(待整理)私有方法(待整理)public  : 任何类的任何方法都可以用这些方法
private  : 确保只有Employee类自身的方法能够访问这些实例字段 , 而其他类的方法不能够读写这些字段 .
final实例字段(待整理)可以将实例字段定义为final . 这样的字段必须在构造对象时初始化
final 修饰符对于基本类型或者不可变类的字段尤其有用(如果类中的所有方法都不会改变其对象 , 这样的类就是不可变的类)
final 关键字只是表示储存在 evaluations 变量中的对象引用不会再指示另一个不同的StringBuilder对象
静态字段与静态方法(待整理)静态字段(类字段)定义为 static 的字段 , 每个类只有一个
非静态字段(待整理)每个对象都有自己的一个副本
静态常量(待整理)静态方法(待整理)不在对象上执行的方法 , 没有隐式参数 , 没有this参数的方法
工厂方法(待整理)静态工厂方法构造对象
main(待整理)方法参数(待整理)对象构造重载(待整理)多个方法有不同的名字 , 不同的参数 , 便出现了重载 . 编译器必须挑选出具体的调用哪个方法 . 它用各个方法首部中的参数类型与特定方法调用中所使用的值类型进行匹配 , 来选出正确的方法 . 
查找匹配的过程被称为重载解析 .
显式字段初始化(待整理)默认字段初始化(待整理)如果在构造器中中没有显式地为字段设置初值 , 会被自动地赋为默认值 : 数值为 0 , 布尔值为 false , 对象引用为 null 
初始化块(待整理)无参数的构造器(待整理)由无参数的构造器创建对象时 , 对象的状态会设置为适当的默认值 .
有参数的构造器(待整理)调用另一个构造器(this关键字)(待整理)包包命名使用包的主要原因是确保类名的唯一性
类的导入一个类可以使用所属包中的所有类 , 以及其他包中的公共类 .
//1.使用完全限定名java.time.LocalDate today = java.time.LocalDate.new();//2.使用 import 语句导入一个特定的类或整个包//只能使用*导入一个包import java.time.*;import java.time.LocalDate;



静态导入有一种 import 语句允许导入静态方法和静态字段
//例如在源文件顶部添加一条指令 :import static java.lang.System.*;//就可以使用System类的静态方法和静态字段而不必加类名前缀out.println(&amp;quot;Goodbye,World!&amp;quot;);exit(0);//还可以导入特定的方法或字段import static java.lang.System.out;



包访问标记为 public 的部分可以由任意类使用 , 标记为 private 的部分只能由定义他们的类使用 . 如果没有指定 public 和 private , 这个部分(类,方法或变量) 可以被同一个包中的所有方法访问 .
JAR文件(待整理)文档注释javadoc  由源文件生成一个HTML文档 , 在源代码中加以特殊界定符 /** 开始的注释
每个 /**...*/ 文档注释包含标记以及之后紧跟着的自由格式文本 . 自由格式文本的第一句应该是一个概要性的句子
标记以 @ 开始
类注释类注释必须放在 import 语句之后 , 类定义之前
方法注释方法注释必须放在所描述的方法之前
除了通用标记外 , 还可以使用 :
这个标记将给当前方法的 “ parameters “ (参数) 部分添加一个条目 . 这个描述可以占很多行 , 并且可以使用HTML标记 . 一个方法的所有的 @param 标记必须放在一起
@param variable description

字段注释(待整理)通用注释包注释注释抽取</content>
    <url>/2022/03/04/Java%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB/</url>
  </entry>
  <entry>
    <title>KK魔法学院原创角色设计课笔记——猫猫墙主讲</title>
    <content>KK魔法学院原创角色设计课【构成DLC15期：为你的OC注入灵魂】——猫猫墙主讲


原创角色设计核心流程全解一、设计起点：明确角色的“生存环境”在你动笔设计一个原创角色（OC）之前，必须回答的第一个问题是：
“这个角色将出现在什么样的‘载体’中？”
这直接决定了设计的根本方向和复杂度：

游戏向角色（尤其是商业游戏立绘&amp;#x2F;皮肤）
核心逻辑：用视觉吸引玩家消费。
设计特点：需要极强的“第一眼吸引力”。角色本身就是一个信息丰富的视觉产品。设计会非常复杂，充满细节、小道具、多层剪裁和不同材质的堆叠，旨在让玩家觉得“值”。
讲故事的方式：通过外观直接讲述。一个角色的性格、职业、背景甚至技能，都尽可能通过其服装、武器、姿态和装饰来体现。视觉本身就是故事。


叙事向角色（漫画、动画、个人插画、企划）
核心逻辑：用故事塑造角色魅力。
设计特点：可以相对简单、克制。角色的魅力主要通过剧情、对话、表情和动态在连续的叙事中展现。过于复杂的设计反而会成为叙事的负担（难画、抢戏、信息过载）。
讲故事的方式：通过时间线中的行为来讲述。一件简单的白衬衫在不同的剧情场景下，可以被赋予完全不同的情感色彩。



一句话总结：游戏角色是“看”的复杂，叙事角色是“演”的简单。
二、设计核心：理解“图形”与“结构”的二维宇宙确定了设计目的后，你需要为自己的角色选择一个“风格坐标”。这由两个核心维度决定：

图形归纳程度：你希望角色的造型被概括、夸张、几何化的程度。
高图形化：像Logo一样强调剪影，形状鲜明、夸张（如《空洞骑士》、欧美卡通）。
低图形化：更忠实于生物或物体的自然、有机形态（如写实肖像、古典油画）。


结构写实程度：你希望角色的解剖、透视、材质刻画符合物理现实的程度。
高结构化：注重准确的骨骼肌肉、合理的服装剪裁、可信的材质质感（如《守望先锋》、写实插画）。
低结构化：对结构进行大量简化、忽略或象征性表达（如Q版、极简风动画）。



关键的“风格安全区”将这两个维度构成一个坐标轴，你会发现成熟的风格通常落在一条对角线上：

左上角：高图形 + 低结构（卡通、风格化）。
右下角：低图形 + 高结构（写实、仿真）。
中间区域：两者平衡（主流二次元、日式RPG）。

⚠️ 必须避开的“设计雷区”：

右上角：高图形 + 高结构。极易产生恐怖谷效应，例如一个写实的人体顶着巨大、夸张的卡通化装备，会显得割裂、诡异。
左下角：低图形 + 低结构。容易沦为缺乏设计感和美感的简陋草图。

设计时，图形与结构的强度需要协同增减。想玩夸张造型，就简化结构；想追求写实质感，就收敛图形的极端变化。
三、设计路径：如何找到并抵达你的目标风格知道了目标在哪，你需要评估自己，选择最适合的起点和路径：

根据兴趣选择：你最爱看、最想画哪种风格？这是长期动力的来源。
根据能力优势选择（务实之选）：
如果你擅长捕捉和归纳形状（图形感好），可以从左上角（卡通、风格化）开始创作，这里能最大化你的优势。
如果你擅长理解和刻画结构、透视（体积感强），可以从右下角（偏写实）开始，利用照片等写实参考起步更轻松。
如果你处于初学或寻求平衡，中间区域（如常见二次元）是最佳练习场，对两项能力要求均衡。



四、设计思维：从“拼凑零件”到“孕育生命”解决了“画什么风格”和“用什么方法画”之后，最关键的是转变底层创作思维：

从“参考搬运”到“感受归纳”
旧思维：找一张好看的图，临摹头发；再找一张，临摹衣服——结果拼凑感强。
新思维：观察一个角色或照片，问自己：“它给我什么感觉？”（如：危险、温柔、慵懒、科技感）。然后，用图形语言去强化这种感受（用尖三角强化危险，用大弧线强化温柔）。


从“先搭骨架”到“先塑灵魂”
旧思维：先严格按解剖画一个正确的人体骨架（结构），再往上“穿衣服”。
新思维：先构思一个有吸引力的动态剪影或图形构成（图形）。然后，运用你的结构知识，去将这个精彩的图形合理化、立体化。让结构能力为图形创意服务。



五、设计实践：第一项训练——风格转换为了切身理解上述理论，课程布置的核心作业是：选择一位现有角色，将其从“卡通风格”转为“写实风格”，或反之。

卡通 -&amp;gt; 写实：你需要收敛夸张的图形，为装备添加合理的结构、缝合线、材质细节，将比例调整得更接近真人。
写实 -&amp;gt; 卡通：你需要放大特征性图形，简化繁琐的结构细节，调整头身比，让一切形状变得更整体、更鲜明。

这个练习的目的，是强迫你去思考不同风格维度下，设计的侧重点究竟发生了怎样的迁移。

终极心法角色设计不是“画出一个人”，而是 “为一种目的，在一个风格宇宙中，用图形与结构的语言，孕育一个视觉生命” 。每次下笔前，想清楚这四件事，你的设计就有了坚实的起点。
</content>
    <url>/2026/01/19/KK%E9%AD%94%E6%B3%95%E5%AD%A6%E9%99%A2%E5%8E%9F%E5%88%9B%E8%A7%92%E8%89%B2%E8%AE%BE%E8%AE%A1%E8%AF%BE%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E7%8C%AB%E7%8C%AB%E5%A2%99%E4%B8%BB%E8%AE%B2/</url>
  </entry>
  <entry>
    <title>SSDSBakery--构成14.4班毕业合绘：十四点四烘焙房</title>
    <content>2025年6月27日，在KK魔法学院的构成课结课毕业啦~在毕业季14,4班同学组织起了合绘，合绘的餐厅主题一下子就想到了赛博点单，请看：
网页链接：十四点四烘焙房
项目地址：SSDSBakery


开发日志2025.7.2命名：SSDSBakery——十四点四烘焙房
策划书
搭建了新的github page
2025.7.3技术栈预测
HTML5&amp;#x2F;CSS3
基础布局和样式
CSS动画（关键帧动画、过渡效果）
3D变换（用于桌牌翻转效果）
Flexbox&amp;#x2F;Grid 布局
媒体查询（响应式设计）


JavaScript (ES6+)
DOM操作
事件处理（点击、滑动等）
状态管理（跟踪菜品状态、视角位置等）


动画库
**GSAP (GreenSock)**：专业级动画库，适合复杂动画序列（开门动画、镜头移动、菜单弹出）
Anime.js：轻量级替代方案


交互增强库
Hammer.js：处理手势操作（名片滑动）
Tilt.js：实现微妙的3D倾斜效果（可选）


前端框架
Vue + VueUse：组合式API简化交互逻辑
Svelte：编译时优化，适合高性能动画



必需图片资源清单
场景图：
关闭的门（带”推开门”提示）
打开的门（动画中间帧可选）
完整的桌子场景（包含菜单、桌牌、名片盒位置）


UI元素：
关闭的菜单（放在桌上的状态）
打开的菜单（多页设计）
关闭按钮（”×”图标）
桌牌正面（餐厅介绍）
桌牌背面（地址信息）
名片盒&amp;#x2F;名片堆叠初始状态


菜品图（每种菜品需要）：
菜单中的小图标（带状态标签）
桌上展示的大图（带透明背景）
菜品介绍卡片背景


名片系列：
5-10张不同设计的名片（统一尺寸）
名片堆叠结束状态图


装饰元素（可选）：
二次元风格餐具装饰
背景纹理
光影效果覆盖层



</content>
    <url>/2025/07/03/SSDSBakery--%E6%9E%84%E6%88%9014.4%E7%8F%AD%E6%AF%95%E4%B8%9A%E5%90%88%E7%BB%98%EF%BC%9A%E5%8D%81%E5%9B%9B%E7%82%B9%E5%9B%9B%E7%83%98%E7%84%99%E6%88%BF/</url>
  </entry>
  <entry>
    <title>Ubuntu22.04安装MySQL流程</title>
    <content>Ubuntu22.04安装MySQL流程



1、安装服务器端sudo apt-get install mysql-server

2、安装客户端sudo apt-get install mysql-client

3、安装 mysql 相关库sudo apt-get install libmysqlclient-dev

4、安装成功后查看 MySQL 版本mysql -V




5、修改 mysqld.cnf 配置文件sudo vim /etc/mysql/mysql.conf.d/mysqld.cnf

 （1）在 [mysqld] 最后一行加入：  
# skip-grant-tables　　　　&amp;lt;-- add # here

 （2）然后点击 ESC ，输入 ‘ ：wq ’ 进行保存和退出；如下图所示；
 注：如果不修改 mysqld.cnf 配置文件，修改完 MySQL 的用户名和密码后，在进入 MySQL 时可能会有如下错误，即语法错误拒绝被访问：



6、查看默认安装的 MySQL 的用户名和密码sudo cat /etc/mysql/debian.cnf




7、登录 MySQL ；mysql -u debian-sys-maint -p    # 换行后输入上述查到的密码






8、进入 MySQL ；use mysql;

9、刷新权限；flush privileges;

10、修改用户名和密码；ALTER USER &amp;#x27;root&amp;#x27;@&amp;#x27;localhost&amp;#x27; IDENTIFIED WITH caching_sha2_password BY &amp;#x27;123456&amp;#x27;;

11、刷新权限；flush privileges;

12、退出；quit;

13、重启 MySQL ；service mysql restart

14、进入 MySQL ；mysql -u root -p    # 回车后输入自己修改后的密码即可

若以上过程没有效果，进行以下步骤：15、修改 mysqld.cnf 配置文件sudo vim /etc/mysql/debian.cnf




16、保存退出键入i 进入，修改user和password键入Esc，输入:wq 保存退出。退出vi后刷新权限退出MySQL，重启
17、刷新权限；flush privileges;

18、退出；quit;

19、重启 MySQL ；service mysql restart

20、进入 MySQL ；mysql -u root -p    # 回车后输入自己修改后的密码即可

修改成功MySQL中help手册翻译List of all MySQL commands:Note that all text commands must be first on line and end with &amp;#x27;;&amp;#x27;?         (\?) Synonym for `help&amp;#x27;.clear     (\c) Clear the current input statement.connect   (\r) Reconnect to the server. Optional arguments are db and host.delimiter (\d) Set statement delimiter.edit      (\e) Edit command with $EDITOR.ego       (\G) Send command to mysql server, display result vertically.exit      (\q) Exit mysql. Same as quit.go        (\g) Send command to mysql server.help      (\h) Display this help.nopager   (\n) Disable pager, print to stdout.notee     (\t) Don&amp;#x27;t write into outfile.pager     (\P) Set PAGER [to_pager]. Print the query results via PAGER.print     (\p) Print current command.prompt    (\R) Change your mysql prompt.quit      (\q) Quit mysql.rehash    (\#) Rebuild completion hash.source    (\.) Execute an SQL script file. Takes a file name as an argument.status    (\s) Get status information from the server.system    (\!) Execute a system shell command.tee       (\T) Set outfile [to_outfile]. Append everything into given outfile.use       (\u) Use another database. Takes database name as argument.charset   (\C) Switch to another charset. Might be needed for processing binlog with multi-byte charsets.warnings  (\W) Show warnings after every statement.nowarning (\w) Don&amp;#x27;t show warnings after every statement.resetconnection(\x) Clean session context.query_attributes Sets string parameters (name1 value1 name2 value2 ...) for the next query to pick up.ssl_session_data_print Serializes the current SSL session data to stdout or file



所有MySQL命令的列表：请注意，所有文本命令都必须位于第一行，并以“；”结尾?         （\？）“帮助”的同义词。clear（\c）清除当前输入语句。connect（\r）重新连接到服务器。可选参数为db和host。delimiter（\d）设置语句分隔符。edit（\e）使用$EDITOR编辑命令。ego（\G）向mysql服务器发送命令，垂直显示结果。exit（\q）退出mysql。与退出相同。go（\g）将命令发送到mysql服务器。help（\h）显示此帮助。nopage（\n）禁用寻呼机，打印到标准输出。notee（\t）不要写入outfile。寻呼机（\P）设置pager[到页面]。通过PAGER打印查询结果。print（\p）打印当前命令。prompt（\R）更改您的mysql提示符。quit（\q）退出mysql。rehash（\#）重新生成完成哈希。source（\.）执行SQL脚本文件。将文件名作为参数。status（\s）从服务器获取状态信息。system（\！）执行系统shell命令。tee（\T）设置输出文件[to_outfile]。将所有内容附加到给定的外文件中。use（\u）使用另一个数据库。将数据库名称作为参数。charset（\C）切换到另一个字符集。可能需要处理具有多字节字符集的binlog。warnings（\W）在每条语句后显示警告。nowarning（\w）不要在每条语句后都显示警告。resetconnection（\x）清除会话上下文。query_attributes为下一个要提取的查询设置字符串参数（名称1值1名称2值2…）。ssl_session_data_print将当前ssl会话数据序列化到stdout或文件


其他命令：更新sudo apt update   

免密码进入mysql：sudo mysql -uroot



参考教程：
Ubuntu 20.04 + mysql 8.0.27 用户名和密码修改
</content>
    <url>/2023/05/06/Ubuntu22.04%E5%AE%89%E8%A3%85MySQL%E6%B5%81%E7%A8%8B/</url>
  </entry>
  <entry>
    <title>Ubuntu服务器搭建Wordpress个人博客过程</title>
    <content>本篇Ubuntu服务器搭建Wordpress个人博客过程写于2021年，后续无更新补充


目录：
BT-Panel应用镜像系统建站
Ubutu系统镜像建站
BT-Panel应用镜像参考教程：B站视频教程视频链接：10分钟拥有真正意义上属于自己的网站！网站搭建！：https://www.bilibili.com/video/BV1D7411B7Yf?t=493
( 没有完全按照视频教程，其中一些更改请参照视频和文章内容对比 )
指导老师：Tokameine：https://tokameine.top/
﻿
准备过程 :域名 :在阿里云购买域名后解析
服务器 :阿里云轻量应用服务器
应用镜像 : BT-Panel其他根据个人需求选择
之后 绑定域名
【香港服务器不需要备案可直接使用，但会存在网络不稳定等许多问题影响运行。】
【国内服务器需要15天左右的备案时间。】
防火墙添加规则 : 开放端口

HTTP TCP 80自定义 TCP 8888

宝塔面板官网 :宝塔面板

﻿
具体步骤 :根据阿里云的提示在轻量应用束缚器管理控制台 , 找到服务器找到应用详情
﻿
﻿
从宝塔面板信息中点击链接 , 跳转至宝塔登录页面 , 输入用户名
( 默认用户名为admin，一定要更改 )
复制命令 , 点击远程链接 , 粘贴命令后回车可查看宝塔账户密码
将密码粘贴至宝塔面板登录

进入宝塔面板首页后更改用户名 &amp;#x2F; 注册账号
进入软件商店下载 :

Apache 2.4.48
MySQL 5.5.62
PHP-7.2（推荐使用）
Pure-Ftpd 1.0.49
如果需要下载 phpMyAdmin , 先下载PHP-7.2以上的版本

下载完成后设置为首页显示
( 正常运行显示后如下图 : )
可直接在应用商店选择一键部署Wordpress
﻿
Ubuntu因为太懒了（因为之前的使用宝塔部署想要保留wordpreaa数据）还是选择用宝塔
宝塔官网下载：https://www.bt.cn/new/download.html
选择在线安装
选择只安装宝塔
安装成功后进入，只下载宝塔
﻿
之后下载
Apache 2.4.48MySQL 5.5.62PHP-7.2（推荐使用）Pure-Ftpd 1.0.49
使用wordpress的一键部署
成功后登陆wordpress
﻿
Sakurairo主题下载地址：https://github.com/mirai-mamori/Sakurairo
安装主题

文章
区块

段落这是文字内容的基本要素，请以此为基础开始撰写。
颜色文本
背景
排版字号尺寸默认13203642
高级打开发布面板

文章
段落

</content>
    <url>/2021/06/24/Ubuntu%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BAWordpress%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E8%BF%87%E7%A8%8B/</url>
  </entry>
  <entry>
    <title>Unexpectedly discovered galaxy clusters resembling bluewhales in shape</title>
    <content>本篇为游戏项目【游鲸】的概念艺术设计脚本。


Unexpectedly discovered galaxy clusters resembling bluewhales in shape作者：（Mor）Mor·Mirror·Blank
MUVVSA今日发布了新文章：《Unexpectedly discovered galaxy clusters resembling blue whales in shape》，对该文章做以下解读：
目录：名词解读JING-17星系团的特点文章主体部分中文翻译    题目    正文文章侧边栏部分中文翻译
名词解读MUVVSA全名：Mor Unify Virtually Vision Space Administration(Mor统一虚拟幻象太空管理局)（类似NASA、CNSA航天局）
MookaMiTeX-ray Observatory  ：MookaMiTeX-ray 天文摄像台
JING-17星系团的特点：1.特殊的能量，无法解析2.粒子波动，无法解析3.星系团在不断扩张4.星系团在移动5.星系团疑似会吞噬附近10光年内的天体6.星系团与蓝鲸高度像似
做出以下猜测：或许JING-17是一个有生命的小型星系团，星系团内包含诸多天体，JING-17是一只小型生命宇宙，不断“游动”与“觅食”，将附近的天体作为自己的食物来源。
暂且将它归类为：移动生命宇宙。
文章主体部分中文翻译题目意外发现了形状酷似蓝鲸的星系团
正文如标题所说，发现了具有特定重要特征的星系团。
由MUVVSA的MookaMiTeX射线天文台观测到异常能量团，该能量团附近有无法确认的粒子波动。由于该星系团与其他星系团极为不同，VU天文望远镜也无法拍摄，下图由著名画家凯特·艾米·奇拉在相关检测数据和科学家的描述下绘制的概念蓝图。
该星系团形状与蓝鲸极为相似，距前后七日的观测对比，星系团直径每七日扩大约为10cm，初步推测该星系团将会不断扩张。同时该星系团位置也有所变化。暂时无法观测该星系团的年龄与星系团边界距离地球的实际距离。更详细的相关研究结果已发布多篇论文。
由于星系团是宇宙中最大的结构之一，随着时间的推移，它会与其他星系团或星系团合并，从而导致星系团气体的不对称或尖锐特征等干扰。科学家们并不确保JING-17这个星系团是否会对太阳系乃至地球造成影响，因为随着它们的大小增加，它们通常仍在经历与其他星系团或星系群合并的混乱。
这是今年预测到的第17个庞大神秘的星系团，编号17。根据著名画家画家凯特·艾米·奇拉的提议，该星系团暂时命名为：JING-17。
奇怪的是，该星系团所处的位置相当孤立，附近10光年内没有其他星系团与天体。结合关于该星系团能够移动的推测，这恐怕意味着该星系团将“吞噬”它所经过的天体。
在观测者莫尔·镜·空白所写的报告中，莫尔大胆针对该星系团相关信息做出了令人难以接受的猜测，具体引用如下：根据现在推测的有关JING-17星系团的特点：1.特殊的能量，无法解析2.粒子波动，无法解析3.星系团在不断扩张4.星系团在移动5.星系团疑似会吞噬附近10光年内的天体6.星系团与蓝鲸高度像似做出以下猜测：或许JING-17是一个有生命的小型星系团，星系团内包含诸多天体，JING-17是一只小型生命宇宙，不断“游动”与“觅食”，将附近的天体作为自己的食物来源。暂且将它归类为：移动生命宇宙。
莫尔认为，宇宙中存在小型生命宇宙并非不可能，她将会在未来一段时间持续关注该星系团来印证这个猜想。
想了解更多的信息，请阅读：
https://www.muvvsa.mor/jing17
文章侧边栏部分中文翻译(其实都是凑字数的)所有其他的小世界观都发生在这个移动的宇宙中。世界观故事的起点也在这里。除了世界观的作者Mor，没有人知道这个宇宙是如何形成的，具体内容现在还不能剧透。目前，科学家们只发现了这个宇宙。如果你想看后续，记得关注Mor（？）为了写一个世界观，我写了一个网站。世界观的名字叫“JING-17”。我胡编乱造了一份报告。欢迎来看这个世界观，虽然你可能看不懂全英文。这些英语都是机器翻译的，所以可能很好笑。我还在要努力凑字数。如果你对这个世界观有兴趣，你可以随时小窗我讨论。这个网站是用代码写的，我可以随时更改内容（其实已经完全不想改了）。世界观的中文名称是“鲸歌”。好了，终于凑够字数了。请看右边的内容。
（写个世界观主线好累啊（不你）
</content>
    <url>/2020/08/11/Unexpectedly-discovered-galaxy-clusters-resembling-bluewhales-in-shape/</url>
  </entry>
  <entry>
    <title>Vtb、Vup、PNGTuber出道手册</title>
    <content>Vtb、Vup、PNGTuber出道手册


起初误认为VUP出道只能使用FaceRig、VTuBe Studio、PrprLive、OBS Studio等等专业面捕软件、推流软件等，于是将这些软件全部购买下载研究了一番，同时也在担心：原来VUP出道前需要准备和额外学习的内容如此庞大，竟还有那么多的VUP出道，熟练使用电脑的我开始担心自己能否短时间内做好出道准备和相关的学习，（短期内指半年内）。
但研究到哔哩哔哩直播姬的时候，发现原来在哔哩哔哩直播姬中包含了简单易上手的VUP出道所使用的各种功能，感慨一下原来并不是想象中的那么难。
由于自己的电脑配置不足，无法同时承担起诸多VUP专业推流软件，只有哔哩哔哩直播姬勉强能保证直播效果流畅。但之前的攻略已经做了，于是也发出来，供其他电脑配置足够的新人VUP参阅。
B站许多专业up主更了解这方面，许多教程都是直接作为参考教程将网址贴出来，这些专业up的教程更加重要，建议反复多次观看。
以下内容为个人独立完成，一个人的查阅资料能力、辨别是非的能力有限，难免采用到有误的参考资料、过时的信息、谬传的信息、等等等等，如有错误，请及时在评论区或私信指出，及时进行更正。
【因为视频教程不方便查找细节性的教程，此手册仅有文字版。请擅用Ctrl + F键】
推荐查找相关教程的up主不愿透露姓名的风向标  https://space.bilibili.com/1393574503ASKLive有声  https://space.bilibili.com/533377303光影学院官方账号   https://space.bilibili.com/1702134598?spm_id_from=333.337.search-card.all.click
推荐查看的教程帖# 想详细问一下如果想做虚拟主播，具体需要做的前期准备都有什么？
Vtb&amp;#x2F;Vup&amp;#x2F;V圈等相关科普Virtual Uploader，虚拟UP主，使用虚拟形象在视频网站上进行投稿活动的主播。
虚拟主播的概念是由绊爱（Kizuna AI）在2016年11月以“虚拟YouTuber”的形式开创的，绊爱也是公认的第一个虚拟YouTuber。【夹带私货时间：绊爱是虚拟形象偶像（Virtual Idol）】效仿的后来者逐渐衍生出虚拟油管博主（Virtual Youtuber - VTuber）、虚拟玩家（Virtual Player）和虚拟主播（Virtual Liver）等职业。
Vtb&amp;#x2F;vtuber：VTuber的简称，在YouTube投稿视频或直播的虚拟主播。其中也有在Twitch和NicoNico等平台活动的Vtb。Vup：VUploader的简称，在Bilibili投稿视频或直播的虚拟主播。
YouTube：中文译名“油管”，是Google公司旗下全世界最大的视频网站，大量的自媒体人以及视频博主在此投稿。官网网址：http://www.youtube.com，但国内无法进入。Bilibili：哔哩哔哩，BILI，B站，哔站等等，于2009年6月26日创建，早期为ACG视频网站，现已发展成为拥有多种分区多种创作类型的国内视频网站。
V圈：原指以2003年VOCALOID（ボーカロイド，或称：术力口）日本乐器制造商雅马哈公司开发的电子音乐制作语音合成软件为起始的虚拟歌姬圈子，因后来发展的Vtuber与VOCALOID简称相同有重名冲突，该冲突至今似乎仍未找到合适的解决方式。V家：指代“VOCALOID家族”的简称，指属于VOCALOID的一群虚拟歌姬。
VOCALOID虚拟歌姬与Vtb&amp;#x2F;Vup的区别：虚拟主播需要有被称为【中之人】的真人扮演者，并依靠动作捕捉技术来实现中之人的虚拟化。虚拟歌姬&amp;#x2F;虚拟歌手，是指在电脑上用歌声合成软件制作，并赋予虚拟二次元形象的歌手。目前主要有：VOCALOID（V家）、UTAU（U家）、袅袅（袅家）、MUTA和Sharpkey。需要需要编辑器和声库，通过输入歌词和旋律的方式让软件生成唱词，配合加载伴奏数据来完成整首音乐制作。
此版块相关参考文章：知乎专栏：如何成为一名虚拟主播（上）知乎专栏：如何成为一名虚拟主播（下）
可参考的视频：【从零开始 成为虚拟主播（vtb&amp;#x2F;vup)】 https://www.bilibili.com/video/BV1v64y1M7QQ/?share_source=copy_web&amp;amp;vd_source=052ecf0f200d4359623220d761340c94 （视频为2020年05月且教程主要为FaceRig，可能现在2023年已无法正常使用）
PNGTuber【除了live2D还有一种虚拟主播，那就是PNGTuber丨如何成为一名PNGTuber？】 https://www.bilibili.com/video/BV1ma4y1A7kK/?share_source=copy_web&amp;amp;vd_source=052ecf0f200d4359623220d761340c94
PNGTuber相关软件：Veadotube mini  官网：[https://olmewe.itch.io/veadotube-mini]PNGTuber MAKER（Steam下载）
模型2022年最新Vtuber模型（虚拟偶像模型）制作指南
Vtb&amp;#x2F;Vup的活动平台Vtb&amp;#x2F;Vup常用的直播平台YouTube（国内网络无法进入）https://www.youtube.com/
Bilibili（虚拟主播直播区）https://live.bilibili.com
ACFUN（即A站，也有虚拟主播直播区）https://www.acfun.cn/
twitcasting（TC台）https://twitcasting.tv
twitchhttp://www.twitch.tv
虎牙https://www.huya.com/g/6055
斗鱼https://www.douyu.com/g_ecy
抖音
Vtb&amp;#x2F;Vup常用的论坛社区推特（社交平台）http://www.twitter.com
VUP官网（virtualup）https://virtualup.cn
魔茶国际（国内网无法进入）https://vtuber.magictea.cc/rank
NGA-VTuber综合讨论区https://nga.178.com/thread.php?fid=-60204499
A岛匿名板—虚拟偶像串https://adnmb3.com/f/%E8%99%9A%E6%8B%9F%E5%81%B6%E5%83%8F
贴吧
Vtb&amp;#x2F;Vup常用到的各种工具数据网站VTBs in bilibilihttps://vtbs.moe/
ICU for Viewershttps://matsuri.icu/
VtuberMusichttps://vtbmusic.com/home
UserLocalhttps://virtual-youtuber.userlocal.jp/
VNUMA（hiyoko）https://hiyoko.sonoj.net
Youtube Live实时排行http://ikioi-ranking.com/
live2D软件已知想要成为Vtb&amp;#x2F;Vup需要“中之人”在幕后扮演，因此“中之人”需要都面部捕捉、动作捕捉等软件或设备进行。
live2d相关参考文章：【vup&amp;#x2F;Live2D相关约稿科普】Live2d建模基础知识解说
【【教程】L2D模型检查与使用手册】 https://www.bilibili.com/video/BV1DN4y19789/?share_source=copy_web&amp;amp;vd_source=052ecf0f200d4359623220d761340c94
Live2DViewerEXSteam商店￥26Steam商店页面介绍：[https://store.steampowered.com/app/616720/Live2DViewerEX/]使用文档： http://live2d.pavostudio.com/doc/zh-cn/Bilibili一些视频介绍和教学： https://space.bilibili.com/177908206Android版本下载：http://live2d.pavostudio.com/doc/zh-cn/android/  
PrPrLive官方教程：【【PrprLive】官方教程  第一期  基础的Live2D直播软件使用】 https://www.bilibili.com/video/BV1nz411q7Bi/?share_source=copy_web&amp;amp;vd_source=052ecf0f200d4359623220d761340c94
PrPrLive安装透明推流VTube Studio【【vup教程】5分钟学会！面捕VTS！推流OBS！（拓展ios）】 https://www.bilibili.com/video/BV1i94y1Z79t/?share_source=copy_web&amp;amp;vd_source=052ecf0f200d4359623220d761340c94
Virtual UP官网[https://virtualup.cn/]，简称VUP，是一款虚拟主播工具，B站官网账号：VUP软件，VUP（免费版）已于2023年6月27日停止运营，但官网目前仍可以正常运行。
【如何让你的Live2D模型成为虚拟主播？#VUP快速入门 - Live2D模式】 https://www.bilibili.com/video/BV1MU4y1E7J2/?share_source=copy_web&amp;amp;vd_source=052ecf0f200d4359623220d761340c94
FaceRig中文网官网：[http://www.facerigcn.com/]2023年10月FaceRig 已在 Steam 停售
游戏版本（摘自百度百科facerig词条）FaceRig分为Classic、Pro、Studio版。官方给出的区分如下：FaceRig Classic：包含FaceRig的基本可用内容FaceRig Pro：包含FaceRig Classic的可用内容，但无其他的技术额外增加内容，本版本官方表示若将FaceRig用作视频或直播等用途并盈利500$&amp;#x2F;月则需购买其Pro或Studio版本 [3]FaceRig Studio：包含FaceRig Classic的可用内容，并按照你所购买的Studio中版本添加额外功能 [3]
参考文章：B站专栏：对于steam上的几种面捕做了比较
live3D软件VRoid StudioLive3D官网： https://live3d.io/官网： https://vroid.com/en/studio
如何做一个虚拟主播？ - VUP软件的回答 - 知乎 https://www.zhihu.com/question/408675281/answer/2122152324 （该教程主要为如何使用手机版VRoid制作模型）
VTuber Maker官网： https://live3d.io/vtuber_maker虚拟主播软件VTuber Maker有哪些有意思的功能？
VTuber Editor虚拟主播软件VTuber Editor知道吗？
Wakaru可以用这个软件变身虚拟Vtuber，像爱酱一样成为偶像
推流软件OBS Studio官网：[https://obsproject.com/]Free and open source software for video recording and live streaming.
OBS Studio 是一个开源的，免费的直播推流软件。
【该部分摘自NGA：[是攻略！] 如何成为Vup——个人势超低成本出道指南兼个人流水账式出道记录     使用效果库obs-StreamFX使用OBS进行推流的话需要在开播设置里填上直播分类和房间标题，并且在网页上点击开始直播之后将给出的服务器地址和推流密钥填进OBS Studio的文件-设置-推流里再在obs的主界面点击开始推流就能开始直播了！  
关于live2d模型的背景透明化对于facerig等带绿色背景的输出：添加视频采集设备后右键点击-&amp;gt;滤镜-&amp;gt;色度键-&amp;gt;绿色 确定即可 其他颜色背景同理对于透明背景的输出：添加视频采集设备后右键点击-&amp;gt;属性-&amp;gt;分辨率&amp;#x2F;类型：自定义-&amp;gt;分辨率：设置成和面捕软件的输出分辨率相同-&amp;gt;视频格式：ARGB 确定即可】
使用OBS推流参考教程：【【OBS第一课】OBS必改设置，从下载开始的最全面OBS教程！】 https://www.bilibili.com/video/BV1sP4y1q79v/?share_source=copy_web&amp;amp;vd_source=052ecf0f200d4359623220d761340c94【【教程】个人向直播设置分享|OBS和直播姬（建议收藏）】 https://www.bilibili.com/video/BV1Ep4y147hX/?share_source=copy_web&amp;amp;vd_source=052ecf0f200d4359623220d761340c94
vup开播简易教程关于OBS如何安装Spout插件，以及安装时的问题macOS环境下OBS推流参数设置的简单解析
Bilibili直播姬官网：[https://live.bilibili.com/liveHime]B站的一键开播软件。
B站超次元superACG[https://space.bilibili.com/1411127782]官方的视频教程：
【【虚拟直播教程】虚拟主播怎么弄？从虚拟形象获取到直播间搭建全细节教学，一看就会！助你成为虚拟偶像！】 https://www.bilibili.com/video/BV1oi4y1f71w/?share_source=copy_web&amp;amp;vd_source=052ecf0f200d4359623220d761340c94
【【虚拟直播教程】6分钟学会用哔哩哔哩直播姬打造一个虚拟直播间！一次性教会你软件具体设置，直播间装饰，插件使用！】 https://www.bilibili.com/video/BV1Am4y1o734/?share_source=copy_web&amp;amp;vd_source=052ecf0f200d4359623220d761340c94
【【直播分享官】5分钟完成官方直播姬基础开播！（直播教程）】 https://www.bilibili.com/video/BV1764y1X7Ma/?share_source=copy_web&amp;amp;vd_source=052ecf0f200d4359623220d761340c94
弹幕姬&amp;#x2F;弹幕工具https://nga.178.com/read.php?&amp;amp;tid=26028458
弹幕机：blivechat可使用css深度定制显示效果 但是要本地运行服务端 并且也有公共服务器！ &amp;#x2F; Comen 即插即用 &amp;#x2F; B站官方的直播姬等  
弹幕工具：弹幕库 可以在不打开直播间的情况下回复弹幕并且可以半透明置顶 无声系最爱！弹幕姬 可以设置自动回复等弹幕机器人行为  
此版块参考文章：NGA：[是攻略！] 如何成为Vup——个人势超低成本出道指南兼个人流水账式出道记录blivechat直播弹幕美化样式使用教程—请务必认真阅读
其他值得参考的教程如何成为一只VUP以及一点杂谈如何成为虚拟主播（浅谈）如何才能成为一个虚拟UP主如何研究VUP群体虚拟主播，从入门到DD—什么是虚拟主播【虚拟主播运营为什么难做？】“赛博运营，边缘行者” #VUP教程 #虚拟主播怎么弄【虚拟主播运营指南】录播解决方案有哪些 #VUP教程 #虚拟主播怎么弄【虚拟主播运营指南】直播自动录播是什么，利与弊 #VUP教程 #虚拟主播怎么弄【教程+排雷】想做Vup如何约皮套？这些坑我帮你踩了，你就别踩了！【虚拟主播运营指南】新人入局应该如何自审与冷启动【VUP思考】VUP新人指南现在就成为VTuber吧！14种简单工具强力推荐！（一）
https://www.zhihu.com/question/408675281https://www.zhihu.com/question/336253862
如何做一个虚拟主播？ - 知乎用户BNBUCp的回答 - 知乎 https://www.zhihu.com/question/408675281/answer/1358085280
其他软件CatTuber更加高级&amp;#x2F;深入的教程使用 VIVE Tracker 打造 VTuber
虚拟偶像技术方案指南（这篇文章中注意到几个点：（下列两句话摘自这篇文章）1.VICON 是电影级设备，VTuber 用的人不多，彩虹社于 2019 年 10 月导入使用。2.OptiTrack 相比 VICON 价格稍低，也更为普及，使用者如虚拟女团 marinasu。不知道国内企业势的vup会不会使用到这些）
【教程】从零开始的自制Vtuber: 1.面部捕捉初级
</content>
    <url>/2021/01/22/Vtb%E3%80%81Vup%E3%80%81PNGTuber%E5%87%BA%E9%81%93%E6%89%8B%E5%86%8C/</url>
  </entry>
  <entry>
    <title>YAML学习笔记</title>
    <content>还算详尽的YAML学习笔记


什么是 YAML？yaml官网

YAML: YAML Ain’t Markup Language™What It Is:YAML is a human-friendly data serializationlanguage for all programming languages.It uses Unicode printable characters, some of which provide structural information and the rest containing the data itself.There are many kinds of data structures, but they can all be adequately represented with three basic primitives: mappings (hashes&amp;#x2F;dictionaries), sequences (arrays&amp;#x2F;lists) and scalars (strings&amp;#x2F;numbers).YAML was specifically created to work well for common use cases such as: configuration files, log files, interprocess messaging, cross-language data sharing, object persistence and debugging of complex data structures.




YAML：YAML Ain’t Markup Language™它是什么：YAML是一种人性化的数据序列化语言，适用于所有编程语言。它使用Unicode 可打印 的字符，其中一些提供结构信息，其余包含数据本身。有许多种数据结构，但它们都可以用三个基本原语充分表示：映射（哈希&amp;#x2F;字典）、序列（数组&amp;#x2F;列表）和标量（字符串&amp;#x2F;数字）。YAML是专门为常见用例而创建的，例如：配置文件、日志文件、进程间消息传递、跨语言数据共享、对象持久化和调试复杂数据结构。


YAML 文件使用 .yml 或 .yaml 扩展名，并遵循特定的语法规则。YAML是一种简单、表达力强的、以数据为导向的语言，它不是一种标记语言 (YAML)，作为配置格式时非常易读。它具有直观的可视化结构，并且其逻辑非常简单：&amp;#x3D;&amp;#x3D;缩进的项目继承父项目的属性&amp;#x3D;&amp;#x3D;。YAML 拥有 Perl、C、XML、HTML 和其他编程语言的特性。YAML 也是 JSON 的超集，所以 &amp;#x3D;&amp;#x3D;JSON 文件在 YAML 中有效&amp;#x3D;&amp;#x3D;。没有通常的格式符号，如大括号、方括号、结束标记或引号。YAML 文件更容易阅读，因为其使用 Python 风格的缩进来确定结构并表示嵌套。为了保持跨系统的可移植性，设计时不允许使用制表符，因此改用空格（字面意义的空格字符）。注释可以用井号或哈希符号（#）。使用注释始终是最佳实践，因为其可描述代码的意图。&amp;#x3D;&amp;#x3D;YAML 不支持多行注释，每行都需要以井号字符为后缀&amp;#x3D;&amp;#x3D;。YAML 文件的结构是映射或列表，遵循层次结构，具体取决于缩进以及定义键值的方式。它以映射来关联键值对。每个键必须是唯一的，而且顺序并不重要。这跟 Python 字典或 Bash 脚本中的变量赋值相似。YAML 中的映射必须经过解析后才能关闭，然后创建新的映射。新的映射可以通过增加缩进级别或解析之前的映射并新建一个相邻映射来创建。列表包括以特定顺序列出的值，可以包含任何数量的所需项目。&amp;#x3D;&amp;#x3D;一个列表序列以破折号（-）和空格开始，而缩进则将其与父级分开&amp;#x3D;&amp;#x3D;。我们可以把序列看作是一个 Python 列表或者 Bash 或 Perl 中的数组。一个列表可以嵌入到一个映射中。YAML 还包含标量，它是以 Unicode 编码的任意数据，可以用作字符串、整数、日期、数字或布尔等值。在创建 YAML 文件时，需要确保遵循这些语法规则，而且文件必须有效。

（摘自Red Hat红帽What is YAML?）
YAML 有什么用途？配置文件：YAML是一种常用的配置文件格式，它可以轻松地表示各种配置选项和参数。相比 JSON，因为 YAML 有更好的可读性，对用户更友好，所以通常建议用 YAML 来编写配置文件，尽管它们在大多数情况下可以互换使用。
数据传输：YAML可以用于在不同的应用程序或系统之间传输数据，因为它是一种跨平台的数据格式，易于解析和处理。
持久化存储：YAML可以用于将数据序列化为文本格式并进行持久化存储，例如将数据存储到文件或数据库中。

除了在 Ansible 中使用之外，YAML 还用于 Kubernetes 资源和部署（Ansible是新出现的自动化运维工具，基于Python开发，集合了众多运维工具（puppet、chef、func、fabric）的优点，实现了批量系统配置、批量程序部署、批量运行命令等功能）（网页Kubernetes 也称为 K8s，是用于自动部署、扩缩和管理容器化应用程序的开源系统）使用 YAML 的一大好处是，YAML 文件可以添加到源代码控制中，比如 Github，这样就可以跟踪和审计变更。(摘自自Red Hat红帽YAML for beginners)

YAML基本语法
&amp;#x3D;&amp;#x3D;大小写敏感&amp;#x3D;&amp;#x3D;
使用缩进表示层级关系
缩进时不允许使用 Tab 键，只允许使用空格。
缩进的空格数不重要，但同级元素必须左侧对齐。
‘#’表示注释

集（Collections）
YAML’s block collections use indentation for scope and begin each entry on its own line. Block sequences indicate each entry with a dash and space (“- ”). Mappings use a colon and space (“: ”) to mark each key&amp;#x2F;value pair. Comments begin with an octothorpe (also called a “hash”, “sharp”, “pound” or “number sign” - “#”).YAML also has flow styles, using explicit indicators rather than indentation to denote scope. The flow sequence is written as a comma separated list within square brackets. In a similar manner, the flow mapping uses curly braces.


YAML的block collections(块集)使用缩进表示作用域，并在每个条目的单独一行上开始。Block sequences(块序列)使用破折号和空格(“- “)表示每个条目。Mappings(映射)使用冒号和空格(“: “)分隔键&amp;#x2F;值对。Comments(注释)以八角符号（也称为“hash”、“sharp”、“pound”或“number sign” - “#“）开头。YAML还具有flow styles(流程样式)，使用显式的指示符而不是缩进表示作用域。Flow sequence(流序列)以逗号分隔的列表形式写在方括号内。类似地，flow mapping(流映射)使用花括号表示。

结构（Structures）
YAML uses three dashes (“---”) to separate directives from document content. This also serves to signal the start of a document if no directives are present. Three dots ( “...”) indicate the end of a document without starting a new one, for use in communication channels.


YAML使用三个破折号（“—”）将指令与文档内容分开。如果没有指令，这也表示文档的开始。三个点（“…”）表示文档的结束，不会开始新的文档，适用于通信渠道。

YAML数据类型
YAML represents any native data structure using three node kinds: sequence - an ordered series of entries; mapping - an unordered association of unique keys to values; and scalar - any datum with opaque structure presentable as a series of Unicode characters.NodesA YAML node represents a single native data structure. Such nodes have content of one of three kinds: scalar, sequence or mapping. In addition, each node has a tag which serves to restrict the set of possible values the content can have.


YAML使用三种节点类型来表示任何本地数据结构：序列（sequence）- 有序的条目序列；映射（mapping）- 无序的键值对；标量（scalar）- 任何具有不透明结构的数据，可以表示为一系列Unicode字符。节点一个YAML节点表示一个单一的本地数据结构。这样的节点有三种内容种类：标量（scalar）、序列（sequence）或映射（mapping）。此外，每个节点都有一个标记，用于限制内容可能具有的可能值集。

YAML 支持以下几种数据类型：

标量（scalar）：单个的、不可再分的值
序列（sequence）：一组按次序排列的值，又称为列表（list）
映射（mapping）：键值对的集合，又称为哈希（hashes） &amp;#x2F; 字典（dictionary）

标量（scalar）
Scalar content can be written in block notation, using a literal style (indicated by “|”) where all line breaks are significant. Alternatively, they can be written with the folded style (denoted by “&amp;gt;”) where each line break is folded to a space unless it ends an empty or a more-indented line.


标量内容可以使用块表示法编写，使用字面样式（由“|”表示），其中所有换行都是重要的。或者，它们可以使用折叠样式（由“&amp;gt;”表示）编写，其中每个换行符折叠成空格，除非它结束一个空行或更多缩进的行。


字符串
布尔值
整数
浮点数
Null
时间
日期纯量直接写在键值对的“value”中。使用key:[空格]value的形式表示一对键值对（空格不能省略）

字符串（String）
Generic StringKindScalarDefinitionRepresents a Unicode string, a sequence of zero or more Unicode characters. This type is usually bound to the native language’s string type or, for languages lacking one (such as C), to a character array.


通用字符串类型标量定义表示Unicode字符串，即零个或多个Unicode字符的序列。该类型通常绑定到本地语言的字符串类型，或者对于缺乏该类型的语言（如C语言）绑定到字符数组。

字符串是一系列字符序列，可以使用单引号或双引号括起来，也可以不使用引号。如果字符串中包含特殊字符，应使用引号括起来。
name: &amp;#x27;Alice&amp;#x27;age: 30address: &amp;quot;123 Main St, New York&amp;quot;

单引号和双引号的使用情况单引号：使用单引号表示一个纯量字符串，该字符串&amp;#x3D;&amp;#x3D;不会被转义，也不会被解析为特殊字符或变量&amp;#x3D;&amp;#x3D;。单引号字符串中的任何特殊字符都会被视为普通字符。例如：
name: &amp;#x27;zhangsan \n lisi&amp;#x27;name: &amp;#x27;John Doe&amp;#x27;

输出结果为：
zhangsan \n lisiJohn Doe

双引号：使用双引号表示一个字符串，&amp;#x3D;&amp;#x3D;该字符串可以包含转义字符和变量，也可以包含特殊字符序列，特殊字符会输出为其本身想表达的含义，例如可以包含换行符，&amp;#x3D;&amp;#x3D;。双引号字符串中的变量&amp;#x3D;&amp;#x3D;可以使用${}语法进行插值&amp;#x3D;&amp;#x3D;。例如：
name: zhangsan \n lisiname: &amp;quot;My name is $&amp;#123;name&amp;#125;.&amp;quot;

输出结果为：
zhangsanlisiMy name is $&amp;#123;name&amp;#125;  #若name有传值，例如Anna，则为My name is $&amp;#123;Anna&amp;#125; 


数字（Number）数字可以是整数或浮点数。

IntegerKindScalar.DefinitionRepresents arbitrary sized finite mathematical integers. Scalars of this type should be bound to a native integer data type, if possible.Some languages (such as Perl) provide only a “number” type that allows for both integer and floating-point values. A YAML processor may use such a type for integers as long as they round-trip properly.In some languages (such as C), an integer may overflow the native type’s storage capability. A YAML processor may reject such a value as an error, truncate it with a warning or find some other manner to round-trip it. In general, integers representable using 32 binary digits should safely round-trip through most systems.


整数类型标量定义表示任意大小的有限数学整数。如果可能，此类型的标量应绑定到本地的整数数据类型。一些语言（如Perl）仅提供允许整数和浮点数值的“数字”类型。只要它们正确地往返传输，YAML处理器可以将这种类型用于整数。在一些语言中（如C语言）中，整数可能会超出本地类型的存储能力。YAML处理器可以将这样的值拒绝为错误，使用警告截断它或找到其他方法往返传输。一般来说，可以使用32位二进制数字表示的整数应该能够安全地通过大多数系统往返传输。


Floating PointKindScalar.DefinitionRepresents an approximation to real numbers, including three special values (positive and negative infinity and “not a number”).Some languages (such as Perl) provide only a “number” type that allows for both integer and floating-point values. A YAML processor may use such a type for floating-point numbers, as long as they round-trip properly.Not all floating-point values can be stored exactly in any given native type. Hence a float value may change by “a small amount” when round-tripped. The supported range and accuracy depends on the implementation, though 32 bit IEEE floats should be safe. Since YAML does not specify a particular accuracy, using floating-point mapping keys requires great care and is not recommended.


浮点数类型标量定义表示实数的近似值，包括三个特殊值（正无穷、负无穷和“非数字”）。一些语言（如Perl）仅提供允许整数和浮点值的“数字”类型。只要它们正确地往返传输，YAML处理器可以将这种类型用于浮点数。并非所有浮点数值都可以在任何给定的本地类型中精确存储。因此，浮点值可能在往返传输时“略微变化”。支持的范围和精度取决于实现，但32位IEEE浮点数应该是安全的。由于YAML不指定特定的精度，因此使用浮点映射键需要格外小心，不建议使用。

number: 42float: 3.14

布尔值（Boolean）
BooleanKindScalar.DefinitionRepresents a true&amp;#x2F;false value. In languages without a native Boolean type (such as C), they are usually bound to a native integer type, using one for true and zero for false.


布尔值类型标量定义表示真或假的值。在没有本地布尔类型的语言（如C语言）中，它们通常绑定到本地的整数类型，使用1表示true，使用0表示false

布尔值可以是true或false。
is_student: trueis_adult: false

空值（Null）
NullKindScalar.DefinitionRepresents the lack of a value. This is typically bound to a native null-like value (e.g., undef in Perl, None in Python). Note that a null is different from an empty string. Also, a mapping entry with some key and a null value is valid and different from not having that key in the mapping.


空值类型标量定义表示缺少值。这通常绑定到本地的类似null的值（如Perl中的undef，Python中的None）。请注意，null与空字符串不同。此外，具有某个键和null值的映射条目是有效的，并且与在映射中没有该键不同。

空值表示缺少一个值，可以使用null关键字表示，也可以用~表示。
value: null


日期和时间（Date and Time）日期和时间时间采用 ISO8601 格式表示。
date: 2022-08-01time: 20:30:00datetime: 2022-08-01T20:30:00Z

# 数据类型示例name: &amp;#x27;Alice&amp;#x27;age: 30is_student: trueweight: 65.5birthday: 1990-01-01boolean:     - TRUE  #true,True都可以    - FALSE  #false，False都可以float:    - 3.14    - 6.8523015e+5  #可以使用科学计数法int:    - 123    - 0b1010_0111_0100_1010_1110    #二进制表示null:    nodeName: &amp;#x27;node&amp;#x27;    parent: ~  #使用~表示nullstring:    - 哈哈    - &amp;#x27;Hello world&amp;#x27;  #可以使用双引号或者单引号包裹特殊字符    - newline      newline2    #字符串可以拆成多行，每一行会被转化成一个空格date:    - 2018-02-17    #日期必须使用ISO 8601格式，即yyyy-MM-dddatetime:     -  2018-02-17T15:02:31+08:00    #时间使用ISO 8601格式，时间和日期之间使用T连接，最后使用+代表时区

类型转换YAML 允许使用两个感叹号，强制转换数据类型
e: !!str 123f: !!str true

序列（Sequence）
Generic MappingKindSequence.DefinitionRepresents a collection indexed by sequential integers starting with zero. Example bindings to native types include Perl’s array, Python’s list or tuple and Java’s array or Vector.


通用序列类型序列定义表示一组以从零开始的顺序整数索引的集合。绑定到本地类型的示例包括Perl的数组、Python的列表或元组和Java的数组或向量。

序列（Sequence）：序列是一种元素的有序集合，每个元素可以是任何类型的值，例如字符串、数字、布尔值、映射或序列。
使用短横线和空格表示一个新的元素。使用-表示序列中的元素。序列使用方括号来表示，元素之间使用逗号分隔。
# 序列示例fruits:  - Apple  - Banana  - Orange

- A- B- C

pets: [dog,cat,pig]

key: [value1, value2, ...]

一个相对复杂的例子：
companies:    -        id: 1        name: company1        price: 200W    -        id: 2        name: company2        price: 500W

意思是 companies 属性是一个序列，每一个序列元素又是由 id、name、price 三个属性构成。
序列也可以使用流式(flow)的方式表示：
companies: [&amp;#123;id: 1,name: company1,price: 200W&amp;#125;,&amp;#123;id: 2,name: company2,price: 500W&amp;#125;]



映射（Mapping）
Generic MappingKindMappingDefinitionRepresents an associative container, where each key is unique in the association and mapped to exactly one value. YAML places no restrictions on the type of keys; in particular, they are not restricted to being scalars. Example bindings to native types include Perl’s hash, Python’s dictionary and Java’s Hashtable.


通用映射类型映射定义表示一个关联容器，其中每个键在关联中是唯一的，并映射到一个值。YAML对键的类型没有限制；特别是，它们不限于标量。绑定到本地类型的示例包括Perl的哈希、Python的字典和Java的哈希表。

映射（Map）：使用冒号来分隔键值对，使用短横线和空格来表示一个新的键值对。&amp;#x3D;&amp;#x3D;key: value&amp;#x3D;&amp;#x3D;映射使用大括号来表示，键值对之间使用逗号分隔。
key:     child-key: value    child-key2: value2


website:   name: bianchengbang  url: www.biancheng.net

# 映射示例person:  name: Alice  age: 30  address:    city: New York    street: 123 Main St


key:&amp;#123;key1: value1, key2: value2, ...&amp;#125;

website: &amp;#123;name: bianchengbang,url: www.biancheng.net&amp;#125;


复杂的映射Mapping较为复杂的映射格式，可以使用问号加一个空格代表一个复杂的 key，配合一个冒号加一个空格代表一个 value：
?      - complexkey1    - complexkey2:    - complexvalue1    - complexvalue2

意思即映射的属性是一个序列 [complexkey1,complexkey2]，对应的值也是一个序列 [complexvalue1,complexvalue2]
注释（Comment）注释以井号（#）开头，可以出现在行末或行中间。注释可以帮助我们记录和解释YAML文档中的内容。
# 注释示例# 这是一个映射person:  # 这是一个字符串键  name: Alice  # 这是一个整数键  age: 30


复合结构以上三种数据结构可以任意组合使用，以实现不同的用户需求，例如：
person:  name: zhangsan  age: 30  pets:    -dog    -cat    -pig  car:    name: QQ  child:    name: zhangxiaosan    age: 2

例：
languages:  - Ruby  - Perl  - Python websites:  YAML: yaml.org   Ruby: ruby-lang.org   Python: python.org   Perl: use.perl.org

转换为 json 为：
&amp;#123;   languages: [ &amp;#x27;Ruby&amp;#x27;, &amp;#x27;Perl&amp;#x27;, &amp;#x27;Python&amp;#x27;],  websites: &amp;#123;    YAML: &amp;#x27;yaml.org&amp;#x27;,    Ruby: &amp;#x27;ruby-lang.org&amp;#x27;,    Python: &amp;#x27;python.org&amp;#x27;,    Perl: &amp;#x27;use.perl.org&amp;#x27;   &amp;#125; &amp;#125;

组织结构缩进（Indentation）缩进空格 Indentation Spaces
Indentation SpacesIn YAML block styles, structure is determined by indentation. In general, indentation is defined as a zero or more space characters at the start of a line.To maintain portability, tab characters must not be used in indentation, since different systems treat tabs differently. Note that most modern editors may be configured so that pressing the tab key results in the insertion of an appropriate number of spaces.The amount of indentation is a presentation detail and must not be used to convey content information.Each node must be indented further than its parent node. All sibling nodes must use the exact same indentation level. However the content of each sibling node may be further indented independently.


缩进空格缩进是用来表示嵌套结构的方式。每当一个新的映射或序列开始时，都必须缩进两个或四个空格，以表明其嵌套级别。缩进的空格数量必须是相同的，不能混用。另外，缩进也可以用来对齐相同级别的键值对或元素。每个节点必须比其父节点缩进更多。所有兄弟节点必须使用完全相同的缩进级别。但是，每个兄弟节点的内容可以独立地进一步缩进。

分隔空格Separation Spaces
Separation SpacesOutside indentation and scalar content, YAML uses white space characters for separation between tokens within a line. Note that such white space may safely include tab characters.Separation spaces are a presentation detail and must not be used to convey content information.


分隔空格在缩进和标量内容之外，YAML使用空白字符在行内标记之间进行分隔。请注意，这样的空格可以安全地包括制表符。分隔空格是表示细节，不能用于传达内容信息。

# 缩进示例person:  name: Alice  age: 30  address:    city: New York    street: 123 Main St

锚点、引用、合并&amp;amp; 锚点（Anchor）“&amp;amp;”符号用于创建一个锚点（Anchor）。锚点允许在YAML文档中创建可重用的节点，从而避免重复定义相同的节点。
defaults: &amp;amp;defaults#defaults映射  adapter:  postgres  host:     localhostdevelopment:#development映射  database: myapp_development  &amp;lt;&amp;lt;: *defaultstest:#test映射  database: myapp_test  &amp;lt;&amp;lt;: *defaults

在这个例子中，锚点defaults定义了一个包含adapter和host键的映射。然后，在development和test映射中，使用&amp;lt;&amp;lt;合并键将锚点defaults与这些映射合并，从而&amp;#x3D;&amp;#x3D;继承锚点中定义的键值对&amp;#x3D;&amp;#x3D;。
具体来说，&amp;lt;&amp;lt;合并键表示&amp;#x3D;&amp;#x3D;将当前映射与另一个映射合并，从而继承另一个映射中的键值对&amp;#x3D;&amp;#x3D;。*后面跟着锚点的名称，表示要使用该锚点中定义的键值对。在示例中，&amp;lt;&amp;lt;: *defaults表示将defaults锚点中定义的键值对合并到当前映射中。
因此，在给定的YAML示例中，”&amp;amp;”符号的作用是创建一个锚点，并使用”&amp;lt;&amp;lt;”合并键将锚点中定义的键值对合并到其他映射中，从而避免了重复定义相同的键值对的问题。
* 引用（Alias）
Alias NodesSubsequent occurrences of a previously serialized node are presented as alias nodes. The first occurrence of the node must be marked by an anchor to allow subsequent occurrences to be presented as alias nodes.An alias node is denoted by the “*” indicator. The alias refers to the most recent preceding node having the same anchor. It is an error for an alias node to use an anchor that does not previously occur in the document. It is not an error to specify an anchor that is not used by any alias node.Note that an alias node must not specify any properties or content, as these were already specified at the first occurrence of the node.


别名节点先前序列化的节点的后续出现形式被表示为别名节点。必须通过锚点标记节点的第一次出现，以允许后续出现形式表示为别名节点。别名节点由*指示符表示。该别名引用具有相同锚点的最近的先前节点。如果别名节点使用尚未在文档中出现的锚点，则会出现错误。指定一个别名节点未使用的锚点不是错误。请注意，别名节点不得指定任何属性或内容，因为这些已在节点的第一次出现时指定。

*符号是一个引用标记（anchor reference），用于引用先前定义的锚点（anchor）。
&amp;amp; 锚点和 * 别名，可以用来引用。*符号后跟着锚点的名称，表示要引用该锚点中定义的节点。
引用标记*可以在YAML文档的任何地方使用，包括映射、序列和标量值。它允许在文档中创建可重用的节点，并在需要时引用它们。
defaults: &amp;amp;defaults#defaults映射  adapter:  postgres  host:     localhostdevelopment:#development映射  database: myapp_development  &amp;lt;&amp;lt;: *defaultstest:#test映射  database: myapp_test  &amp;lt;&amp;lt;: *defaults

相当于:
defaults:  adapter:  postgres  host:     localhostdevelopment:  database: myapp_development  adapter:  postgres  host:     localhosttest:  database: myapp_test  adapter:  postgres  host:     localhost


下面是另一个例子:
- &amp;amp;showell Steve - Clark - Brian - Oren - *showell 

转为 JavaScript 代码如下:
[ &amp;#x27;Steve&amp;#x27;, &amp;#x27;Clark&amp;#x27;, &amp;#x27;Brian&amp;#x27;, &amp;#x27;Oren&amp;#x27;, &amp;#x27;Steve&amp;#x27; ]

&amp;lt;&amp;lt; 合并（Merge）“&amp;lt;&amp;lt;”符号是一个合并键（merge key），它用于将一个映射或者哈希表与另一个映射或哈希表合并。表示合并到当前数据，用来引用锚点。
#示例defaults: &amp;amp;defaults#defaults映射  adapter:  postgres  host:     localhostdevelopment:#development映射  database: myapp_development  &amp;lt;&amp;lt;: *defaultstest:#test映射  database: myapp_test  &amp;lt;&amp;lt;: *defaults

在给定的示例中，&amp;lt;&amp;lt;: *defaults表示将当前映射与名为default的映射合并。
*defaults是一个锚点（anchor），它是一个可重用的命名节点，可以在其他位置引用它，*defaults引用了名为default的锚点。
如果default锚点被定义为一个映射，那么&amp;lt;&amp;lt;: *defaults将会将当前映射与default映射进行合并。
合并的方式如下：

当前映射中没有”default”中的键时，将”default”中的所有键值对添加到当前映射中。

当前映射中有”default”中的键时，将”default”中的键值对覆盖当前映射中对应的键值对。


标签（Tags）
In YAML, untagged nodes are given a type depending on the application. The examples in this specification generally use the seq, map and str types from the fail safe schema. A few examples also use the int, float and null types from the JSON schema.Explicit typing is denoted with a tag using the exclamation point (“!”) symbol. Global tags are URIs and may be specified in a tag shorthand notation using a handle. Application-specific local tags may also be used.


在YAML中，未标记的节点根据应用程序赋予一种类型。本规范中的示例通常使用故障安全模式下的seq、map和str类型。一些示例还使用JSON模式下的int、float和null类型。显式类型使用感叹号（“!”）符号标记。全局标记是URI，可以使用句柄的标记缩写表示。也可以使用特定于应用程序的本地标记。

标签用”!”表示，可以用来标识数据类型或格式。标签可以是内置标签或自定义标签。内置标签包括”!!str”（字符串）、”!!int”（整数）、”!!float”（浮点数）等，自定义标签则可以根据需要进行定义。
- !!str &amp;quot;123&amp;quot;- !!int &amp;quot;456&amp;quot;- !!float &amp;quot;3.14&amp;quot;

在上面的示例中，使用了内置标签!!str、!!int和!!float来标识不同的数据类型。
---文档分隔符一个 YAML 文件可以由一个或多个文档组成，文档之间使用---作为分隔符，且个文档相互独立，互不干扰。如果 YAML 文件只包含一个文档，则---分隔符可以省略。  
---website:   name: bianchengbang   url: www.biancheng.net---website: &amp;#123;name: bianchengbang,url: www.biancheng.net&amp;#125;pets:   -dog   -cat   -pig---pets: [dog,cat,pig]name: &amp;quot;zhangsan \n lisi&amp;quot;---name: &amp;#x27;zhangsan \n lisi&amp;#x27;

日志文件完整YAML示例
a sample log file

---Time: 2001-11-23 15:01:42 -5User: edWarning:  This is an error message  for the log file---Time: 2001-11-23 15:02:31 -5User: edWarning:  A slightly different error  message.---Date: 2001-11-23 15:03:17 -5User: edFatal:  Unknown variable &amp;quot;bar&amp;quot;Stack:- file: TopClass.py  line: 23  code: |    x = MoreObject(&amp;quot;345\n&amp;quot;)- file: MoreClass.py  line: 58  code: |-    foo = bar

Spring Boot 常用yml示例：application.yml
server:  port: 8080  servlet:    context-path: /myappspring:  datasource:    url: jdbc:mysql://localhost:3306/mydb    username: myuser    password: mypassword  jpa:    hibernate:      ddl-auto: update    show-sql: truelogging:  level:    root: INFO    com.example.mypackage: DEBUGmyapp:  greeting: Hello, World!  timeout: 5000

参考教程

YAML Ain’t Markup Language (YAML™) version 1.2
YAML 语言教程
YAML for beginners
What is YAML?
YAML Glossary
# YAML教程（快速入门版）
## YAML 入门教程


</content>
    <url>/2023/06/19/YAML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
  </entry>
  <entry>
    <title>ayerr图片显示修复示例</title>
    <content>原主题ayer已在2022年停止更新导致后续图片不能正常显示，作者设计了ayerr 主题：一款基于ayer主题修复了图片显示问题后的衍生主题。
因原主题ayer已停止维护导致博客图片无法显示，于是我对原项目进行fork后修改并重新部署。若有其他问题欢迎联系。
本文详细介绍了 ayerr 主题中可用的图片显示方法，包括三种使用方式和详细的代码范例。
省流：
&amp;#123;% asset_img 图片文件名 &amp;quot;图片描述&amp;quot; %&amp;#125;

![图片描述](firename)

&amp;lt;img src=&amp;quot;图片文件名&amp;quot; alt=&amp;quot;图片描述&amp;quot;&amp;gt;





第一种方式：asset_img标签使用 &amp;#123;% asset_img %&amp;#125; 标签
语法格式
&amp;#123;% asset_img 图片文件名 &amp;quot;图片描述&amp;quot; %&amp;#125;

代码范例
&amp;#123;% asset_img demo.png &amp;quot;这是使用 asset_img 标签的图片&amp;quot; %&amp;#125;

显示效果


特点

专为文章资源文件夹设计
自动处理图片路径
生成带有 article-img 类的图片标签
支持带空格的描述文字
无需手动拼接图片路径

第二种方式：使用传统 Markdown 语法语法格式
![图片描述](图片文件名)

代码范例
![这是使用传统 Markdown 语法的图片](demo.png)

显示效果

特点

标准 Markdown 语法，兼容性好
简洁易记
自动处理文章资源文件夹中的图片
支持描述文字


两种方法的区别




方法
语法
特点
适用场景



asset_img 标签
&amp;#123;% asset_img 图片名 &quot;描述&quot; %&amp;#125;
专为文章资源设计，自动处理路径
推荐使用，兼容性更好


传统 Markdown
![描述](图片名)
标准语法，简洁易记
习惯传统语法的用户



注意事项

启用文章资源文件夹：确保在博客根目录的 _config.yml 中启用：
post_asset_folder: true

图片存放位置：将图片放在与文章同名的资源文件夹中，例如：


source/_posts/├── test-asset-fix.md└── test-asset-fix/    └── demo.png




图片尺寸：建议使用适当尺寸的图片，避免过大影响加载速度

图片格式：支持常见的图片格式，如 PNG、JPG、GIF 等

修复说明


本次修复解决了 ayerr 主题中的图片显示问题，主要包括：

实现了 &amp;#123;% asset_img %&amp;#125; 标签支持
修复了传统 Markdown 图片显示问题
修复了图片 URL 生成逻辑
优化了图片显示样式
确保两种图片使用方式都能正常工作

现在，您可以在 ayerr 主题中自由使用两种图片显示方法，轻松添加图片到您的博客文章中。
第三种方式：原生的 HTML 图片标签&amp;lt;img src=&amp;quot;图片文件名&amp;quot; alt=&amp;quot;图片介绍&amp;quot;&amp;gt;



</content>
    <url>/2026/01/14/ayerr%E5%9B%BE%E7%89%87%E6%98%BE%E7%A4%BA%E4%BF%AE%E5%A4%8D%E7%A4%BA%E4%BE%8B/</url>
  </entry>
  <entry>
    <title>cropper剪裁插件的用法</title>
    <content>cropper剪裁插件的用法


使用方法：加载的文件必须按照顺序加载三个js
&amp;lt;link rel=&amp;quot;stylesheet&amp;quot; href=&amp;quot;../assets/lib/cropper/cropper.css&amp;quot;&amp;gt;&amp;lt;script src=&amp;quot;../assets/lib/jquery.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;&amp;lt;script src=&amp;quot;../assets/lib/cropper/Cropper.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;&amp;lt;script src=&amp;quot;../assets/lib/cropper/jquery-cropper.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;



初始化剪裁插件
let $image = $(&amp;#x27;#image&amp;#x27;); // 找到一张图片（默认显示的那张图片）// 配置项let option = &amp;#123;  // 参考下面的 [参数] 部分  // 比如：aspectRatio 表示剪裁比例  aspectRatio: 400 / 280&amp;#125;;// 初始化$image.cropper(option);

方法的使用
$image.cropper(&amp;#x27;方法名&amp;#x27;, 方法的参数);比如，有一个 replace 方法：replace(url)$image.cropper(&amp;#x27;replace&amp;#x27;, url);比如，剪裁得到canvas，原方法是这样说明的：getCroppedCanvas(&amp;#123; width: 30, height: 10 &amp;#125;)let canvas = $image.cropper(&amp;#x27;getCroppedCanvas&amp;#x27;, &amp;#123; width: 30, height: 10 &amp;#125;);

把canvas转成我们想要的格式
// 剪裁之后，会得到一个canvas// 能够把 canvas 转成 base64 格式；转成 文件对象 格式，只能转成这两种格式// 转成 base64格式let base64 = canvas.toDataURL();// 转成 文件对象 格式canvas.toBlob(function (blob) &amp;#123;  // blob是二进制大对象格式，把它 append 到 FormData 中，会变为文件对象&amp;#125;);



参数
你可以通过$().cropper(options)方法来设置参数。如果你想改变全局默认参数，可以使用$.fn.cropper.setDefaults(options)方法。
aspectRatio：类型：Number，默认值NaN。设置剪裁容器的比例。
crop：类型：Function，默认值null。当改变剪裁容器或图片时的事件函数。
preview：类型：String(jQuery选择器)，默认值’’。添加额外的元素（容器）的预览。注意：
最大宽度是剪裁容器的初始化宽度
最大高度是剪裁容器的初始化高度
如果你设置了aspectRatio参数，确保预览容器具有相同的比例
strict：类型：Boolean，默认值true。在strict模式中，canvas不能小于容器，剪裁容器不能再canvas之外。
responsive：类型：Boolean，默认值true。是否在窗口尺寸改变的时候重置cropper。
checkImageOrigin：类型：Boolean，默认值true。默认情况下，插件会检测图片的源，如果是跨域图片，图片元素会被添加crossOrigin class，并会为图片的url添加一个时间戳来使getCroppedCanvas变为可用。添加时间戳会使图片重新加载，以使跨域图片能够使用getCroppedCanvas。在图片上添加crossOrigin class会阻止在图片url上添加时间戳，及图片的重新加载。
background：类型：Boolean，默认值true。是否在容器上显示网格背景。
modal：类型：Boolean，默认值true。是否在剪裁框上显示黑色的模态窗口。
guides：类型：Boolean，默认值true。是否在剪裁框上显示虚线。
highlight：类型：Boolean，默认值true。是否在剪裁框上显示白色的模态窗口。
autoCrop：类型：Boolean，默认值true。是否在初始化时允许自动剪裁图片。
autoCropArea：类型：Number，默认值0.8（图片的80%）。0-1之间的数值，定义自动剪裁区域的大小。
dragCrop：类型：Boolean，默认值true。是否允许移除当前的剪裁框，并通过拖动来新建一个剪裁框区域。
movable：类型：Boolean，默认值true。是否允许移动剪裁框。
resizable：类型：Boolean，默认值true。是否允许改变剪裁框的大小。
zoomable：类型：Boolean，默认值true。是否允许放大缩小图片。
mouseWheelZoom：类型：Boolean，默认值true。是否允许通过鼠标滚轮来缩放图片。
touchDragZoom：类型：Boolean，默认值true。是否允许通过触摸移动来缩放图片。
rotatable：类型：Boolean，默认值true。是否允许旋转图片。
minContainerWidth：类型：Number，默认值200。容器的最小宽度。
minContainerHeight：类型：Number，默认值100。容器的最小高度。
minCanvasWidth：类型：Number，默认值0。canvas 的最小宽度（image wrapper）。
minCanvasHeight：类型：Number，默认值0。canvas 的最小高度（image wrapper）。
build：类型：Function，默认值null。build.cropper事件的简写方式。
built：类型：Function，默认值null。built.cropper事件的简写方式。
dragstart：类型：Function，默认值null。dragstart.cropper事件的简写方式。
dragmove：类型：Function，默认值null。dragmove.cropper事件的简写方式。
dragend：类型：Function，默认值null。dragend.cropper事件的简写方式。
zoomin：类型：Function，默认值null。zoomin.cropper事件的简写方式。
zoomout：类型：Function，默认值null。zoomout.cropper事件的简写方式。

方法因为图片是异步加载的，所以你需要在built之后才能调用下面的方法，setAspectRatio、replace和destroy方法例外。
$().cropper(&amp;#123;`` ``built: ``function` `() &amp;#123;``  ``$().cropper(``&amp;#x27;method&amp;#x27;``, argument1, , argument2, ..., argumentN)`` ``&amp;#125;``&amp;#125;

move(offsetX, offsetY)：

offsetX：类型：Number，水平方向上移动的大小，单位像素。
offsetY：类型：Number，垂直方向上移动的大小，单位像素。

移动一幅图片：
$().cropper(``&amp;#x27;move&amp;#x27;``, 1, 0)``$().cropper(``&amp;#x27;move&amp;#x27;``, 0, -1)

zoom(ratio)：
ratio：
类型：Number

Zoom in：需要一个正数（ratio &amp;gt; 0）
Zoom out：需要一个负数（ratio &amp;lt; 0）

缩放一幅图片：
$().cropper(``&amp;#x27;zoom&amp;#x27;``, 0.1)``$().cropper(``&amp;#x27;zoom&amp;#x27;``, -0.1)

rotate(degree)：
ratio：
类型：Number

Rotate right：需要一个正数（degree &amp;gt; 0）
Rotate left：需要一个负数（degree &amp;lt; 0）

旋转一幅图片，需要CSS3 Transforms3d的支持（IE10+）：
$().cropper(``&amp;#x27;rotate&amp;#x27;``, 90)``$().cropper(``&amp;#x27;rotate&amp;#x27;``, -90

enable()：使cropper可用。
disable()：冻结cropper。
reset()：重置剪裁区域的图片到初始状态。
clear()：清空剪裁区域。
replace(url)：
url：``替换图片的URL重建cropper。``类型：String``一个新的图片URL

getData()：
返回值：``类型：Object``属性：``x：剪裁区域左侧的偏移。``y：剪裁区域距上部的偏移。``width：剪裁区域的宽度。``height：剪裁区域的高度。``rotate：图片的旋转角度。``请参考实例效果

getContainerData()：
返回值：``类型：Object``属性：``width：容器的当前宽度。``height：容器的当前高度。``输出容器尺寸数据。

getImageData()：
返回值：
类型：Object
属性：``left：图片的左侧偏移。``top：图片的上部偏移。``width：图片的宽度。``height：图片的高度。``输出图片的位置和尺寸大小。

getCanvasData()：
返回值：``类型：Object``属性：``left：canvas的左侧偏移。``top：canvas的上部偏移。``width：canvas的宽度。``height：canvas的高度。``输出canvas（图片容器）的位置和尺寸大小。

setCanvasData(data)：
返回值：``类型：Object``属性：``left：canvas的距离左侧新的偏移。``top：canvas的距离上部新的偏移。``width：canvas新的宽度。``height：canvas新的高度。``改变canvas（图片容器）的位置和尺寸大小。

getCropBoxData()：
返回值：``类型：Object``属性：``left：剪裁区域距离左侧的偏移。``top：剪裁区域距离上部的偏移。``width：剪裁区域的宽度。``height：剪裁区域的高度。``输出剪裁区域的位置和尺寸大小。

setCropBoxData(data)：
返回值：``类型：Object``属性：``left：剪裁区域距离左侧新的偏移。``top：剪裁区域距离上部新的偏移。``width：剪裁区域新的宽度。``height：剪裁区域新的高度。``改变剪裁区域的位置和尺寸大小。

getCroppedCanvas([options])：
参数（默认值）：``类型：Object``属性：``width：输出的canvas目标宽度。``height：输出的canvas目标高度。``fillColor：canvas中填充的颜色。``返回值：``类型：HTMLCanvasElement``一个画有剪裁图片的canvas。</content>
    <url>/2021/05/26/cropper%E5%89%AA%E8%A3%81%E6%8F%92%E4%BB%B6%E7%9A%84%E7%94%A8%E6%B3%95/</url>
  </entry>
  <entry>
    <title>Hello World</title>
    <content>Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.


Quick StartCreate a new post$ hexo new &amp;quot;My New Post&amp;quot;

More info: Writing
Run server$ hexo server

More info: Server
Generate static files$ hexo generate

More info: Generating
Deploy to remote sites$ hexo deploy

More info: Deployment
</content>
    <url>/2020/08/01/hello-world/</url>
  </entry>
  <entry>
    <title>dos命令存档</title>
    <content>dos命令存档


打开命令窗口
开始+系统+命令提示符
Windows+R 输入cmd打开控制台
在任意的文件夹下面，按住shift键+鼠标右键点击，在此处打开命令行窗口 ( Powershell )
资源管理器的地址栏前面加上 cmd 路径

Dos( Disk Operating System ), 磁盘操作系统
部分Dos命令改变当前盘符c:d:

目录创建目录&amp;#x2F;文件夹md + 文件夹名
md test

移除目录&amp;#x2F;文件夹rd + 文件夹名
rd test

进入指定目录cd

退回到上一级目录cd..

退回到根目录cd\

文件创建文件type nul&amp;gt; + 文件名+文件名后缀
type nul&amp;gt;test.txt

写入内容到文件echo Hello Word &amp;gt;test.txt

追加内容到文件echo Hello Word &amp;gt;&amp;gt;test.txt

在文件夹里创建文件cd&amp;gt;

在文件夹里移除文件del + 文件名
del test.doc

更改文件名ren 

列出当前目录下的文件和文件夹dir

退出 dos 命令行exit

清理屏幕cls

查看电脑ipipconfig

ping命令ping www.baidu.com

Java查看jdc安装信息java -version



编译java文件javac + java文件名.java
javac test.java

运行java文件java + 文件名
java test

生成Javadoc文档javadoc -d doc -author -version next1.java

(Java文件内添加javadoc注释)
/****@author 作者名*@version 1.0*/























</content>
    <url>/2020/08/02/dos%E5%91%BD%E4%BB%A4%E5%AD%98%E6%A1%A3/</url>
  </entry>
  <entry>
    <title>properties文件或类笔记</title>
    <content>有关properties配置文件的详细（并非）研究


properties文件是java所支持的配置文件类型，java中的properties文件是一种配置文件，  主要用于表达配置信息，  文件类型为*.properties，  格式为文本文件，  在properties文件中，可以用”#”来作注释。
文件的内容是格式是 “键&amp;#x3D;值”的格式，  
properties是配置文件。
主要的作用是通过修改配置文件可以方便地修改代码中的参数，实现不用改class文件即可灵活变更参数。
解释：java运行中java文件会变成class文件，之后无法通过反编译找到原样的代码，这样的话，如果java类中某个参数变更，就很难灵活的实现参数修改，这个时候properties 文件就能很灵活的实现配置，减少代码的维护成本和提高开发效率。
jdbc.properties&amp;#x2F;database.properties示例：在SMM项目中，JDBC配置文件用于配置应用程序与数据库之间的连接。通常，JDBC配置文件中应该包含以下属性：

jdbc.driver: 数据库驱动程序的类名，例如com.mysql.jdbc.Driver。
jdbc.url: 数据库的URL地址，例如jdbc:mysql:&amp;#x2F;&amp;#x2F;localhost:3306&amp;#x2F;mydatabase。
jdbc.username: 连接数据库所需的用户名。
jdbc.password: 连接数据库所需的密码。
jdbc.initialSize: 连接池初始化时创建的连接数。
jdbc.maxActive: 连接池中最大的活动连接数。
jdbc.maxIdle: 连接池中最大的空闲连接数。
jdbc.minIdle: 连接池中最小的空闲连接数。

以上属性是最常见的JDBC配置属性，当然，还有其他一些属性可以根据具体应用场景进行配置，例如连接超时时间、查询超时时间、验证语句等。
driverClassName=com.mysql.cj.jdbc.Driver#com.mysql.cj.jdbc.Driver为MySQL8.0版本以上url=jdbc:mysql://localhost:3306/kgcuser=rootpassword=root  initialSize=5  maxActive=10


url=jdbc:mysql://localhost:3306/appinfodb?useUnicode=true&amp;amp;amp&amp;amp;characterEncoding=utf-8&amp;amp;zeroDateTimeBehavior=rounddriver=com.mysql.jdbc.Driver  #这是JDBC连接字符串，指定了MySQL数据库的地址和要连接的数据库名称。#com.mysql.jdbc.Driver 为MySQL5.0版本左右#`useUnicode=true`指定要使用Unicode字符集，#`characterEncoding=utf-8`指定字符集为UTF-8#`zeroDateTimeBehavior=round`指定当数据库中的日期时间字段为零时，应将其舍入到最接近的值。username=root  password=root  minIdle=45  maxIdle=50  initialSize=5  maxActive=100  maxWait=100  removeAbandonedTimeout=180  #这是连接被认为是遗弃的时间，以秒为单位，在这段时间内未被使用的连接将被关闭，这里配置为180秒。removeAbandoned=true#这是一个布尔值，指示是否启用连接的遗弃检查。如果设置为true，则连接池将在`removeAbandonedTimeout`时间内检查连接是否被遗弃，如果是，则关闭该连接。



读取properties文件示例代码public static Properties getProperties(String config) throws IOException &amp;#123;//获取properties文件        Properties properties = new Properties();        InputStreamReader in=null;//输入流        FileInputStream inStream=null ;//文件输入        try &amp;#123;            inStream = new FileInputStream(new File(config));            in = new InputStreamReader(inStream,(&amp;quot;UTF-8&amp;quot;));                // 处理中文字符流            properties.load(in);            //加载properties文件        &amp;#125;catch (Exception e) &amp;#123;            log.error(&amp;quot;无法找到并使用配置文件: [ &amp;quot; + config+&amp;quot; ]&amp;quot;);        &amp;#125;finally &amp;#123;            if (inStream!=null) &amp;#123;                inStream.close();            &amp;#125;            if (in!=null) &amp;#123;                in.close();            &amp;#125;        &amp;#125;        return properties;    &amp;#125;





Properties类主要用于读取Java的配置文件.Properties类表示一组持久的属性。properties属性可以保存到流中或从流中加载。properties属性列表中的每个键及其对应的值都是一个字符串。properties属性列表可以包含另一个属性列表作为其“默认值”;如果在原始属性列表中找不到属性键，则会搜索此第二个属性列表。
方法：load—加载;store–存储;load（Reader）&amp;#x2F;store（Writer，String）方法以一个简单的面向行的格式从以下格式加载和存储属性到基于字符的流。load（InputStream）&amp;#x2F;store（OutputStream，String）方法的工作方式与加载（Reader）&amp;#x2F;存储（Writer，String）对相同，只是输入&amp;#x2F;输出流以ISO 8859-1字符编码编码。
Properties 类表示了一个持久的属性集。Properties 可保存在流中或从流中加载。属性列表中每个键及其对应值都是一个字符串。
一个属性列表可包含另一个属性列表作为它的“默认值”;如果未能在原有的属性列表中搜索到属性键，则搜索第二个属性列表。

因为 Properties 继承于 Hashtable，所以可对 Properties 对象应用 put 和 putAll 方法。但不建议使用这两个方法，因为它们允许调用者插入其键或值不是 String 的项。相反，应该使用 setProperty 方法。如果在“不安全”的 Properties 对象(即包含非 String 的键或值)上调用 store 或 save 方法，则该调用将失败。类似地，如果在“不安全”的Properties 对象(即包含非 String 的键)上调用 propertyNames 或 list 方法，则该调用将失败。

简单用例-1打印自定义.properties 文件中的值在src&amp;#x2F;main&amp;#x2F;resources 目录下，放置 jdbc.properties 文件，是数据库的配置文件。![[Pasted image 20230617144233.png]]
jdbc.driver=com.mysql.jdbc.Driverjdbcurl=jdbc:mysql://localhost:3306/mybatis?characterEncoding=utf8jdbcusername=rootpassword=root

list 输出到控制台 用绝对路径加载
@Testpublic void name1Test()&amp;#123;	try&amp;#123;		Properties properties=new Properties();		//磁盘符的绝对路径		InputStream input=new BufferedInputStream(new FileInputStream(&amp;quot;D:\\jdbc.properties&amp;quot;));		properties.load(input);		properties.list(System.out);	&amp;#125;catch(Exception e)&amp;#123;		e.printStackTrace();	&amp;#125;&amp;#125;


-2propertyNames 输出 getClass() 加载@Testpublic void name2Test()&amp;#123;        	try&amp;#123;            		Properties properties=new Properties();  		// 用/文件名， / 表示根目录            		InputStream input=PropertiesTest.class.getClass().getResourceAsStream(&amp;quot;/jdbc.properties&amp;quot;);            		properties.load(input);            		Enumeration&amp;lt;String&amp;gt; names=(Enumeration&amp;lt;String&amp;gt;) properties.propertyNames();            		while(names.hasMoreElements())&amp;#123;		//这是key值            			String key=names.nextElement();            			String value=properties.getProperty(key);            			System.out.println(key+&amp;quot;=&amp;quot;+value);   			&amp;#125;              	&amp;#125;catch(Exception e)&amp;#123;   	 		e.printStackTrace();    	&amp;#125;&amp;#125;


-3stringPropertyNames 输出 getClassLoader 加载 (推荐)@Testpublic void name3Test()&amp;#123;	try&amp;#123;        	Properties properties=new Properties();        	//直接写src 类路径下的文件名        	InputStream input=PropertiesTest.class.getClassLoader().getResourceAsStream(&amp;quot;jdbc.properties&amp;quot;);        	properties.load(input);                	//把key值转换成set 的形式，遍历set        	Set&amp;lt;String&amp;gt; names=properties.stringPropertyNames();        Iterator&amp;lt;String&amp;gt; iterator=names.iterator();        	while(iterator.hasNext())&amp;#123;        		String key=iterator.next();        		String value=properties.getProperty(key);        		System.out.println(key+&amp;quot;=&amp;quot;+value);    		&amp;#125;	&amp;#125;catch(Exception e)&amp;#123;    				e.printStackTrace();    	&amp;#125;&amp;#125;



-4获取值 getProperties@Testpublic void name3Test()&amp;#123;	    	try&amp;#123;				Properties properties=new Properties();				InputStream input=PropertiesTest.class.getClassLoader().getResourceAsStream(&amp;quot;jdbc.properties&amp;quot;);				properties.load(input);				//String value=properties.getProperty(&amp;quot;jdbc.url&amp;quot;);				String value=properties.getProperty(&amp;quot;jdbc.url1&amp;quot;,&amp;quot;没有该key值&amp;quot;);				System.out.println(&amp;quot;输出值：&amp;quot;+value);				&amp;#125;catch(Exception e)&amp;#123;					e.printStackTrace();			&amp;#125;	&amp;#125;


-5普通写入，中文时乱码@Testpublic void writeTest()&amp;#123;	    	try&amp;#123;				Properties properties=new Properties();				InputStream input=PropertiesTest.class.getClassLoader().getResourceAsStream(&amp;quot;jdbc.properties&amp;quot;);				properties.load(input);						//多添加几个值。				properties.setProperty(&amp;quot;name&amp;quot;,&amp;quot;两个蝴蝶飞&amp;quot;);				properties.setProperty(&amp;quot;sex&amp;quot;,&amp;quot;男&amp;quot;);				//properties.put(&amp;quot;name&amp;quot;,&amp;quot;两个蝴蝶飞&amp;quot;);  		//可以用继承Hashtable 的put 方法写入值				// properties.put(&amp;quot;sex&amp;quot;,&amp;quot;男&amp;quot;);						//将添加的值，连同以前的值一起写入 新的属性文件里面。				OutputStream out=new FileOutputStream(&amp;quot;D:\\jdbc.properties&amp;quot;);				properties.store(out,&amp;quot;填充数据&amp;quot;);					&amp;#125;catch(Exception e)&amp;#123;				e.printStackTrace();			&amp;#125;	&amp;#125;


-6解决乱码写入的问题@Testpublic void write2Test()&amp;#123;	    	try&amp;#123;        		Properties properties=new Properties();        		//用绝对路径        		InputStream input=new BufferedInputStream(new FileInputStream(&amp;quot;D:\\workspace\\JavaLearn\\src\\jdbc.properties&amp;quot;));    		properties.load(new InputStreamReader(input,&amp;quot;utf-8&amp;quot;));        		//多添加几个值。        		properties.setProperty(&amp;quot;name&amp;quot;,&amp;quot;两个蝴蝶飞&amp;quot;);        		properties.setProperty(&amp;quot;sex&amp;quot;,&amp;quot;男&amp;quot;);        		OutputStream output=new 		FileOutputStream(&amp;quot;D:\\jdbc.properties&amp;quot;);        		OutputStreamWriter out=new OutputStreamWriter(output,&amp;quot;utf-8&amp;quot;); 		properties.store(out,&amp;quot;填充数据&amp;quot;);					&amp;#125;catch(Exception e)&amp;#123;					e.printStackTrace();			&amp;#125;	&amp;#125;


-7导出到 .xml 配置文件 storeToXML@Testpublic void xmlWriteTest()&amp;#123;	    	try&amp;#123;        		//处理成编码样式。        		Properties properties=new Properties();        		//多添加几个值。        		properties.setProperty(&amp;quot;name&amp;quot;,&amp;quot;两个蝴蝶飞&amp;quot;);        		properties.setProperty(&amp;quot;sex&amp;quot;,&amp;quot;男&amp;quot;);        		OutputStream output=new FileOutputStream(&amp;quot;D:\\jdbc.xml&amp;quot;);      		//编码设置成utf-8的形式。         		properties.storeToXML(output,&amp;quot;填充到xml&amp;quot;,&amp;quot;utf-8&amp;quot;);					&amp;#125;catch(Exception e)&amp;#123;					e.printStackTrace();			&amp;#125;	&amp;#125;


-8导出XML 配置文件 loadFromXML @Test public void xmlReadTest()&amp;#123;	     	 try&amp;#123;        		 Properties properties=new Properties();        		 InputStream input=new BufferedInputStream(new FileInputStream(&amp;quot;D:\\jdbc.xml&amp;quot;));        		 properties.loadFromXML(input);        		 properties.list(System.out);				&amp;#125;catch(Exception e)&amp;#123;				e.printStackTrace();		&amp;#125;&amp;#125;



参考文章properties文件 , properties类, 的作用properties文件Java基础——Properties类
</content>
    <url>/2023/08/24/properties%E6%96%87%E4%BB%B6%E6%88%96%E7%B1%BB%E7%AC%94%E8%AE%B0/</url>
  </entry>
  <entry>
    <title>从零入门的MMD学习笔记</title>
    <content>本篇MMD学习笔记为从零入门，前期铺垫了许多内容，如果需要直接实战请移步B站寻找相关教程。
https://www.bilibili.com/read/cv20273?from=articleDetail)


本篇学习笔记参考的教程：最系统的MMD零基础入门教程宝典
MMD兵器库
MMD入门综合指南3.1（2021修改版)
[MMD（MikumikuDance）的发展历史](
MMD一般流程1.找资源（或制作资源）并载入MMD
2.渲染
3.导出
4.后期加音乐，加特效，字幕
5.导出，压制
6.投稿 
部分下载链接&amp;#x2F;教程链接：MMD.zip下载链接：https://pan.baidu.com/s/1G-qUnTPzNSbDpT2fzO4gQw?pwd=mqmj提取码：mqmj 
MikuMikuDance.7z软件下载：https://pan.baidu.com/s/1XYEUEsb2AvtGbBZZ3-z_aQ提取码：2021
Paper朱基础教学小菜谱.zip链接：https://pan.baidu.com/s/10k6m0LPKaDVBrmi9Q-SDCA提取码：38pn
MMD软件链接：https://pan.baidu.com/s/1GxjIKZuPMnNzB37_bB3Ghg?pwd=xasq
Paper朱基础教学小菜谱（7.3更新）.zip链接：https://pan.baidu.com/s/1-qYk_oAQrCBLzWdyinO2rw提取码：5sr4
Paper朱教程11.4更新MME：链接：https://pan.baidu.com/s/1EzJOyx6e22a2urTE4cioTA提取码：yhm9
穆小泠弹指醉mmd：https://pan.baidu.com/s/1-Wh9MMl63bB3M-TRHqRE6w?pwd=0124#list/path=%2F
MikuMikuDance是日本人樋口优所开发，将VOCALOID2的初音未来等角色制作3D模组的免费软件。



软件列表篇MikuMikuDance
PmxEditor (PE)
Notepad++ 
GoldWave
Bandzip 
小丸工具箱
PS  PR  AE 
Crazybump 
Aectime 
VPN
百度云
翻译工具
MMD制作所需的资源主要包括人物模型，场景，动作，姿势，镜头，音乐，MME（特效）另外还有贴图文件等。
MMD相关网站链接国内：
B站：https://www.bilibili.com

MMD贴吧：http://tieba.baidu.com/f?kw=mikumikudance

萌舞论坛：http://www.moe5.net/forum.php

模之屋 ：https://www.aplaybox.com/

尼特部落：http://geek.prdsarea.com

MMD咸鱼维基：https://xywiki.com/MMD

初音社：https://www.mikuclub.org


国外：
NiceNico：http://www.nicovideo.jp/ 
使用翻墙，翻译工具。一般在静画区，用日文去搜索
モーション ——动作，モデル—— 模型，ステージ——场景，カメラ——镜头

YouTube：https://www.youtube.com/

Deviantart：http://www.deviantart.com/

日本MMD资源集中区：https://bowlroll.net/file/index

BowlRoll(B碗) 模型下载：https://bowlroll.net/file/224701
搜素时中，日，英皆可
model——模型，stage——场景，motion——动作，camera——镜头

官方MMD资源集合站：https://www6.atwiki.jp/vpvpwiki

Deviantart（Da站）

LearnMMD：https://learnmmd.com/downloads/

GitHub：https://github.com 

wiki

3dtextures 

cc0textures

iiidea.cn


MMD相关基础知识MMD常用名词 pmm———MMD的工程文件, 记录使用了那些模型,场景,动作,镜头,特效等
pmd&amp;#x2F;pmx—-一般是人物模型文件(有时也会是道具)
x————–一般是场景 ，或者道具模型,还可能是特效文件
fx————-特效文件
vmd———-动作文件，一般是角色动作，或者摄像机、灯光的运动记录。
vqd———–这是姿势文件，载入后，角色就会摆个指定的pose
MME———MikuMikuEffect , 是用来添加各种特效的文件
PE————-Pmd Editor , 用来改模型的软件
常见的软件介绍视频处理相关： Adobe Premiere Pro（Pr）———视频剪辑软件
Adobe After Effects（Ae）———-视频特效包装合成软件
Adobe Photoshop（Ps）————众所众知的PS软件，修图
Adobe Media Encoder——-Adobe自家的编码转格式软件。
Sony Vegas Pro—————-剪辑软件
小丸工具箱——————–视频压制处理工具
完美解码+Potplayer———视频解码器和播放器，增加输出编码选项。
三维相关：CINEMA 4D R18————三维软件，偏向包装制作
3ds Max———————三维软件，偏向游戏建筑
Maya————————-三维软件，偏向影视游戏
Metasequoia 4（水杉）—–三维软件，早期比较适合MMD建模
Bitmap2Material————制作材质的一款软件
Marvelous Designer——–衣服制作，以及布料模拟
渲染目前MMD这个软件有众多渲染方式。常见的有：
Ik渲染(ikpolishshader)，T渲染(T_ToonShader)，Ray渲染，AT渲染(A-Toon)，PS渲染(Power-Shader)，ES渲染(excellentshadow)，N渲染(NCHLShader)，G渲染(G-SToonShader) 作者：Yashoku雫霁 https://www.bilibili.com/read/cv1090815?spm_id_from=333.880.0.0 出处：bilibili
模型的制式常见的四种YYB式 TDA式 三妈式(mamama) Sour式
http://tieba.baidu.com/p/4750456116 



借物表动作：名称+作者  
镜头：名称+作者  
舞台：名称+作者
音乐：名称+歌手
渲染：渲染主件和附件名称+原作者
工具：名称
部分作者糖斯 场景配布作者
RedialC 教程作者 配布作者 
小怪兽粉刷月球 动作配布作者
溯北P 场景配布作者
Sour暄 模型配布作者
神帝宇 崩3配布作者
椛暗_Official 模型配布作者
永远赤红的幼月 镜头配布作者
samsink 模型配布作者
三目YYB 模型配布作者
</content>
    <url>/2021/11/20/%E4%BB%8E%E9%9B%B6%E5%85%A5%E9%97%A8%E7%9A%84MMD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
  </entry>
  <entry>
    <title>以【叙事性线构插图】为目的的绘画学习日志</title>
    <content>以叙事为最终目的，以线条刻画细节、叙事性构图为主、叙事性色彩为辅的画法。
ps：自己个人总结的喜欢的画风，本篇写的内容也全都是个人学习探索
为了达到这个画风效果具体学习过哪些内容请看另一篇以【叙事性线构插图】为目的的绘画知识库


详细解释叙事性线构插图：以线条和构图驱动故事的绘画形式这是一种将 “线条的表现力” 和 “构图的叙事性” 推向极致的插画形式。色彩在这里退居二位，成为烘托氛围的辅助工具，而非塑造形体的主力。
核心特征
故事内容为主: 一切技术的终点都是为了更好地表达故事内核。画面不再是技术的炫耀，而是故事的容器。
构图占比含量高: 构图不再是“安排元素”，其本身就是第一叙事语言。强烈的几何分割、巧妙的负空间、精准的视觉引导，是画面的骨架和灵魂。
以线条为主，色彩为辅 : 线条承担了定义形体、表现质感、暗示光影、传递情绪的全部重任。色彩通常用于建立色调、区分层次、营造氛围，多为平涂或有限渐变。
目的是叙事: 创作的原始驱动力是“讲述”，而不是“描绘”。
依赖故事性载体 : 通常通过具有象征意义的物品、环境细节和符号来承载故事，而不是直接描绘事件瞬间（例如直接画两个人打架）。

初步尝试
【叙事】 -&amp;gt; “一句话故事”
【构图】 -&amp;gt; “强制选择”
【线条】 -&amp;gt; “信息量线条”

第一步：一句话故事（定义叙事）
做什么： 在动笔前，用一句话说清你想讲的故事。
格式： 【物体】+【状态】+【情绪】
例子：
旧怀表 + 在被雨打湿的窗台上停止走动 + 孤独
玩具士兵 + 在巨大的皮鞋旁列队 + 无畏
情书 + 被揉成一团又展开 + 悔恨


怎么练： 每天想5个“一句话故事”。这是最重要的肌肉训练，它保证你的画永远“有话说”。

第二步：强制选择（激活构图）
做什么： 为你的“一句话故事”选择一个最强的构图公式。不要“随便画画”，必须强制二选一。
选择A：几何切割（强大、戏剧性）
用一个大号的、简单的几何形（三角、圆、方）去切割画面。
思考： 我的故事用哪种形状最搭？稳定（方）？动荡（三角）？循环（圆）？聚焦（圆）？


选择B：焦点引导（微妙、氛围感）
确定一个唯一的视觉焦点（C位），用所有元素（线条、明暗）去引导观众看它。
思考： 画面中哪个元素是故事的灵魂？用什么办法（汇聚线、明暗对比、框景）能把它锁死在C位？


怎么练： 为你的每个“一句话故事”，同时画两个邮票大小的草图小稿（Thumbnail），一个用几何切割，一个用焦点引导。

第三步：信息量线条（执行线条）
做什么： 在确定的构图小稿上，思考线条的“任务”。
线条的三个任务：
塑形（是什么）： 用准确的线条画出结构、透视。这是基本功。
质感（摸起来怎样）： 用不同的笔触（排线、点、曲折线）表现木头、金属、布料。
氛围（感觉怎样）： 用线条的稳定性（平稳长线） 或躁动性（短促断线） 来传递情绪。


怎么练： 画的时候，心里默念：“我这一笔，是在完成哪个任务？” 是让它更立体（任务1）？还是让它更有质感（任务2）？还是让它更忧郁（任务3）？

学习内容参考-1理论素养
格式塔心理学（图形心理学）：
学什么： 完形原则（接近性、相似性、连续性、封闭性等）。
怎么用： 你如何排列元素，观众会自动将其感知为一个整体（角色）或一个组（人群）？如何利用“封闭性”让观众脑补出完整的形状？这是你构图时操控观众潜意识的根本法则。


符号学：
学什么： 能指（Signifier）与所指（Signified）。即一个图像（能指）背后约定俗成的含义（所指）。
怎么用： 你画的“手表”不是一个计时工具（能指），而是“童年的纯真”、“破裂的誓言”或“传承的记忆”（所指）。你的创作就是在选择和组合符号来编码你的故事，等待观众解码。


色彩心理学：
学什么： 不同色彩、色调、明度带来的普遍心理感受和文化特定含义。
怎么用： 在你的“线为主，色为辅”风格中，色彩是战略性的核武器。只在一幅棕色调的、怀旧的故事里，给一个关键物品点上一点点绿色，这一点点绿色就会成为充满希望或诡异感的绝对焦点。


艺术史与哲学：
学什么： 不同时代、流派的作品和理念。
怎么用： 不是为了掉书袋，是为了站在巨人的肩膀上。当你想表达“疏离感”，你是否能想到爱德华·霍普？当你想表现“扭曲的心理”，你是否能参考奥地利表现主义？艺术史是一个巨大的解决方案库。



技术基础
素描： 不是像素描作业那样涂调子，而是“结构素描”——用线条的轻重、虚实来表现体积和空间。这是你线稿立体感的根源。
透视： 您已掌握。它是构建可信叙事空间的基石，确保所有物体安稳地待在它们该在的地方。
解剖与质感： 学习解剖不是为了画肌肉男，是为了理解衣物下的身体如何驱动布料产生褶皱。学习质感（木纹、金属、玻璃）是为了让你的线条排得更准确，一眼就能区分出不同材质。

视觉语言
构图： 您表格中的“专项设计-叙事性构图”应提升到此处，作为视觉语言的总指挥官。
光影： 在您的风格里，光影不再通过涂抹明暗来表现，而是通过线条的疏密组织（排线） 来表现。这是需要专门训练的顶级技巧。
动态设计： 即使画一个静止的物品，也要考虑其内在的动势和节奏感。一个歪倒的杯子比一个摆正的杯子更有故事。

创作思维这是将您与其他画匠区分开来的领域。

世界观构建： 您画的“锈迹斑斑的手表”属于一个怎样的世界？是末世废土？还是蒸汽朋克？世界观的设定决定了物品的设计逻辑。
隐喻设计： 这是符号学的具体实践。有意识地选择“隐喻物”和“被隐喻物”，并进行视觉上的结合。（例如：用破碎的镜子映射出一个完整但哭泣的脸）。
跨学科灵感： 从文学、电影、音乐、哲学、科学中汲取灵感。一个物理定律（如熵增）如何用视觉呈现？这是最高级的叙事。

学习内容参考-2在B站或YouTube搜索 “Every Frame a Painting” 这个频道。看任何一集（中文字幕）。看他如何像外科医生一样解剖电影画面是如何讲故事的。这是对你大脑最好的构图叙事启蒙。
《构图的艺术》（Ian Roberts）这本书的电子版或实体书。不要通读，直接看里面的图画，看他如何用简单的色块形状来构建画面力量感。这是对你“几何切割”思维的直接强化。
当你对构图有基本感觉后，唯一推荐一个付费课程：《Visual Storytelling 视觉叙事》by Iain McCaig（在Schoolism平台上）这不是教怎么画的课，是教怎么想的课。Iain McCaig是业界传奇（《星球大战》概念设计师），他用最生动的方式，把“符号学”、“心理学”、“叙事学”融汇在了具体的创作中。这堂课是把所有零散知识串起来的“线”。
《构图的艺术》（The Art of Composition）by Ian Roberts这是对“构图占比含量高”理念的教材。它超越了简单的三分法，教如何用抽象的形状、值和色彩来构建有吸引力和动态的画面。实践性极强。
《视觉叙事：数字时代影视创作的语法》（Visual Storytelling: How to Speak to Your Audience Without Saying a Word）by Morgan Sandler 它从电影语言的角度剖析视觉叙事，教如何用镜头（相当于你的画框）、光影、色彩来引导情绪和讲述故事。
《框架信息：艺术家和设计师的符号学》（Framing Information: Semiotics for Artists and Designers） 直接回应对“符号学”的兴趣。它教如何有意识地使用图像、颜色和符号来传递特定信息，让“故事性载体”充满内涵。
《素描的原力》（The Force: How to Draw）by Michael Mattesi 它教的不是解剖，而是如何用“力”和“节奏”来画出生动、有活力的线条。这对于让线稿充满表现力和动感至关重要。
《安德鲁·路米斯的素描课》系列（Figure Drawing for All It’s Worth, etc.)虽然主题是人体，但其核心是教如何用简洁、概括的线条精准地捕捉形体与动态。这种简化思维适用于万物。
《想象：创造力的艺术与科学》（Imagine: How Creativity Works）by Jonah Lehrer 当感到迷茫和卡顿时，这本书能从神经科学和心理学角度给你启发，告诉你创意是如何产生的，以及如何为自己营造一个充满创造力的环境。
《艺术家之路》（The Artist’s Way）by Julia Cameron这是一本为期12周的“创造性自我发现”工作簿。它通过“晨间笔记”等实践方法，帮你破除创作障碍，找回创作的初心与快乐，非常适合在焦虑期使用。
《叙事性插图：用画面讲故事》（ Narrative Illustration: Tell a Story without Words ）by 【例如在Domestika, Skillshare等平台搜索此标题】这类课程通常由活跃的插画师讲授，他们会完整展示从构思、草图到完成一幅叙事性插画的全过程。
Proko 频道（YouTube&amp;#x2F;官网）虽然以解剖闻名，但Proko的课程本质是教人如何“理解”而非“复制”。他的“结构法”画人体和画物品的思维是相通的，能极大强化造型能力。
《色彩学：数字艺术家的科学与应用》（ Color for Digital Artists ）by 【Schoolism或CGMA等平台】“色彩为辅”需要学懂色彩的科学。这门课能在有限的用色中，做出最精准、最有效果的选择。
《Every Frame a Painting》（ 每一帧都是画 ）【YouTube频道（已停更，但全是精华）】 这是学习视觉叙事的圣经。频道通过拉片的方式，极致地分析了电影大师（如今敏、奉俊昊）如何用构图、剪辑、运动来讲故事。每一集都是一堂大师课。
《Sideways》（ 横向 ）【YouTube频道】 虽然主题是“音乐”，但它深入浅出地分析音乐如何影响情绪、构建主题、塑造人物。这种跨学科的叙事逻辑对你用视觉讲故事有极大的启发和迁移作用。
《Ahmed Aldoori》、《Sinix Design》等艺术家频道【YouTube】 观看职业艺术家是如何思考的。他们经常分享自己的创作流程、草图、以及如何从生活中汲取灵感。这是一种“沉浸式”的学习。
</content>
    <url>/2025/03/20/%E4%BB%A5%E3%80%90%E5%8F%99%E4%BA%8B%E6%80%A7%E7%BA%BF%E6%9E%84%E6%8F%92%E5%9B%BE%E3%80%91%E4%B8%BA%E7%9B%AE%E7%9A%84%E7%9A%84%E7%BB%98%E7%94%BB%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/</url>
  </entry>
  <entry>
    <title>从零开始的Android APP开发——心迹日记（InnerTrace-XinJiDiary）</title>
    <content>突发奇想想要开发一款日记APP，用帮助用户多方面观察自己、记录自己、比昨天进步一点点。之前没有接触过Android开发，于是从零开始学起了，本篇为APP：心迹日记（InnerTrace-XinJiDiary）学习路程和开发日记。
WebDemo试用地址：心迹日记Demo
项目地址：心迹日记（[InnerTrace-XinJiDiary]


Day 1–2025.5.26一、项目构思与需求分析
核心理念
目标：通过日记记录帮助用户“记录自己，观察自己，发现自己，认识自己的需求，提升自己”。
核心功能：
动态模板：学习、减肥、心情自愈等场景化记录模板。
数据智能：自动卡路里计算、情绪分析书籍推荐。
数据可视化：生成成长曲线与统计图表。




用户需求
记录日常行为（学习时长、体重变化、情绪波动）。
获得个性化反馈（如连续情绪低落时推荐心理学书籍）。
多维度数据回顾（周&amp;#x2F;月&amp;#x2F;年趋势分析）。


详细功能构思
在众多社交平台发现一件事情：大家各自有各自的烦恼，然而都是有烦恼但不自知，不知道自己为什么有这个烦恼，没有自己观察过自己都因为什么事情而烦恼，进而也没想过去搜一搜查一查改善一下烦恼。
日记其实是个很好的东西，他是自我观察自我进步最简便的方式。
心迹日记这个日记最主要的目的是观察自己从来没观察过的角度，认识每一天的自己，发现自己每一天的变化，提高对自己的认识。
我将准备21天为一个周期的日记模板，例如：观察自己的心情、观察自己的全面发展、学习情况、减肥情况、身体状况、家庭宠物情况等等。
模板初级为21天养成计划，21天后模版会变得不太一样，提供一些开放式栏目，配一些专业书籍，比如，减肥营养学、人际关系心理学。即：根据用户使用模板的频率提供能帮助到用户的书。
hi～你已经写了21天坏情绪日记啦～向你推荐一本书或许会对你有帮助，阅读一下书放松一下吧～




二、技术准备与学习
技术栈确认
语言：Kotlin（Android 官方推荐）。
架构：MVVM + Clean Architecture（分层解耦）。
数据库：Room + SQLite（本地存储）。
网络：Retrofit（未来集成卡路里 API）。
界面：Jetpack Compose（现代声明式 UI）。


学习资源
官方文档（Android Developers、Kotlin 指南）。
开源项目参考（如 SimpleNote、Journey 日记类 App）。




三、项目管理与仓库搭建
GitHub 仓库创建
仓库名：InnerTrace-XinJiDiary
项目地址：心迹日记（InnerTrace-XinJiDiary）
关键文件：
README.md：项目介绍、技术栈、快速开始指南。
CONTRIBUTING.md：贡献规范（分支管理、代码风格）。
LICENSE：GPL3.0 开源协议。




分支策略
main：稳定版本分支（仅通过 Pull Request 合并）。
feat/*：功能开发分支（如 feat/setup-core-module）。




四、项目初始化与结构搭建
模块化架构设计
核心模块：
app：主应用入口（含启动页、导航）。
core：通用组件（主题、工具类、基础 UI）。
feature：功能模块（日记、统计、推荐）。




关键配置完成
Gradle 依赖管理：统一版本号（libs.versions.toml）。
settings.gradle：声明模块依赖关系。
.gitignore：排除 IDE 缓存、构建文件。


首次代码提交
完成 core 模块基础代码（主题、工具类）。
提交并推送至 feat/setup-core-module 分支。



4.1标准模块化 Android 项目结构InnerTrace-XinJiDiary/    # 🌟根目录（项目名）├── app/                  # 🏠主模块（应用入口，必须存在）│   ├── src/              # 主代码目录│   │   ├── main/         # 正式环境代码│   │   │   ├── java/     # Java/Kotlin 代码│   │   │   ├── res/      # 资源文件（布局、图片、字符串等）│   │   │   └── AndroidManifest.xml  # 应用清单文件│   ├── build.gradle      # 🔧模块级配置（依赖、插件）├── core/                 # 📦基础模块（通用工具、主题、组件）│   ├── src/main/         # 结构同 app 模块│   └── build.gradle├── feature/              # 🧩功能模块（按业务拆分，如日记、统计）│   ├── diary/            # 日记功能模块│   │   ├── src/main/│   │   └── build.gradle│   └── statistics/       # 数据统计模块│       ├── src/main/│       └── build.gradle├── gradle/               # 🧰Gradle 包装器（确保构建一致性）│   └── wrapper/│       ├── gradle-wrapper.jar│       └── gradle-wrapper.properties├── build.gradle          # ⚙️项目级配置（全局依赖版本管理）├── settings.gradle       # 🔗模块依赖声明（必须！）├── .gitignore            # 🚫排除无需版本控制的文件├── README.md             # 📖项目说明文档├── LICENSE               # 📜开源协议└── CONTRIBUTING.md       # 👥贡献指南




五、问题解决与优化
Git 操作问题
修复分支跟踪错误（git branch --set-upstream-to）。
解决推送后文件未显示问题（检查 .gitignore 与提交范围）。


项目结构调整
清理冗余目录（.idea、External Libraries）。
规范文件位置（LICENSE、README.md 移至根目录）。




六、下一步开发计划
核心功能实现
完成 feature/diary 模块的模板动态渲染。
集成 Room 数据库（日记数据存储与查询）。


推荐系统开发
实现情绪分析规则引擎（负面情绪占比 &amp;gt;70% 时触发推荐）。


测试与优化
编写单元测试（卡路里计算逻辑、推荐规则）。
优化 UI 动画与交互细节。


发布准备
配置 GitHub Actions 自动化构建。
准备 Google Play 上架材料（应用截图、描述文案）。



Day 2–2025.6.5一、网页版Demo开发试用地址：https://github.com/Morlvoid/XinJiDiary-WebDemo
Day 3–2025.6.11一、网页版Demo部署部署地址：
http://xinjidiary.morlvoid.pro/
</content>
    <url>/2023/05/26/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84Android%20APP%E5%BC%80%E5%8F%91%E2%80%94%E2%80%94%E5%BF%83%E8%BF%B9%E6%97%A5%E8%AE%B0%EF%BC%88InnerTrace-XinJiDiary%EF%BC%89/</url>
  </entry>
  <entry>
    <title>八芒星：荣格八维可视化图表工具--思路日志</title>
    <content>这是一个根据荣格八维衍生设计的可视化八芒星模型。
使用链接：八芒星


理论依据[荣格八维测试](https://www.jungus.cn/test/)
初步设计
意识与无意识的层次（两个圆）：
大圆： 代表整体的心理领域，包含意识（小圆内）和部分靠近意识的无意识（大圆与小圆之间的环带）。
小圆： 代表清晰的意识层面。


功能态度（两个四芒星）：
大四芒星（外倾功能 - e）： 位于小圆之外、大圆之内，象征外倾功能主要活跃在意识与无意识的交界地带，是意识努力去整合和运用的对象（因为它们更适应外部世界）。它们属于意识可触及但可能还未完全熟练掌握或处于发展中的部分。
小四芒星（内倾功能 - i）： 完全位于小圆之内，象征内倾功能是意识的根基和核心。它们更主观、内省，是判断和感知的内在标准，因此被清晰地包含在意识圈内。
黑底白边： 形成鲜明对比，清晰地区分出两组功能。
四芒星造型： 比简单的点或线更能代表功能的“方向性”（感知&amp;#x2F;判断）和“态度”（内倾&amp;#x2F;外倾）。四个角代表四种功能（F&amp;#x2F;T&amp;#x2F;S&amp;#x2F;N），两两相对（如 Ti-Fe, Te-Fi, Si-Ne, Se-Ni）。


个体功能发展（黄色八角星）：
连接八个端点： 完美地对应荣格的八个心理功能。
黄色： 代表个体的独特性、意识的光芒和实际的发展水平。在黑白背景上非常突出。
数值映射（0-40）： 直接使用测试分数，直观显示每个功能的相对强度。端点位置由该功能的分数决定（离中心点的距离按比例计算）。



</content>
    <url>/2022/07/26/%E5%85%AB%E8%8A%92%E6%98%9F%EF%BC%9A%E8%8D%A3%E6%A0%BC%E5%85%AB%E7%BB%B4%E5%8F%AF%E8%A7%86%E5%8C%96%E5%9B%BE%E8%A1%A8%E5%B7%A5%E5%85%B7--%E6%80%9D%E8%B7%AF%E6%97%A5%E5%BF%97/</url>
  </entry>
  <entry>
    <title>以【叙事性线构插图】为目的的绘画知识库-2</title>
    <content>第一部分：以【叙事性线构插图】为目的的绘画知识库-1
第二部分：以【叙事性线构插图】为目的的绘画知识库-2


4.0.2.2色彩叙事练习虽然从钢笔画入门很好，但最终色彩是强大的叙事工具。在黑白灰基础扎实后，要系统学习色彩理论（色相、明度、饱和度、冷暖、对比、调和），理解色彩心理学（不同色彩引发的普遍情绪联想），以及色彩如何建立氛围、象征、区分时空或心理状态。电影美术、经典绘画的色彩运用是极好的学习对象。
4.0.2.3连续性叙事虽然单幅叙事是核心，但有时也需要多幅画面讲述一个序列（如绘本、漫画分格、故事板）。练习如何在单幅内暗示时间流逝&amp;#x2F;前因后果，以及如何设计多幅画面的节奏、连贯性和视觉焦点转移。
“讲故事”的终极练习 - 创作完整作品：

定期给自己设定主题或小故事（原创、改编、命题均可）。
完整走一遍流程：构思故事核心 -&amp;gt; 提炼关键帧（哪一幅最能代表这个故事？）-&amp;gt; 草图探索构图&amp;#x2F;视角&amp;#x2F;角色 -&amp;gt; 深入刻画（线条、明暗&amp;#x2F;色彩）-&amp;gt; 审视是否准确传达叙事意图。
这是检验你所有训练成果的终极方式。

4.0.2.4创作整合输出持续所有输入性练习（速写、摄影、观察、理论学习）。
定期进行完整创作： 构思小故事 -&amp;gt; 提炼关键帧 -&amp;gt; 深入创作（尝试不同媒介，不局限于钢笔）。
刻意运用所学： 在创作中有目的地应用构图、色彩、符号象征、角色表演、镜头语言。
寻求反馈： 分享你的作品和创作思路，向同行或目标观众寻求反馈，看你的叙事意图是否被准确理解。
深入研究特定文化&amp;#x2F;主题： 选择感兴趣的方向深挖其视觉符号和叙事传统。
4.0.2.5“主题系列画” - 世界观构建举例：
“魔法师书房” + 状态&amp;#x2F;历史。
目标： 单幅画面不仅要展现环境，更要通过细节讲述主人的性格、经历、甚至时代的变迁（如废弃书房）。
挑战：
复杂场景与透视： 书房涉及书架、桌椅、门窗等，需扎实的多点透视能力。大量画建筑速写和室内场景速写打基础。
细节叙事： 每一处细节都是线索！

勤恳整洁：书本按颜色&amp;#x2F;大小分类？笔记工整？魔药瓶标签清晰？羽毛笔插在笔座？地面一尘不染？光线明亮有序？
混乱不羁：书本乱堆&amp;#x2F;摊开&amp;#x2F;甚至当杯垫？涂鸦的草稿纸满地？奇怪的实验装置冒烟？吃剩的食物？光线来源复杂（烛台、魔法球、窗外月光混杂）？
废弃遗迹：厚厚的灰尘？破损的书页&amp;#x2F;家具？蛛网？小动物（鸟窝、老鼠洞、藤蔓侵入）？褪色的魔法阵？散落失效的魔法物品？昏暗&amp;#x2F;诡异的光线（一缕夕阳照在灰尘上）？

色彩叙事
色彩方案： 为每种书房设定主色调和辅助色调（整洁：偏冷&amp;#x2F;中性，明亮；混乱：暖色+撞色，光影对比强；废弃：低饱和度灰调，点缀腐朽绿&amp;#x2F;锈迹红）。
色彩象征： 利用色彩心理学（整洁用蓝&amp;#x2F;白显理性；混乱用红&amp;#x2F;黄显活跃&amp;#x2F;危险；废弃用棕&amp;#x2F;灰显衰败）。
光影氛围： 色彩结合光影（整洁的均匀光照，混乱的局部强光与阴影，废弃的微弱光源&amp;#x2F;神秘光）营造截然不同的氛围。
钢笔画精研：
极致细节： 在关键部位（如魔法书的纹路、实验仪器的结构、灰尘的堆积感）进行深入刻画，展现钢笔画的精细表现力。
综合技法： 结合点绘、排线、涂黑、留白等多种技法表现丰富质感（金属、皮革、纸张、木头、灰尘、魔法光效）。
色彩学系统学习与应用
理论： 深入学习色环、对比（色相对比、明度对比、饱和度对比、冷暖对比）、调和（类似色、邻近色、三角色等）、色彩心理学、色彩的文化象征。
色彩小稿： 为每个书房创作先画多个色彩小稿，试验不同配色方案的叙事效果。
局部上色&amp;#x2F;综合媒介： 可在钢笔稿基础上，使用水彩、彩铅、马克笔、数字上色等进行色彩渲染。重点思考色彩如何强化你设定的叙事和氛围。
想象力深化
在“书房”系列中，融入更多你第二阶段训练的“概念具象化”和“属性嫁接”：比如整洁书房里一本会自动整理的书？混乱书房里一个会偷喝魔药的茶杯？废弃书房里一株靠残留魔力发光的蘑菇？
学习重点： 复杂空间透视、细节的叙事性设计、色彩理论与叙事性配色的深度结合、钢笔与色彩的融合技巧、完整世界观的视觉化呈现。
参考内容全网最全绘画优秀书籍推荐（含PDF资源分享）
【Artists’ Master Series Color &amp;amp; Light】
附录附录：动画、美术、动漫相关专业的完整学习科目清单


专业名称

课表



动画专业（含3个方向）
专业基础课（必修）
动画概论    美术基础（素描、速写、色彩）    造型设计    数字图像处理（Photoshop&amp;#x2F;SAI）    视听语言    剧本创作    影视声音艺术    中外动画史



方向核心课（1）动画艺术方向（二维&amp;#x2F;实验动画）
原画设计    动画运动规律    分镜头脚本设计    二维动画创作（Animate&amp;#x2F;TVPaint）    实验动画技法    动画导演    短片创作（必修实践）



方向核心课（2）三维动画与特效方向
三维建模（Maya&amp;#x2F;ZBrush）    角色绑定与动画    动力学与特效（Houdini）    影视合成技术（Nuke）    渲染技术（Arnold&amp;#x2F;Redshift）    虚拟制片流程    三维动画短片创作（必修实践）



方向核心课（3）漫画与插画方向
漫画分镜设计    故事漫画创作    绘本设计    角色与场景设定    数字绘画（Procreate&amp;#x2F;PS）    插画技法（水彩&amp;#x2F;板绘）    漫画IP开发与运营



技术支撑课（必修）
影视剪辑（Premiere&amp;#x2F;DaVinci）    动画制片管理    数字绘画进阶    动画软件专题（如UE5引擎基础）



选修课（示例）
动画表演    实验影像创作    游戏美术设计    AIGC艺术应用    动画音乐音效设计    儿童动画创作







数字媒体艺术专业（网络视频&amp;#x2F;交互方向）
核心科目
数字媒体艺术概论    交互设计原理    动态图形设计（After Effects）    网络视频创作    虚拟现实艺术（Unity&amp;#x2F;Unreal）    网页动效设计（HTML5&amp;#x2F;CSS3）    用户界面设计（Figma）    数据可视化    数字短片导演    新媒体装置艺术



技术课
编程基础（Python&amp;#x2F;C#）    传感器技术    物理交互开发


戏剧影视美术设计专业（影视美术&amp;#x2F;特效方向）
核心科目
影视美术概论    场景设计（手绘+数字）    影视概念设计    特效化妆    影视模型制作    数字绘景（Matte Painting）    影视照明技术    影视服装设计    虚拟场景搭建（Unreal Engine）    影视特效合成（Nuke）    影视制片美术管理



实践课
影视剧组美术实习    毕业大戏美术设计







美术类相关课程（绘画&amp;#x2F;设计基础）
必修基础
素描静物&amp;#x2F;人物    色彩构成    速写与动态捕捉    透视与解剖学    平面构成



进阶选修
油画技法    水墨动画创作    版画制作    雕塑与三维造型    数字艺术拼贴







研究生阶段核心课程（示例）
动画艺术学硕
动画理论前沿    实验动画创作研究    动画产业与政策



数字艺术专硕
跨媒体叙事设计    虚拟人技术应用    沉浸式空间设计    数字艺术策展


附录：动画&amp;#x2F;美术&amp;#x2F;动漫专业科目分类表


分类
科目



1. 理论素养
动画概论中外动画史数字媒体艺术概论影视美术概论动画产业与政策（研） 动画理论前沿（研）


2. 技术基础
美术基础（素描&amp;#x2F;速写&amp;#x2F;色彩）造型设计透视与解剖学动画原理与运动规律动力学与特效（Houdini基础）编程基础（Python&amp;#x2F;C#）传感器技术


3. 视觉语言
视听语言分镜头脚本设计影视概念设计动态图形设计（AE）色彩构成平面构成影视照明技术


4. 专项设计
动画方向：原画设计、角色绑定、三维建模漫画方向：角色设定、故事漫画创作、绘本设计影视美术：场景设计、特效化妆、影视服装设计交互方向：用户界面设计、数据可视化、物理交互开发


5. 工具与媒介
数字图像处理（PS&amp;#x2F;SAI）二维动画软件（Animate&amp;#x2F;TVPaint）三维软件（Maya&amp;#x2F;ZBrush&amp;#x2F;Blender）合成软件（Nuke&amp;#x2F;DaVinci）引擎工具（Unreal&amp;#x2F;Unity）数字绘画工具（Procreate&amp;#x2F;数位板）AIGC工具应用（Midjourney&amp;#x2F;Stable Diffusion）


6. 创作思维
剧本创作动画导演实验动画技法跨媒体叙事设计（研）漫画IP开发新媒体装置艺术短片创作（全流程实践）


7. 行业与商业
动画制片管理影视制片美术管理漫画IP运营虚拟制片流程动画市场分析（选修）数字艺术策展（研）


8. 练习与进阶
基础训练：速写与动态捕捉、数字绘画进阶专项训练：原画临摹、三维角色动画练习项目实战：  动画创作工坊（工作室制）毕业设计（动画短片&amp;#x2F;漫画连载&amp;#x2F;交互作品）影视剧组实习高阶研究：  虚拟人技术应用（研） 沉浸式空间设计（研）


附录：Krenz绘画教室的三门核心课程学习重点透视、构成、色彩。是系统提升绘画基础的专业训练体系，以下基于课程官方内容及学员实践反馈，综合整理各课程的核心学习目标、知识点与训练重点：

一、透视课
核心目标：掌握空间逻辑与物体结构的精准表达，解决“形不准”“透视错误”问题。
核心知识点与训练内容：

透视原理与计算
单点&amp;#x2F;两点&amp;#x2F;三点透视的应用场景区分
俯仰角透视压缩规律（如22.5°、45°、67.5°的收缩比例）
焦距对透视的影响（广角vs望远镜头的收缩差异）
透视网格搭建与“上帝视角”取景法


结构拆解与组合
几何体（方块、圆柱）作为基础单元的组合逻辑
三视图转换技巧（正&amp;#x2F;侧&amp;#x2F;顶视图的空间对应关系）
复杂物件（如家具、机械）的透视拼接（如“N字法”“倍增法”）


实战应用
场景与人物透视融合（如角色与地板的接触点计算）
自由物体（如旋转酒瓶、曲面家具）的透视适配



典型作业：

L1~L7：分阶段练习（室内空间、旋转物件、景深控制）
L8结课作业：原创场景+人物整合，需提交三视图及成稿


二、构成课
核心目标：强化画面叙事力与视觉引导，解决“构图平淡”“重点模糊”问题。
核心知识点与训练内容：

动态与节奏设计
动态线（CSI线条）引导视线路径
剪影形状的负空间平衡（正负形互动）
视觉焦点层级控制（主&amp;#x2F;次元素明度与纯度对比）


构图法则
经典构图模型（三角、黄金螺旋、穆夏式装饰框架）
元素“信息量”规划（繁简区域交替避免杂乱）
抽象几何归纳（将复杂场景简化为点线面组合）


画面情绪表达
动态姿势的张力设计（如“预备动作-爆发动作”序列）
留白与呼吸感的控制



课程特色：

作业量相对较少但需深度思考，侧重分析大师作品构图逻辑
强调“炼金术思维”：参考→拆解→重组→创新


三、色彩课
核心目标：驾驭光影逻辑与色彩情绪，解决“颜色脏”“氛围弱”问题。
核心知识点与训练内容：

科学化色彩系统
环境光影响模型（如天光&amp;#x2F;暖光源的叠加逻辑）
固有色与光照的分离处理（避免颜色“糊掉”）
闭塞（Occlusion）与漫反射的精准刻画


实用技法
渐变映射（Gradient Map）快速统一色调
高饱和色块的视觉平衡技巧（如降明度保纯度）
颗粒质感笔刷营造色彩微妙变化


氛围营造
光影形状设计（如窗影、点光源的戏剧性效果）
情绪色调选择（冷寂vs温暖、压抑vs通透）



学员痛点突破：

暗部色彩丰富性训练（避免灰暗死黑）
从“色稿随意”到“可控色彩规划”的转型

附录：西哥特——绘画技能树【西哥特老师的“烧砖理论”学习顺序：人体透视基础、画面内容设计、全局色调控制、细化渲染提升】
人体透视基础

几何体绘制（线条流畅、型准、透视比例不崩坏）

体块朝向控制力（几何体块多角度）

图形意识（初级）（抽象构成化、归纳）

视觉引导框架线（单体）（简易图形与直线穿插，DPR）

人体体块特征（素体）（迈克尔汉普顿）

多角度人体站姿（建立标准人体转角度）

人物动作转角度（日常）

人物动作（张力：肢体夸张、战斗、运动等）转角度


画面内容设计

主题内容
表演：视角、镜头、构想（导演&amp;#x2F;编剧）
叙事：故事中的某一帧、情节性

找参考能力（对参考进行甄别和判断）

良好画面方案的积累（视觉经验）

视觉引导线（全画面、插图的规划（视觉中、趋势、引导等）

图形意识（高级，图形+透视融合，图形美观优先、个人审美）

造形设计（人物造型、服装武器等）

画面镜头视角（常规）

画面镜头视角（出彩、强镜头）


全局色调控制

纯黑白效果（二分光影、黑白两色）

黑白灰布控（三分调子）

多阶灰度布控（黑白灰+深浅灰、极深、极亮）

结构想象力（支撑画出准确的形状、刻画体积）

形状经验（调子）（色块形状归纳、疏密节奏、造型特征）

明暗交接线（精致）

触控制（笔触技法，通过笔触形状+走势，暗示信息量）

灰彩转化（转化对应明度的色彩）

色彩风格定位（产生自己的审美偏好，多积累）


细化渲染提升

体积塑造

质感渲染（基础）（区分镜面反射、漫反射，区分粗糙-光洁的材质序列、区分金属布料皮革）

质感渲染（逼真）

细节刻画（完成度）（最大限度深入最小细节单位）（素描静物写生等）

丰富小调子（不影响母层级的前提下，深入细节的子层级关系）

细腻的色彩（微妙颜色变化、藏色，微妙小色彩变化配合小调子的素描关系）

技法娴熟度（有限的笔法就能达到效果、利用笔刷的随机性）

内容真实度（给观众的真实感，准确地传递信息）


附录：曼奇立德绘画课程体系曼奇立德绘画课程体系的综合梳理，结合其官方招生简章、学员反馈及课程升级信息，分为基础班、研修班、特色专题课包三大模块，并附核心课程内容与教学特色：

一、基础班课程体系（面向美术功底薄弱者）
核心课程内容

人体结构基础
动态与比例：360°人体透视、动态线捕捉（CSI线条应用）
肌肉与骨骼：解剖学简化逻辑、关节运动规律（如肩胛-手臂联动）
线稿进阶：轮廓信息强化、体积感表现（73老师线稿课重点）1


色彩与光影
商业色彩系统：RGB取色法、渐变映射统一色调
环境光影响：天光&amp;#x2F;暖光源叠加逻辑、闭塞区处理
材质刻画：金属&amp;#x2F;布料&amp;#x2F;皮肤的质感差异化表现


设计入门
元素拆解重组：文化符号提取（如东方纹样×科幻机械）
剪影设计：负空间平衡、视觉焦点层级控制




二、研修班课程体系（需提交原创作品审核）
专项深化方向

角色设计（73老师主讲）
文化叙事设计：从民俗考据到幻想生物转化（如“蒸汽朋克神社巫女”）
日系风格专精：二次元结构简化、动态张力表现


场景概念设计
空间建构：透视网格快速搭建、广角畸变控制1
氛围渲染：光影形状设计（窗影&amp;#x2F;雾霭）、色彩情绪表达


商业项目实战
IP开发流程：角色三视图→宣传插图→周边衍生
3D辅助设计：Blender基础建模辅助透视验证




三、特色专题课包

设计作品集DLC（14周冲刺）


目标：完成职业级作品集
内容：
个人风格定位分析
4-6套完整角色&amp;#x2F;场景设计（含三视图、细节拆解图）
行业简历与作品集排版指导




手办涂装班（12周）


核心模块：
色彩理论：环境色叠加、高饱和色平衡
实操技法：
Q版涂装：平滑渐变控制
正比涂装：肌肤通透感、金属旧化




成果：完成1件Q版+1件正比涂装作品


课程体系对比与选择指南



课程类型
适合人群
课程重点
时长
入学要求



向日葵班
零基础&amp;#x2F;无板绘经验
软件操作+基础素描
4个月
无作品审核


基础班
美术功底一般（应届生）
人体&amp;#x2F;色彩&amp;#x2F;设计入门
6个月
提交临摹作品


研修班
进阶提升&amp;#x2F;求职作品优化
高级设计+项目实战
8个月
原创设计作品集


DLC课包
求职冲刺&amp;#x2F;风格定型
作品集定制
14周
需通过基础班或同等考核



教学特色与学员反馈

“曼奇风”争议：
学生作品风格高度统一（强剪影、高饱和色），需主动突破模仿局限；
讲师个人风格多样（如73老师的日系、曼曼的写实），鼓励多元发展。


高强度训练：
每日12小时学习制（早10点-晚10点），假期仅周日休息；
结课作品完成度可达行业入门标准（参考毕业作品展示）。


资源短板：
基础课人体演示减少，需依赖助教或自学补足；
住宿随机分配（2-8人间），无自主选择权。



附录：个人画师四大生存路径全景表


路径
核心模式
细分赛道
代表案例
年收入区间
风险警示



1. 卖课
知识付费
▶ 技能教学（K大透视课） ▶ 兴趣培训（水彩美食课） ▶ 行业科普（AIGC提示词工程）
徐雅馨（圆珠笔手绘课）
10万-500万
需持续更新课程防过时


2. 进公司
雇佣劳动
▶ 游戏美术（米哈游原画师） ▶ 品牌设计（奥美视觉） ▶ 影视概念（追光动画）
73（前曼奇讲师→游戏主美）
15万-60万
职场内卷&amp;#x2F;35岁危机


3. 接外包
项目制服务
▶ 商插（出版社配图） ▶ 建模（手办原型外包） ▶ 二创（B站动态漫制作）
武汉早点宣传插画师
5万-50万
低价竞争&amp;#x2F;尾款拖欠


4. 个人创业
资产所有权
▶ 原创IP开发（漫画&amp;#x2F;潮玩） ▶ 独立游戏（Steam发售） ▶ 数字资产（NFT&amp;#x2F;平台打赏）
眠狼（《猫丞兔角》IP年入600万）
0-∞（波动极大）
冷启动难&amp;#x2F;盗版猖獗



注：个人创业的本质是 「从出售劳动时间转向积累可复利资产」

附录：市场主流美术岗位的分类及详解
一、按核心职能分类
1. 概念设计（前期创作）

概念原画师（Concept Artist）
方向：角色概念设计 &amp;#x2F; 场景概念设计 &amp;#x2F; 机械设计
核心能力：世界观视觉化、风格探索、氛围图（Key Art）、设计逻辑表达。
工具：Photoshop、Procreate。


分镜师（Storyboard Artist）
职责：镜头叙事设计（影视&amp;#x2F;动画&amp;#x2F;游戏剧情过场）。



2. 2D美术（视觉内容生产）

原画师&amp;#x2F;角色设计师（2D Character Artist）
职责：角色立绘、三视图、服装&amp;#x2F;武器设计。


场景原画师（2D Environment Artist）
职责：场景构图、建筑&amp;#x2F;自然元素设计。


插画师（Illustrator）
区别：侧重宣传级视觉输出（海报、CG），艺术表现力＞设计功能性。


UI美术师（UI Artist）
职责：界面图标、按钮、动态UI、交互视觉设计。需懂UX基础。


2D特效美术（2D VFX Artist）
职责：技能特效、粒子动效（Spine&amp;#x2F;AE实现）。



3. 3D美术（模型与空间构建）

3D角色模型师（3D Character Modeler）
流程：高模雕刻（ZBrush） → 拓扑低模（Maya&amp;#x2F;Max） → UV拆分 → 贴图绘制（Substance Painter）。


3D场景模型师（3D Environment Artist）
专精：建筑&amp;#x2F;植被&amp;#x2F;道具建模、场景拼接、灯光氛围。


3D动作师（Animator）
职责：角色骨骼绑定、动作设计（走跑攻击）、表情动画。


3D特效美术（3D VFX Artist）
工具：Unity&amp;#x2F;Unreal引擎粒子系统、Houdini。



4. 技术美术（TA：技术与艺术桥梁）

技术美术师（Technical Artist）
方向：
工具向TA：开发美术生产工具（Python&amp;#x2F;Mel脚本）、优化工作流。
渲染向TA：定制Shader、优化光影&amp;#x2F;材质表现（需懂图形学）。
管线向TA：搭建引擎美术资源规范。


硬要求：编程能力（Python&amp;#x2F;C#&amp;#x2F;HLSL）+ 美术素养 + 引擎经验。



5. 美术管理与质检

美术总监（Art Director）
职责：整体视觉风格把控、团队管理、跨部门协调。


主美（Lead Artist）
职责：小组技术指导、质量审核（如角色组主美、场景组主美）。


美术外包经理（Outsourcing Manager）
职责：对接外包团队、制定规范、验收资源。




二、按技术栈分类



类别
代表岗位
技能核心



2D方向
原画师&amp;#x2F;UI美术&amp;#x2F;插画师
手绘功底、设计思维、色彩构图


3D方向
模型师&amp;#x2F;动作师&amp;#x2F;场景艺术家
三维软件、拓扑&amp;#x2F;UV、PBR材质


程序化方向
技术美术（TA）&amp;#x2F;特效美术
编程+美术+引擎三栖能力


管理方向
美术总监&amp;#x2F;主美
审美决策力、项目管理、沟通协调



三、按项目阶段分类

预研阶段：概念原画师、艺术总监（定风格基调）。
生产阶段：
前期：原画师（输出设计稿）
中期：3D模型师、动作师（资源量产）
后期：特效美术、TA（引擎集成优化）


维护阶段：UI美术（版本更新）、TA（性能调优）。


附录：角色美术资源类型（图像）总览广泛意义上的：头像，半身像，全身立绘，半身插，全身插，精二立绘等等分类，更准确的名字叫：角色美术资源类型。
具体有以下分类：
基础展示类
头像（Headshot&amp;#x2F;Icon）：角色的头部或上半身特写，常用于UI界面（如状态栏、对话框、玩家头像）。
半身立绘（Bust&amp;#x2F;Upper Body）：展示角色腰部以上的部分，强调服装、表情和手持道具。角色选择界面、剧情对话立绘。
全身立绘（Full-body Art）：完整的角色站立全身图，强调整体造型和比例。
​	标准立绘：静态站姿，用于角色界面。
​	动态立绘：通过live2D等增加简单动作（如飘动发梢、呼吸起伏），增强表现力。
插画（Illustration）：艺术性更强的完整构图，包含角色、背景和叙事元素。半身插画：半身角色+场景，用于宣传图或剧情CG。全身插画：全身角色+复杂背景，如活动主视觉海报。
三视图（Orthographic Views）：角色正面、侧面、背面的标准化线稿，用于3D建模参考。要求比例精准，标注关键尺寸（如肩宽、身高）。

动态表现类
表情差分（Expression Variations）：同一角色不同表情的系列图（如喜、怒、哀、惊）。视觉小说、对话互动中的情绪传达。
动作分解（Action Sheets）：角色关键动作的分帧图，用于动画制作或游戏骨骼绑定。
皮肤&amp;#x2F;换装设计（Skin&amp;#x2F;Costume Design）：同一角色不同服装或造型的版本。

功能类与衍生类
Q版（Chibi Style）：头身比例夸张（如2-3头身）的萌系简化风格。用途来制作周边商品、Loading界面、休闲玩法角色形象。
像素风（Pixel Art）：低分辨率点阵图，复古或独立游戏常用。静态像素：固定动作的像素角色。动态像素：带逐帧动画的行走&amp;#x2F;攻击效果。
UI图标（UI Icons）：角色缩略图或剪影，用于技能栏、队伍编成界面。要求高辨识度，极小尺寸下仍能识别角色特征。

表1：角色美术资源类型与应用总结


资源类型
核心用途
典型应用场景
核心规范要点（简要）



头像
UI标识、快速识别
玩家头像、状态栏、对话框、社交平台
高辨识度（小尺寸）、风格统一、符合UI规范


半身立绘
角色展示（腰部以上）、情感
角色选择界面、剧情对话立绘
强调表情&amp;#x2F;上半身细节、构图稳定


全身立绘 (标准)
角色完整展示、造型
游戏角色详情页、卡牌
比例准确、姿态清晰、背景简洁&amp;#x2F;透明


全身立绘 (动态)
增强表现力、生动感
主界面看板、特殊互动
符合Live2D&amp;#x2F;Spine等工具规范、动作自然不穿帮


半身插画
叙事、氛围营造、宣传
剧情CG、章节封面、中型宣传图
构图完整（含背景）、叙事性强、艺术感突出


全身插画
高强度宣传、视觉冲击
活动主视觉海报、官网Banner、Loading图
高完成度、复杂构图、强视觉中心、符合宣传尺寸


三视图
3D&amp;#x2F;2D制作精准参考
3D建模、骨骼绑定、周边制作
比例绝对精准、线条清晰、标注完整、无透视


表情差分
情绪传达、互动反馈
视觉小说、对话系统、角色互动
表情夸张明确、风格统一、与基础立绘完美匹配


动作分解图
动画制作参考
骨骼动画关键帧、特效触发点
动作清晰连贯、关键帧标注、符合运动规律


皮肤&amp;#x2F;换装设计
商业化、个性化、内容更新
节日活动、角色外观付费内容
主题鲜明、设计新颖、保持角色辨识度、符合设定


Q版形象
萌系表达、周边开发、休闲玩法
周边商品、Loading图、小游戏、表情包
头身比统一、特征夸张化、线条简洁可爱


像素角色 (静态)
复古风格、特定玩法
独立游戏、复古游戏、UI元素
风格统一、低分辨率下辨识度高、色彩限制


像素角色 (动态)
复古风格动态表现
角色移动、攻击动画
帧数合理、动作流畅、循环无缝


UI角色图标
功能标识、快速选择
技能图标、队伍编成、道具栏
极致辨识度（极小尺寸）、轮廓清晰、色彩鲜明


表2：生产端资源通用规范总结


规范类别
核心要求
说明&amp;#x2F;示例



文件格式
统一指定
源文件：PSD（分层合理）；交付文件：PNG（透明背景）、TGA（高质量）、JPG（宣传）


分辨率&amp;#x2F;尺寸
按类型和平台明确要求
头像：256x256； 主视觉插画：1920x1080； 移动端立绘：适配多种屏幕分辨率


色彩模式
统一
sRGB（确保多设备显示一致）


命名规则
清晰、统一、包含关键信息
角色名_资源类型_变体_版本.后缀 (例：Amiya_Headshot_Normal_v01.psd)


图层&amp;#x2F;分组
结构清晰、命名规范
便于修改、协作和自动化处理。如：分开线稿、上色、阴影、高光、背景层。


风格一致性
严格遵循项目美术风格指南
线条风格、上色方式、光影逻辑、比例、设计元素必须统一


设计还原度
100%还原角色设定稿
服装、饰品、发型、瞳色等细节必须准确无误


文件优化
无多余图层&amp;#x2F;通道；资源大小合理
尤其对用于实时运行（游戏）的资源，需控制文件大小


交付结构
清晰目录层级
按角色&amp;#x2F;类型&amp;#x2F;版本等逻辑组织文件夹


审核流程
明确步骤（美术自查、主美审核、策划确认等）
确保质量和符合需求


版本控制
清晰记录修改
使用文件名版本号或版本管理工具


附录：美术专业能力体系分类表


主类
子类
细化能力项
关联领域



1. 理论素养
艺术史论
风格流派演变&amp;#x2F;地域美学特征&amp;#x2F;当代艺术思潮
所有创作领域基础



视觉符号学
文化原型解码&amp;#x2F;符号修辞策略&amp;#x2F;隐喻系统构建
品牌设计&amp;#x2F;叙事美术



色彩科学
色度学原理&amp;#x2F;环境光影响模型&amp;#x2F;跨文化心理响应
影视调色&amp;#x2F;UI系统


2. 技术基础
造型能力
结构素描&amp;#x2F;动态解剖&amp;#x2F;机械原理拆解
角色设计&amp;#x2F;工业设计



空间系统
多灭点透视&amp;#x2F;轴测投影&amp;#x2F;场景深度层级控制
场景设计&amp;#x2F;分镜绘制



材质表现
PBR材质理论（金属度&amp;#x2F;粗糙度）&amp;#x2F; 次表面散射算法
3D渲染&amp;#x2F;写实绘画


3. 视觉语言
构图工程
视觉动线规划&amp;#x2F;格式塔原理应用&amp;#x2F;信息密度平衡
电影构图&amp;#x2F;海报设计



动态设计
运动曲线编辑&amp;#x2F;预备动作-缓冲原理&amp;#x2F;形变控制器应用
动画&amp;#x2F;特效设计



光影叙事
情绪化布光&amp;#x2F;全局照明模拟&amp;#x2F;实时阴影优化
影视美术&amp;#x2F;游戏场景


4. 专项设计
角色系统
生物解剖重构&amp;#x2F;服装史考据&amp;#x2F;职业特征符号化
游戏原画&amp;#x2F;手办设计



场景设计
环境叙事逻辑&amp;#x2F;可玩性空间构建&amp;#x2F;程序化生成技术
开放世界游戏&amp;#x2F;影视绘景



产品设计
人机工程学&amp;#x2F;CMF设计（色彩&amp;#x2F;材料&amp;#x2F;工艺）&amp;#x2F;可生产性评估
周边开发&amp;#x2F;载具设计



UI&amp;#x2F;UX设计
费茨定律应用&amp;#x2F;眼动追踪优化&amp;#x2F;多端适配规范
游戏界面&amp;#x2F;AR交互系统


5. 工具与媒介
数字创作
- 2D：PS图层管理&amp;#x2F;矢量工具链（AI）&amp;#x2F;笔刷引擎开发 - 3D：ZBrush雕刻&amp;#x2F;Maya拓扑&amp;#x2F;Blender渲染
数字绘画&amp;#x2F;模型生产



工程制图
第三角投影法&amp;#x2F;GD&amp;amp;T公差标准&amp;#x2F;爆炸视图生成
机械设定&amp;#x2F;产品结构设计



渲染技术
光线追踪算法&amp;#x2F;实时渲染管线（URP&amp;#x2F;HDRP）&amp;#x2F;离线渲染器（V-Ray&amp;#x2F;Arnold）
电影级输出&amp;#x2F;引擎可视化


6. 创作思维
世界观架构
地理生态链设计&amp;#x2F;社会规则可视化&amp;#x2F;技术树推导
游戏策划&amp;#x2F;概念艺术



跨学科创新
科学可视化（生物&amp;#x2F;天文）&amp;#x2F;数据艺术转化&amp;#x2F;历史考据应用
实验艺术&amp;#x2F;教育产品设计



情感工程
微表情心理学&amp;#x2F;色彩情绪矩阵&amp;#x2F;沉浸感触发机制
叙事游戏&amp;#x2F;动画电影


7. 行业应用
游戏美术
角色原画&amp;#x2F;场景地编&amp;#x2F;UI动效&amp;#x2F;技术美术（TA）管线
手游&amp;#x2F;主机游戏开发



影视美术
数字绘景&amp;#x2F;Matte Painting&amp;#x2F;镜头光影规划
电影&amp;#x2F;剧集制作



周边开发
可动结构设计&amp;#x2F;涂装分件规划&amp;#x2F;工厂量产规范
手办&amp;#x2F;潮玩产品线



版权管理
著作权登记&amp;#x2F;跨境IP授权协议&amp;#x2F;衍生品权益分割
商业合作&amp;#x2F;自由职业


8. 能力进阶
流程优化
AIGC辅助设计（ControlNet参数调节）&amp;#x2F;自动化脚本开发（Python for Maya）
生产效率提升



技术融合
实时交互美术（Unity Shader编程）&amp;#x2F;XR空间设计（VR&amp;#x2F;AR内容规范）
元宇宙应用&amp;#x2F;沉浸式展览



风格战略
市场趋势分析&amp;#x2F;个人风格辨识度构建&amp;#x2F;跨媒介风格迁移
艺术总监&amp;#x2F;独立开发者


附录：绘画专业能力体系等级总览表


知识域
核心模块
技术&amp;#x2F;理论要点
能力等级
关联领域



造型基础
结构素描
几何体概括&amp;#x2F;负空间分析&amp;#x2F;复杂形体解构
核心能力 (C1)
角色设计&amp;#x2F;工业设计



透视系统
线性透视(1-5点)&amp;#x2F;曲线透视&amp;#x2F;轴测投影
核心能力 (C1)
场景设计&amp;#x2F;分镜绘制



解剖学应用
人体骨骼肌肉动力学&amp;#x2F;动物解剖学&amp;#x2F;机械结构原理
核心能力 (C1)
生物设计&amp;#x2F;医疗插画


视觉表现
光影理论
直射光与全局照明&amp;#x2F;材质光学属性(反射率&amp;#x2F;折射率)&amp;#x2F;次表面散射(SSS)
核心能力 (C1)
写实绘画&amp;#x2F;3D渲染



色彩科学
色立体模型&amp;#x2F;色彩管理(ICC)&amp;#x2F;环境光影响&amp;#x2F;心理色调响应
专业能力 (P1)
影视调色&amp;#x2F;UI设计



构图方法论
视觉引导线&amp;#x2F;格式塔原理&amp;#x2F;动态平衡系统
专业能力 (P1)
电影构图&amp;#x2F;平面设计


数字创作技术
2D数字绘画
图层合成模式&amp;#x2F;矢量控制&amp;#x2F;笔刷引擎参数化
核心能力 (C1)
数字插画&amp;#x2F;贴图绘制



3D建模与渲染
高精度雕刻&amp;#x2F;拓扑优化&amp;#x2F;PBR材质通道制作&amp;#x2F;光线追踪算法
专业技术 (P2)
游戏资产&amp;#x2F;产品可视化



程序化生成
Houdini VEX脚本&amp;#x2F;Substance Designer节点编辑
专业技术 (P2)
特效开发&amp;#x2F;大型场景生成


动态媒体
二维动画
关键帧动画&amp;#x2F;变形控制器(如Spine)&amp;#x2F;运动曲线编辑
拓展能力 (E1)
MG动画&amp;#x2F;游戏UI动效



三维动画
骨骼绑定系统&amp;#x2F;动作捕捉数据处理&amp;#x2F;摄像机轨迹规划
专业技术 (P2)
影视动画&amp;#x2F;过场镜头



实时交互动画
Live2D形变网格&amp;#x2F;Unity动画状态机
拓展能力 (E1)
虚拟偶像&amp;#x2F;动态立绘


设计理论
视觉叙事
符号隐喻设计&amp;#x2F;空间叙事逻辑&amp;#x2F;时间轴信息呈现
专业能力 (P1)
概念艺术&amp;#x2F;漫画叙事



用户体验设计
费茨定律应用&amp;#x2F;眼动追踪研究&amp;#x2F;交互热区规划
拓展能力 (E1)
游戏UI&amp;#x2F;AR界面设计


跨学科整合
影像技术
摄影光学原理&amp;#x2F;电影级调色流程(DaVinci Resolve)&amp;#x2F;色键抠像技术
拓展能力 (E1)
参考素材采集&amp;#x2F;数字绘景



工程制图
第三角投影法&amp;#x2F;GD&amp;amp;T公差标准&amp;#x2F;爆炸视图制作
拓展能力 (E1)
载具设计&amp;#x2F;机械设定


理论体系
视觉符号学
能指与所指关系&amp;#x2F;文化原型分析&amp;#x2F;符号修辞策略
理论基础 (T1)
品牌设计&amp;#x2F;主题创作



色彩心理学
情感唤起机制&amp;#x2F;跨文化色彩语义&amp;#x2F;商业场景应用模型
理论基础 (T1)
营销设计&amp;#x2F;环境空间


生产管理
技术美术(TA)
着色器编程(HLSL&amp;#x2F;GLSL)&amp;#x2F;美术管线优化&amp;#x2F;DCC工具链整合
专业技术 (P2)
引擎美术开发



版权管理
著作权登记流程&amp;#x2F;CC协议应用&amp;#x2F;跨国侵权追溯
行业知识 (I1)
自由职业&amp;#x2F;外包协作



生成式AI协作
潜在扩散模型控制&amp;#x2F;ControlNet参数调节&amp;#x2F;训练数据集合规
新兴技术 (ET1)
概念探索&amp;#x2F;效率工具



能力等级说明



等级代码
定义
掌握要求



C1
核心能力 (Core)
所有视觉创作领域必备基础


P1
专业能力 (Professional)
细分领域深度应用技能（如角色设计&amp;#x2F;场景美术）


P2
专业技术 (Technical)
需系统培训的硬技能（ZBrush雕刻&amp;#x2F;TA开发）


E1
拓展能力 (Extension)
增强主领域竞争力的辅助技能


T1
理论基础 (Theory)
指导创作实践的知识体系


I1
行业知识 (Industry)
商业环境必备认知


ET1
新兴技术 (Emerging Tech)
产业变革期需关注的工具链



### 附录：设计原创角色的步骤


设计一个动漫角色是融合艺术、叙事与技术的过程，涉及多门专业课的核心知识点。以下从角色定位、视觉设计、叙事构建、技术实现及产业应用五个维度，系统梳理所需知识体系：

 一、角色定位与叙事功能

角色类型与功能

主角&amp;#x2F;配角&amp;#x2F;反派定位：主角需具备成长弧光（如《火影忍者》鸣人从吊车尾到英雄）；配角承担辅助叙事或喜剧调剂功能（如《海贼王》乔巴强化团队温情）；反派需动机合理（如《蝙蝠侠》小丑的混沌哲学）。

角色功能表：



类型
核心功能
设计重点



主角
承载主题，驱动剧情发展
成长性、情感共鸣点


反派
制造冲突，凸显主角价值观
动机深度、视觉压迫感


喜剧角色
调节叙事节奏
夸张动作、反差萌设计





叙事逻辑适配

媒介差异：影院角色需强视觉奇观（如《千与千寻》无脸男的沉默神秘）；TV动画角色依赖符号化特征（如《蜡笔小新》粗眉毛强化辨识度）。
风格统一：角色造型需与作品基调一致（治愈系避免狰狞造型）。




 二、视觉造型设计原理

造型基础要素
夸张与变形：放大特征强化识别度（《猫和老鼠》汤姆腰部拉伸表达惊慌）。
纯化（简化）：用最少线条传递信息（米老鼠三圆构成头部）。
动态表现：关节设计决定动作张力（日漫角色多用“关节点”实现战斗姿势）。


视觉符号系统
色彩心理学：红色&amp;#x3D;热情&amp;#x2F;危险（《进击的巨人》兵团披风）；蓝色&amp;#x3D;冷静&amp;#x2F;忧郁（《冰雪奇缘》艾莎礼服）69。
服装与道具：反映时代与文化（《鬼灭之刃》和服纹样暗示角色流派）。
比例与对比：角色群像需高矮胖瘦差异化（《超人总动员》家族体型凸显个性）。


标准化设计文档
三视图（转面图）：正面&amp;#x2F;侧面&amp;#x2F;背面确保建模一致性1。
表情库：基础四情（喜怒哀乐）+细分变体（冷笑、狂喜）。
关键动态图：标志性POSE强化性格（蜘蛛侠蹲伏姿势的敏捷感）。




 三、性格与背景故事构建

性格塑造层次
外在行为：台词与动作体现性格（《疯狂动物城》尼克玩世不恭的挑眉）。
内在矛盾：缺陷引发共情（《心灵奇旅》22号厌恶投胎的虚无感）。
潜史（Backstory）：过去创伤驱动行为（《蝙蝠侠》小丑起源的多版本暗示）。


背景故事设计
社会关系网：亲友&amp;#x2F;敌对关系构成戏剧张力（《哈利·波特》斯内普的双面身份）。
文化身份：民族元素融合现代审美（《海洋奇缘》莫阿娜的波利尼西亚纹身）。




 四、技术实现流程

2D角色制作
原画设计：关键帧绘制强调运动轨迹。
色指定：赛璐璐或数字上色分层管理。


3D角色管线
建模：低模高模选择（游戏用低模保性能，电影用高模求精）。
UV拆分与贴图：Substance Painter绘制材质（皮革&amp;#x2F;金属质感参数调整）。
绑定与动画：骨骼系统驱动表情（Blend Shape控制口型同步）。




 五、产业应用与衍生开发

IP化设计思维
衍生适配性：造型需简化便于商品化（LINE FRIENDS无四肢设计降低成本）。
跨媒介叙事：预留角色扩展空间（《英雄联盟》角色背景故事支撑游戏+动画）。


数据驱动设计
受众测试：A&amp;#x2F;B方案验证市场偏好（迪士尼Focus Group筛选角色设计）。
潮流融合：结合Z世代审美（《赛博朋克2077》角色义体设计迎合科幻风）。




 核心能力整合模型
设计一个成功角色需掌握以下交叉知识：

艺术基础：人体结构&amp;#x2F;色彩理论&amp;#x2F;动态素描；
叙事能力：剧本分析&amp;#x2F;角色弧光构建；
软件技能：Photoshop（2D）、Maya&amp;#x2F;ZBrush（3D）；
产业认知：版权管理&amp;#x2F;衍生品开发逻辑。

联系方式：QQ1523467770
</content>
    <url>/2025/03/20/%E4%BB%A5%E3%80%90%E5%8F%99%E4%BA%8B%E6%80%A7%E7%BA%BF%E6%9E%84%E6%8F%92%E5%9B%BE%E3%80%91%E4%B8%BA%E7%9B%AE%E7%9A%84%E7%9A%84%E7%BB%98%E7%94%BB%E7%9F%A5%E8%AF%86%E5%BA%93-2/</url>
  </entry>
  <entry>
    <title>前端技术总结</title>
    <content>前端技术查询


📍 一、 核心前端基础 (必学，几乎所有公司都要求)
HTML (HyperText Markup Language):
作用: 网页内容的骨架和语义结构。
要求: 精通语义化标签、常用元素、表单等。div 只是其中一个布局元素。


CSS (Cascading Style Sheets):
作用: 控制网页的样式、布局和外观。
要求: 精通盒模型、选择器、定位、布局技术（特别是 Flexbox 和 Grid）、响应式设计（媒体查询）。flex 是 Flexbox 布局的一部分。Sass&amp;#x2F;Less 是 CSS 预处理器（提升效率，必学其一，Sass 更主流）。Bootstrap&amp;#x2F;Tailwind 是 CSS 框架（非常常用，了解或掌握其一，Tailwind 增长快）。


JavaScript (ECMAScript):
作用: 实现网页的交互逻辑、动态内容、数据处理。
要求: 精通核心语法、DOM&amp;#x2F;BOM 操作、事件处理、异步编程（Promise, async/await）、ES6+ 新特性（箭头函数、解构、模块化等）、基础数据结构与算法。


浏览器工作原理与 API:
作用: 理解页面如何加载、渲染、执行；利用浏览器提供的能力。
要求: 了解关键渲染路径、事件循环。熟悉常用 Web API：Fetch API (替代老旧的 XMLHttpRequest&amp;#x2F;Ajax)、JSON 处理、本地存储 (localStorage, sessionStorage)。



📍 二、 核心前端框架&amp;#x2F;库 (必学，主流公司要求掌握至少一个)
React:
作用: 主流 UI 库，用于构建组件化、高效的单页应用 (SPA)。生态极其庞大。
相关: React Router (路由), Redux&amp;#x2F;MobX&amp;#x2F;Context API (状态管理，虽未列出但几乎必学), Axios (HTTP 客户端库，常用), Ant Design&amp;#x2F;Material UI (UI 组件库，非常常用)。Umi&amp;#x2F;DVA 是国内基于 React 的特定框架&amp;#x2F;方案。


Vue:
作用: 另一个极其流行的渐进式 UI 框架，易学易用，生态丰富。
相关: Vue Router (路由), Vuex&amp;#x2F;Pinia (状态管理), Axios, Element UI&amp;#x2F;Element Plus&amp;#x2F;Ant Design Vue (UI 组件库，非常常用)。uni-app 是基于 Vue 的跨端框架。


Angular:
作用: 一个更重量级、全功能的 SPA 框架，由 Google 维护，在企业级应用常见。
相关: Angular Router, RxJS (响应式编程库，核心), Angular Material (UI 组件库)。AngularJS (v1.x) 已过时，除非维护老项目否则不必学。


TypeScript:
作用: JavaScript 的超集，添加了静态类型系统。在现代前端开发中，已成为事实上的必备技能或强烈推荐技能。
要求: 越来越多的公司，尤其是使用 React 和 Angular 的公司，要求或强烈推荐使用 TS。它能显著提高代码质量和可维护性。



📍 三、 前端工程化 (非常重要，大中型公司普遍要求)
包管理:
npm (或 yarn, pnpm): 管理项目依赖的基石，必学。


版本控制:
Git: 绝对必备！ 代码管理、协作的基础工具。需要熟练掌握常用命令和工作流 (如 Git Flow)。


构建工具:
Webpack: 目前最主流、最强大的模块打包器和构建工具。理解其核心概念 (入口、出口、loader、plugin) 非常重要。
Vite: 新一代构建工具，基于原生 ES 模块，开发速度极快，越来越流行。是 Webpack 的有力竞争者&amp;#x2F;补充。
Rollup: 常用于库&amp;#x2F;组件打包，输出更精简。
Gulp: 基于流的任务运行器，用于自动化任务 (如压缩、编译、拷贝)。虽被 Webpack&amp;#x2F;Vite 部分取代，但仍常见于老项目或特定任务。RequireJS 是较老旧的模块加载器，现代项目基本不用。


脚手架&amp;#x2F;框架集成:
Create React App (CRA), Vue CLI, Vite 本身的脚手架等：快速初始化项目结构的工具，必会使用。



📍 四、 特定领域&amp;#x2F;加分项 (根据公司和项目需求)
移动端&amp;#x2F;跨端开发:
React Native, Flutter (未列出但重要), uni-app, ionic, NativeScript 等：用于开发原生或接近原生体验的移动应用。Cordova&amp;#x2F;WebView&amp;#x2F;HybridApp 是较老的 WebView 套壳方案。
Android&amp;#x2F;IOS 原生知识：对跨端开发理解底层有帮助，但纯前端岗通常不要求精通。
HBuilder 是 uni-app 的官方 IDE。


Node.js 与全栈&amp;#x2F;后端基础:
Node.js: 让 JavaScript 运行在服务端。对现代前端至关重要！ 即使不做后端，也需要用它来运行构建工具、开发服务器、编写脚本、理解 BFF (Backend For Frontend)。
相关框架&amp;#x2F;库:
Express&amp;#x2F;Koa: 轻量级 Node.js Web 框架 (必学基础)。
NestJS: 更现代化、架构清晰的 Node.js 框架 (TypeScript 友好，企业级流行)。
Next.js (React), Nuxt.js (Vue): 服务端渲染 (SSR) &amp;#x2F; 静态站点生成 (SSG) 框架 (提升 SEO 和首屏速度，非常重要！SSR 就是其关键能力)。


后端语言 (Java, C#, Go, Python, PHP, Ruby): 纯前端岗位通常不要求精通！ 但了解一门（尤其是项目后端用的语言）有助于联调、理解接口、向全栈发展。Spring Boot, Spring Cloud, MyBatis, Django, Flask 都是后端框架，前端无需掌握。
C, C++, VC, Delphi: 与前端开发基本无关，除非涉及非常底层的浏览器引擎开发或特定桌面应用集成（如 Electron 底层），否则可以忽略。


数据可视化:
ECharts, AntV (G2, G6, X6): 强大的图表库。GIS 地图相关。


UI 框架&amp;#x2F;组件库:
除了框架配套的 (Ant Design, Element, Material UI)，还有 layUI, mUI, Bootstrap (前面提过) 等。掌握 1-2 个主流即可，原理相通。


状态管理:
如 Redux (React), Vuex&amp;#x2F;Pinia (Vue), MobX。复杂应用必备。


CSS 方法论&amp;#x2F;架构:
BEM, CSS Modules, CSS-in-JS 等，用于管理大型项目的 CSS。


测试:
Jest, React Testing Library, Vue Test Utils, Cypress, Puppeteer 等 (单元测试、组件测试、E2E 测试)。越来越被重视。


性能优化:
前端核心架构设计、性能优化: 这是高级&amp;#x2F;资深前端工程师的核心能力要求。包括加载性能、渲染性能、代码分割、缓存策略、监控等。需要深入理解浏览器、网络、框架本身。


运维&amp;#x2F;基础设施基础 (DevOps Lite):
Docker: 容器化部署，越来越普及，掌握基础概念和使用很有帮助。
Linux 基础命令: 服务器环境大多是 Linux，掌握基础命令是必要的。
Nginx: 常用 Web 服务器&amp;#x2F;反向代理，前端需要了解基本配置（如静态资源服务、反向代理 API、负载均衡）。
CI/CD: 持续集成&amp;#x2F;持续部署概念和实践 (如 Jenkins, GitLab CI, GitHub Actions)。了解流程很有价值。
DevOps: 理念，前端也需要参与其中。
CDN: 内容分发网络原理，前端部署需要考虑。


数据库基础:
MySQL, MongoDB 等：纯前端不要求会写复杂 SQL 或 NoSQL 查询！ 但需要理解基本概念（表、文档、CRUD）、知道如何通过 API 与后端交互操作数据。


老技术&amp;#x2F;特定技术:
jQuery: 曾经是霸主，现在新项目很少用，但维护老项目可能需要了解。
zepto: 类似 jQuery，更轻量，用于移动端，现在也较少。
Gulp (前面提过), RequireJS (前面提过)。
LayUI, mUI: 特定 UI 框架。
OTT: 过顶内容，与前端技术本身关系不大，可能指特定业务场景。
GUI agent, AI agent: 概念宽泛，非前端通用技术，可能指特定应用场景（如自动化测试工具、集成AI功能）。



📍 五、 软技能与附加要求
计算机&amp;#x2F;软件工程专业: 很多公司要求，但不是绝对门槛（优秀自学&amp;#x2F;培训班出身也有机会），扎实的基础知识更重要。
技术博客&amp;#x2F;开源项目贡献: 是重要的加分项！ 体现技术热情、学习能力、沟通能力和技术影响力。不是硬性要求，但能显著提升竞争力。
沟通协作能力: 与设计师、后端、产品、测试协作必备。
学习能力: 前端技术日新月异，持续学习是必须的。
解决问题能力: 核心能力。

📍技术查询渠道PC端网站
掘金社区
CSDN社区
博客园
菜鸟教程
张鑫旭的个人空间(CSS完美世界作者)
阮一峰的个人主页(ES6标准入门作者)
Stack Overflow(国外技术社区)
GItHub
鸠摩搜书
BiliBili
LeetCode(算法)

手机APP
掘金社区
简书
CSDN
微信读书

公众号类
前端大学
前端之巅
程序人生

推荐书籍
JavaScript高级程序设计4(红宝书)
JavaScript权威指南(犀牛书)
JavaScript-DOM编程艺术
ES6教程入门
深入浅出Vuejs
Vuejs实战
图解HTTP
图解TCP&amp;#x2F;IP
深入浅出Node.js
我的第一本算法书
算法4

</content>
    <url>/2021/04/20/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/</url>
  </entry>
  <entry>
    <title>写给自己的启蒙书</title>
    <content>一本写给自己的启蒙书——又名《》……还没有想好。
目前还是学习笔记，涵盖从数学、英语、物理为基础到计算机组成原理、数据结构等等内容的、从零开始学起的启蒙笔记。这么说可能有点奇怪，真的要从1+1&amp;#x3D;2和电池有正极和负极写到人工智能算法吗？或许会这样写的。日后有机会将这本笔记整理成书。


前言总有内行人说：“《计算机组成原理》很深奥，理解了它才算学会计算机。”也总有外行人发言：“学计算机写代码很简单的，本质上整个计算机还是0和1组成的。”
不管他们怎么说，我都不认为他们提议的起点适合入门者。我的推荐是，在入门计算机之前，先理解这个等式：
最简电路 + 点划间隔编码 &amp;#x3D; 人类首个工程化的远距离通信系统
虽然由于电线的电阻，它能传递的距离还是较短，但这个问题后面会有解决方式：后来发明了继电器，通过继电器中继站自动重建电流，信号可横跨大陆海洋。
最简电路：具有用电器（通常为灯泡或电磁铁音响&amp;#x2F;蜂鸣器），电源，开关，导线四个东西且能够形成断路（关）和通路（开）的最简单电路。
物理构成：电源 + 开关 + 导线 + 用电器（灯泡&amp;#x2F;电磁铁音响）- 核心状态： - 通路（开 → 用电器工作） - 断路（关 → 用电器停止）这样的开&amp;#x2F;关状态可抽象表示为1和0。
点划间隔编码：通过操控开和关能够实现点、划、间隔三种状态，并将三种状态排列组合成人类可解读的文字的最简单的传递信息的方式。
点线空编码操控开关生成三种基本信号： - 点（▄▄ ▄▄） → 短通电 - 划（▄▄▄▄▄▄ ） → 长通电 - 间隔（  ） → 断电间隔- 信息传递：将信号按预定义规则（如莫尔斯码）组合成字符&amp;#x2F;单词 
这样最原始的组成才是计算机的本质：数十亿甚至上百亿个开关电路按编码规则协同工作。计算机不是魔法，它始于一个开关和一盏灯：一段从物理世界到数字智能的启蒙之旅。另外，如果真的要从计算机组成原理开始学起，还是先看《编码:隐匿在计算机软硬件背后的语言》这本书。
前言写到这里。这本书我要从1+1&amp;#x3D;2写到人工智能算法。从点亮灯泡、发送莫尔斯码开始，一步步探索开关如何组合成逻辑门（与&amp;#x2F;或&amp;#x2F;非），逻辑门如何构建加法器、存储器，处理器如何执行指令，软件如何被编写，最终理解复杂的算法和人工智能如何建立在这些最基础的‘开关’和‘规则’之上。后面我要开始写基础了——电学基础、数学基础、以及英语。
为什么？因为：电学是计算机的基础。数学是编程和算法的基础。英语是学好计算机的基础。
这趟从电流到智能的旅程，现在就从你眼前的这个简单等式开始。
第一章：电学1.1 电学1.1.1 电1.1.2 基础电路1.1.3 电流与电压</content>
    <url>/2021/06/03/%E5%86%99%E7%BB%99%E8%87%AA%E5%B7%B1%E7%9A%84%E5%90%AF%E8%92%99%E4%B9%A6/</url>
  </entry>
  <entry>
    <title>博客介绍</title>
    <content>你好！欢迎来看我的个人博客！我的网络通用名：Morlvoid（馒头白面）可以叫我馍馍~
想成为UI&amp;#x2F;UX程序交互设计师的菜菜程序员，画画、ACG是爱好，梦想是出书！ ( ^▽^ )  希望一直以学生的心态学习世界上所有有趣的东西！地球Online，Game Start！
本站更新内容较为杂乱，可以分类查看：技术相关、绘画相关、ACG、个人原创、随笔
学习日志
2018年10月~2019年6月，初学C++，C、数据结构。
2021年2月~2021年12月，学习Web开发，Vue，Node.js，Git，UI设计。
2022年2月~2023年9月，学习Java后端开发，Spring，Linux，MySQL。
2023年12月~2025年12月，入职中国移动私有承包商公司，工作内容：大数据管理分析、机房运维。主要应用：Python大数据处理，Python脚本与办公软件office协同工作。
2024年2月~2025年6月，自学动漫相关专业，blender，参与UI设计和制作、美工设计等相关兼职。
2024年8月~2026年4月，在KK魔法学院学画画中……构成√色彩√虚拟形象设计√  原创虚拟IP主题站 
2025年6月~今，学习UI与UX与代码结合的高交互性网站设计开发，制作作品集中计划考研。
项目介绍页   绘画作品页 

</content>
    <url>/2099/01/15/%E5%8D%9A%E5%AE%A2%E4%BB%8B%E7%BB%8D/</url>
  </entry>
  <entry>
    <title>前端网站项目——满记甜品开发日志</title>
    <content>前端网站项目——满记甜品开发日志  2022.6.22目录：
前端功能需求→后端功能需求→数据库设计→UI设计→前端实现→后端实现→项目部署


甲方需求简述用户通过手机号进行登录和注册功能。
用户通过模糊查询、动态查询、热度排行榜等方法挑选甜品类型和口味，并选择几款甜品加入购物车，确认订单后填入收货信息和收货地址并付费购买甜品等功能。
用户登录后可收藏喜欢的甜品，可查看订单进度，可修改个人昵称和手机号、地址，可对商品、商家、骑手进行评价。
管理员通过手机号进行登录管理商品功能。管理员可上架下架甜品，查看用户订单，管理用户订单状态等。
用户注册、登录功能：（设置在首页）
1.1 用户手机号登录、注册：用户输入手机号或平台账号，系统检查该手机号或账号是否已经注册，如果未注册，用户可以进行注册，如果已经注册，系统会提示用户直接进行登录操作。

打开“首页”界面
点击“登录”或“注册”按钮，进入登录&amp;#x2F;注册页面
在登录&amp;#x2F;注册页面中，选择“手机号登录选项，进入相应页面
对于“手机号登录”，用户需要输入手机号码，然后点击“获取验证码”按钮，系统会发送验证码到该手机号，用户填写收到的短信验证码并确认登录
对于“注册”，用户需要填写手机号码或账号，设置密码，填写个人信息，如昵称、性别、地区等
在填写完毕后，点击“提交注册”按钮，系统会验证该手机号码或账号是否已经存在，如果已经存在，系统会提示用户直接进行登录操作
如果该手机号或账号未被注册，系统会将用户的信息进行存储，并提示注册成功
用户完成登录后，可以进行操作：如浏览商品详情页、添加购物车、提交订单、提交收货地址、修改收货地址、查看订单状态等。

（手机号验证API：）
（https://www.tianyandata.cn/）
1.2 管理员登陆：管理员账号是需要单独的数据库存放的，管理员登录时需要输入管理员账户密码进行验证。

打开“首页”登录界面
管理员需要输入管理员用户名和密码进行验证
系统会检测管理员提交的用户名和密码是否匹配数据库中的记录，如果匹配成功，系统会将管理员重定向到后台管理页面
后台管理页面通常包括商品管理、用户管理、订单管理、数据统计、网站配置等模块
管理员可以根据自己的权限管理不同的系统功能，进行相应的操作

注意事项:

管理员账户的密码需要设置为足够安全的复杂度，建议采用字母、数字和特殊字符混合的方式，长度不少于8位。
管理员密码需要定期进行更改，以确保账户的安全性。
管理员登录后需要注意保护账户的安全性，不要将账户信息泄露给他人。
系统必须对管理员的操作进行权限控制，防止管理员滥用权限造成损失。
系统需要记录管理员的操作日志，以便于追溯和审计管理员在系统内的操作。

用户访问商品界面，根据商品分类访问：（登录后可用）
2.1 查询功能：系统需要提供对商品的模糊查询和动态查询功能，用户可以根据类型、口味、商品热度排行榜、季节店铺榜等方面来查询商品。

打开“产品推介”主界面
点击查询按钮或进入查询页面
选择商品分类方式，如按类型、口味、是否有货、商品热度排行榜、季节店铺榜等
可以输入关键词进行模糊查询
可以选择不同的已有的标签进行动态查询
可以选择热度排行榜
可以选择季节单品榜
模糊查询通过点击“搜索”或“确定”按钮，系统会显示查询结果
动态查询通过美点击一个标签，系统会显示查询结果
用户可以浏览查询到的商品，选择心仪商品进行购买或点赞

用户购物车功能：（登录后可用）
3.1 添加商品：用户在商品详情页上选择商品数量并通过添加至购物车功能添加商品，如果已经添加过，按钮会显示为加减按钮。

用户通过进入“产品推介”页面
用户需要自己选择喜欢的商品
用户需要点击“添加至购物车”按钮，将商品添加至购物车中
如果用户已经将该商品添加至购物车，购物车按钮会显示为“已添加”，用户可以直接修改商品数量，或者继续浏览其他商品
如果用户已经登录，系统会将商品信息添加至用户的购物车中，并提示“成功添加至购物车”
用户可以在购物车页面查看和修改购物车中的商品信息以及总价
用户可以选择继续浏览商城网站或进行结算购买

注意事项：

商品详情页面需要清晰显示商品的图片、名称、价格、规格等信息，方便用户进行选择
用户在添加商品时，需要注意选择喜欢自己的类型、口味、是否加冰、是否加糖，以避免后续退换货的问题

3.2 提交订单前选择送货地址：用户在提交订单时需要选择送货地址，系统需要提供多地址的功能（即为：数据库中储存用户信息的表中提供多个（5个左右）的地址信息列）地址中需要有姓名、电话和地址。

用户在购物流程中提交订单前，需选择一个送货地址，如在购物车页面中点击“结算”按钮后进入结算页面，选择“收货地址”等选项时需要填写或选择相关信息。
用户需要从数据库中已存储的收货地址信息列表中选择一个地址，如果用户之前没有添加过收货地址，则需要先去“个人中心”页面添加地址。
系统在设计数据库结构时需要开设多个地址信息列，来存储用户的多个地址信息。在网站或APP的收货地址管理页面，需要清晰显示不同地址信息的名称，例如“家庭”、“公司”、“学校”等方便用户识别。
每个地址信息中需要包含姓名、电话和地址等信息，以确保快递员能够准确送到用户的指定位置。
用户可以根据自己的需要进行选择，如果需要更改收货地址，点击“编辑”按钮，对已有地址进行修改。
如果想要添加新的地址，点击“新建地址”按钮，填写相关信息进行添加。
添加&amp;#x2F;编辑地址的页面需要清晰显示不同地址信息的名称、省&amp;#x2F;市&amp;#x2F;区等地址信息，以及联系人姓名、电话等详细信息。用户需要仔细确认自己填写的地址信息，确保其准确无误。

注意事项：

在添加&amp;#x2F;编辑地址时，需要确保地址信息的格式、拼写和精度，避免因填写错误导致送货地址不准确。
系统需要对接快递公司的API，以便于选择送货地址后对送货范围做出限制。（选做）
添加&amp;#x2F;编辑地址的页面需要清晰明了，避免用户因为找不到地址修改的入口或填写信息不当而造成不必要的麻烦。
在收货地址管理页面为用户提供批量操作功能，方便用户在多个地址信息之间进行切换、修改、删除等操作。
用户提交的地址信息需要保密，系统需要实现相关保护措施，来确保用户信息不被恶意利用。

3.3 提交订单：用户在提交订单时需要核对收货地址、商品列表（图片、名称、数量、金额）等信息。

提交地址信息后，系统需要进行验证和存储，以确保地址信息的准确性、完整性和安全性。
用户在选择完收货地址后，需要仔细核对相关信息，避免出现快递不能准确到达的问题，进一步确保顺利送货。

注意事项：

系统需要对用户提交的商品信息进行验证和存储，确保数据的准确性、完整性和安全性
系统需要对购物车中商品的价格、优惠等信息进行明细显示，方便用户核对和结算。

用户个人信息界面功能：（登录后可用）
4.1 查看喜欢的单品：用户可以查询自己点过喜欢的单品。

用户在登录后，通过点击“个人空间”按钮，进入个人信息页面，查看自己的个人信息和各种功能选项。
在个人信息页面中，用户可以选择“我喜欢的”等选项，进入相关页面查看自己的收藏和点赞信息。
如果用户之前收藏了一些单品，可以在“我的喜欢”页面中查看自己的收藏列表，列表中应包含收藏商品的名称、价格、图片等信息。
在查看自己的点赞信息时，用户可以进行一些操作，例如添加&amp;#x2F;删除收藏、点赞和取消点赞等，以便对自己感兴趣的商品进行管理和处理。

注意事项：

在实现个人中心功能时，需要严格遵守相关法律法规和用户隐私保护规定，确保用户的个人信息不被泄露或不当使用。
在设计个人中心页面时，需要考虑用户使用习惯和个人偏好，并充分考虑用户体验和操作便利性。
在添加&amp;#x2F;删除收藏等操作时，需要确保系统响应及时、准确和可靠，以避免用户遭受不必要的困扰或损失。

4.2 更改个人信息：用户可以修改个人的收货地址、姓名、电话和头像等信息。

用户在登录后，通过点击“个人空间”按钮，进入个人信息页面，在页面上选择“更改个人信息”选项。
系统将跳转至一个页面，用户可以在该页面上修改自己的各种个人信息，例如收货地址、姓名、电话和头像等信息。
如果用户要更改自己的收货地址，可以点击“编辑地址”按钮，进入修改地址页面，在该页面上输入新的地址信息，并保存修改后的地址信息。
如果用户要更改自己的姓名和电话号码，可以点击“编辑个人信息”按钮，在该页面上修改个人信息，并保存修改后的信息。
在进行以上操作时，用户需要仔细检查自己填写的信息，确保信息的准确性和完整性，特别是个人敏感信息，需要注意保护隐私和安全。
用户输入信息完成后，需要点击“保存”或“确认”按钮，系统会将用户修改的个人信息保存至数据库中。
修改成功后，系统会给用户相应的提示，用户需要注意确认修改是否成功，并检查已修改的信息的正确性。

注意事项：

在进行个人信息修改时，用户需要认真检查自己输入的信息，确保信息的真实性和准确性。
在进行更改个人信息时，需要确保系统稳定可靠，避免数据丢失或其他不必要的困扰。
在更改个人信息时，需要注意保护个人隐私和敏感信息，特别是收货地址和电话等个人敏感信息，需要做好保护措施，并遵守相关法律法规和用户隐私保护规定。

4.3 查看历史订单：用户可以查询历史订单，并且可以使用再来一单功能按钮。

用户在登录后，通过点击“个人空间”按钮，进入个人信息页面，选择“历史订单”选项。
在历史订单页面中，用户可以查看之前已经下过的订单列表，列表中应该包括订单号、下单时间、订单状态、订单总价等信息。
如果用户想要查看某个具体的订单的详情信息，可以点击该订单对应的“详情”按钮，进入订单详情页面，该页面上应包括订单中的商品列表、数量、单价、运费、订单总价等信息。
如果用户想要再来一单，可以选择想要再次购买的订单号，并点击“再来一单”按钮，系统将会将该订单中的商品重新加入购物车中，以备用户下一次购买使用。
在进行以上操作时，用户需要注意保护个人隐私和敏感信息，特别是订单号等个人敏感信息，需要做好保护措施，并遵守相关法律法规和用户隐私保护规定。
用户在使用再来一单功能时，需要注意商品数量、价格等相关信息的准确性和合理性，避免因买多或买少出现不必要的损失。

注意事项：

在进行历史订单查询时，用户需要认真核对订单信息，特别是订单号、订单状态、订单总价等关键信息，以确保查看信息的准确性和完整性。
在再来一单操作时，需要确保系统稳定可靠，商品数据准确，避免因不稳定或数据异常导致的错误操作和不必要的损失。
在购买商品时，需要遵守相关法律法规和商业规范，如在购买过程中需要确认商品的真实性、有效期、售后服务等相关条件，并防止遭受欺诈或其他不良行为的危害。

4.4 评价功能：用户可以对商家和骑手进行评价。

当订单状态为已完成后，用户可以在订单详情页面中选择“评价”选项。
进入评价页面后，用户需要选择要评价的对象，即商家或骑手，然后输入具体的评价内容。
如果是针对商家的评价，用户可以根据自己的实际体验，对商家的服务质量、商品品质、配送速度等方面进行评价，并给出相应的评分等级。
如果是针对骑手的评价，用户可以对骑手的服务态度、配送速度、安全性等方面进行评价，并给出相应的评分等级。
在评价过程中，用户需要注意文明用语，避免使用不文明语言、谩骂或恶意评价等行为，同时也需要认真考虑评价内容和分数，意见和建议应当建立在事实和客观情况基础上。
完成评价后，用户需要点击“提交”或“确认”按钮，系统将会将评价内容和分数保存至数据库中。

注意事项：

后台管理人员需要去审核用户的评价内容和分数，关注实际体验和客观情况，尽量选择有价值的评价信息，管理员应避免用户使用不文明语言、谩骂或恶意评价，保持文明的网络环境。
后台管理人员需要注意保护个人隐私和敏感信息，尤其是对商家和骑手的评价应遵守相关规定和良好的职业道德，遵守相关法律法规和商业规范，保持公正、公平、透明的态度和行为。

4.5 查看优惠券信息：系统需要提供会员优惠功能，包括所有单品打折或使用会员券减价等。

用户在登录后，可以在“个人空间”按钮，进入个人信息页面，找到“我的优惠券”选项，选择该选项进入优惠券页面。
在优惠券页面中，用户可以查看可用的优惠券信息，该信息包括优惠券名称、折扣力度、有效期等重要信息。
如果用户想要使用优惠券进行购物，可以选择该优惠券，然后点击“使用”按钮。
系统将会自动跳转至商品页面，并根据优惠券的类型和折扣力度进行相应的优惠扣减。
在使用优惠券时，用户需要按照优惠券的类型和使用条件进行相关操作，如满足最低消费额度、保证优惠券在有效期内、不重复使用等规定。
如果用户想要查看已经使用的优惠券信息，可以选择“已使用”或“已过期”选项，系统将会显示相应的优惠券使用记录。

注意事项：

在进行优惠券使用时，用户需要按照优惠券的类型和使用条件进行相关操作，避免出现不必要的损失或纠纷。
在查看优惠券信息时，用户需要认真核对优惠券的名称、折扣力度、有效期等相关信息，确保使用的优惠券有效并符合相关条件。
在使用优惠券时，用户需要注意相关的规定和操作流程，如最低消费额度、有效期等等，避免出现错误操作或违规行为。
经营方需要确保优惠券信息和使用流程的准确和规范，避免虚假宣传、误导消费者等违规行为。

管理员&amp;#x2F;商家管理界面(后台)：（后台页面&amp;#x2F;其他页面，与用户看到的前台页面区别开，是独立的页面）
5.1 后台商品管理：管理员需要更新商品数量，管理员通过点击上下架按钮来控制商品上下架。

店长或管理员登录进入商品管理页面，在管理系统中选择“商品管理”选项。
在商品管理页面中，管理员可以查看所有已存在的商品信息。可以在搜索框中输入商品名称、分类、关键词等信息进行快速查找。
如果需要更新商品数量，管理员可以选择想要更新的商品，点击“编辑”按钮。系统将会自动跳转至编辑页面。
在编辑页面中，管理员可以修改商品数量、价格、描述等信息，并点击“确认”按钮进行保存。
如果需要控制商品上下架状态，管理员可以选择想要操作的商品，并点击“上架”或“下架”按钮。
系统将会自动修改商品的上下架状态，并在页面中展示相应操作记录。

注意事项：

在进行商品管理时，管理员需要对商品信息和状态进行准确和规范的管理和操作，避免出现错乱或错误操作等情况。
在更新商品数量或价格等信息时，管理员需要遵守相关规定和良好的职业道德，确保信息的准确和合理。
在进行商品上下架操作时，管理员需要关注商品状态和库存等相关信息，同时需要遵守商业规范和相关法律法规的规定，避免误导消费者和其他违规行为。
经营方需要建立信息化的商品管理体系，确保商品信息和状态的有效和规范管理，提高管理效率和质量。

5.2 分类管理：管理员可以自定义分类，并提供分类管理功能来设置商品的分类。
（首页的页面展示分类：首页的分类还是按首页的来）

店长或管理员登录管理系统。
找到分类管理选项并点击进入。
点击添加分类按钮，输入分类名称，选择分类图片等信息。
确认添加并保存新分类。
可以对已有分类进行编辑、删除等操作。

5.3用户信息管理：管理员可以查看有多少用户购买过本店的哪些商品，并根据购买次数做出排行榜，通过排行榜来查看商品热度。

店长或管理员登录管理系统。
找到用户信息管理选项并点击进入。
查看用户购买记录，可以根据购买时间、商品等进行筛选。
统计每个商品的购买次数和金额，并根据购买次数做出排行榜。
根据排行榜查看商品热度，可以根据此来做出后续的商品管理决策。
可以对用户信息进行编辑、删除等操作，如需要修改个人信息或删除不该被公开的信息。

5.4店铺信息管理：管理员可以修改店铺名称、所在地区、详细地址、营业范围、营业执照等。

店长或管理员登录管理系统
找到店铺信息管理选项并点击进入
找到需要修改的信息，如店铺名称、所在地区、详细地址、营业范围、营业执照等
点击编辑按钮，进行修改操作
修改完毕后，点击保存按钮保存修改
如果需要上传新的营业执照，选择上传文件的选项，找到营业执照所在位置，上传文件。
确认无误后，保存修改并确认变更
可以在店铺信息管理页面中进行查看、编辑、更新操作，如需要进行其他店铺信息维护，也可以在此页面中操作

5.5订单管理：商家可以查看订单详情，并分页查看已处理和未处理订单。

店长或管理员登录商家后台系统。
进入订单管理页面。
选择订单状态，可以查看已处理和未处理订单。
根据需要查看订单列表，可以根据订单编号、时间、金额等进行筛选。
点击订单编号，进入订单详情页面，可以实时查看订单状态，包括下单、备餐、骑手送餐、送达等状态
如果需要对订单状态进行修改，可在订单详情页中进行操作。
在订单管理页面中，可以对订单进行取消、发货、退货、退款等操作。
对于已完成的订单，可以对订单进行评价和追评。
管理员可以进行分页查看已处理和未处理订单，方便统计和管理。

5.6订单用户信息：商家可以点击订单详情来查看订单用户的收货地址和电话号，同时可以添加自己的备注信息。

店长或管理员登录商家后台系统

进入订单管理页面

选择需要查看的订单编号，点击该订单的订单编号

进入订单详情页面，可以实时查看订单状态，包括下单、备餐、骑手送餐、送达等状态

在订单详情页面中，查看用户的收货地址和电话号码。

如有需要，可以在备注栏中添加自己的备注信息，如需要询问用户其他信息可在此备注栏中提出。

保存备注信息后，确认订单无误，即可进行后续的发货、退货、退款等操作。


数据库设计根据以上需求，可以设计以下数据库：
数据库名：manji_sweet用户表：user（一个用户最多可设置5个不同的收货地址）
字段：用户id（主键）、手机号、密码、昵称、地址1、地址2、地址3、地址4、地址5
字段：user_id（主键）、phone_number、password、nickname、address1、address2、address3、address4、address5
商品表：product字段：商品 id（主键）、甜品名称 、 描述、图片、价格 、类型、分类 、口味 、甜度、状态（上架&amp;#x2F;下架）
字段：product_id（主键）、product_name、description、image、price、type、category、flavor、sweetness、status（on&amp;#x2F;off shelf）
订单表：order字段：订单id（主键）、用户id、商品id、数量、总价、状态（待付款&amp;#x2F;待发货&amp;#x2F;已发货&amp;#x2F;已完成&amp;#x2F;已取消）、收货人、联系电话、收货地址、下单时间、付款时间、发货时间、更新时间
字段：order_id（主键）、user_id、product_id、quantity、total_price、status（unpaid&amp;#x2F;paid&amp;#x2F;delivering&amp;#x2F;delivered&amp;#x2F;completed&amp;#x2F;cancelled）、consignee、phone_number、delivery_address、order_time、payment_time、delivery_time、update_time
收藏表（喜欢表）：collection字段：id、用户id、商品id、创建时间、更新时间
字段：collection_id、user_id、product_id、create_time、update_time
商品评价表：evaluation字段：商品id、用户id、管理员id、骑手id、内容、创建时间、更新时间
字段：evaluation_id、product_id、user_id、admin_id、rider_id、content、create_time、update_time
管理员信息表：admin字段：id、手机号、密码、职位
字段：admin_id、phone_number、password、position
购物车表：cart字段：id、用户id、商品id、数量、创建时间、更新时间
字段：cart_id、user_id、product_id、quantity、create_time、update_time
用户表：
例子1：user_id为001的用户，手机号为12345678901，密码为123456，昵称为小明，有三个收货地址，分别是“北京市海淀区xx小区xx号楼xx单元”，“北京市朝阳区xx小区xx号楼xx单元”，“北京市丰台区xx小区xx号楼xx单元”。



user_id
phone_number
password
nickname
address1
address2
address3
address4
address5



001
12345678901
123456
小明
北京市海淀区xx小区xx号楼xx单元
北京市朝阳区xx小区xx号楼xx单元
北京市丰台区xx小区xx号楼xx单元




商品表：
例子2：商品id为1001的甜品名称是巧克力蛋糕，描述为口感细腻，图片为一张巧克力蛋糕的照片，价格为80元，类型为蛋糕，分类为甜点，口味为巧克力，甜度为中甜，上架状态。



product_id
product_name
description
image
price
type
category
flavor
sweetness
status



1001
巧克力蛋糕
口感细腻
巧克力蛋糕的照片
80
蛋糕
甜点
巧克力
中甜
上架


订单表：
例子3：订单id为20210801001的订单，用户id为001，商品id为1001，数量为1，总价为80元，状态为已取消，收货人为小明，联系电话为12345678901，收货地址为“北京市海淀区xx小区xx号楼xx单元”，下单时间为2021年8月1日10:00，更新时间为2021年8月10日12:00。



order_id
user_id
product_id
quantity
total_price
status
consignee
phone_number
delivery_address
order_time
payment_time
delivery_time
update_time



20210801001
001
1001
1
80
已取消
小明
12345678901
北京市海淀区xx小区xx号楼xx单元
2021-08-01 10:00:00


2021-08-10 12:00:00


收藏表：
例子4：收藏id为1的用户001，收藏了商品id为1001的甜品，创建时间为2021年8月1日10:00，更新时间为2021年8月1日12:00。



collection_id
user_id
product_id
create_time
update_time



1
001
1001
2021-08-01 10:00:00
2021-08-01 12:00:00


商品评价表：
例子5：商品id为1001的甜品，用户id为001，管理员id为001，骑手id为001，评价内容是非常好吃，创建时间为2021年8月1日10:00，更新时间为2021年8月1日12:00。



evaluation_id
product_id
user_id
admin_id
rider_id
content
create_time
update_time



1
1001
001
001
001
非常好吃
2021-08-01 10:00:00
2021-08-01 12:00:00


管理员信息表：
例子6：管理员id为001，手机号为12345678901，密码为123456，职位为管理员。



admin_id
phone_number
password
position



001
12345678901
123456
管理员


购物车表：
例子7：购物车id为1，用户id为001，加入了商品id为1001的甜品，数量为2，创建时间为2021年8月1日10:00，更新时间为2021年8月1日12:00。



cart_id
user_id
product_id
quantity
create_time
update_time



1
001
1001
2
2021-08-01 10:00:00
2021-08-01 12:00:00


</content>
    <url>/2022/06/22/%E5%89%8D%E7%AB%AF%E7%BD%91%E7%AB%99%E9%A1%B9%E7%9B%AE%E2%80%94%E2%80%94%E6%BB%A1%E8%AE%B0%E7%94%9C%E5%93%81%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/</url>
  </entry>
  <entry>
    <title>原创OC概念设计网站-游鲸JING17</title>
    <content>[本篇为原创OC概念设计相关内容存档]
概念站主页：http://jing17.morlvoid.pro/


概念站构成概念站的文本类型有三种：

站内对外展示的故事
图书管理员所掌握的禁书——世界的法则与秘密
我——作者本人的设计理念

概念站核心设定世界观三大圈层与七大状态三大圈层1.精神2.原则3.物质
七大状态1.完全依赖精神2.由精神向外延伸影响个人行为原则3.由精神向外延伸影响个人行为原则和整个人的行为举止4.完全依赖物质5.由物质向内延伸影响个人行为原则6.由物质向内延伸影响个人行为原则和个人精神思想7.精神与物质互相影响统一
七大状态区分逻辑
本体论纯度
类别1与4为极端本体论立场（纯粹精神&amp;#x2F;物质）
类别7为对立统一的中和路径


影响方向性
类别2-3：精神向外辐射（从理念到行动）
类别5-6：物质向内渗透（从环境到认知）


实践深度
行为原则（浅层规则） vs 行为举止（深层习惯）
例如：义务论（规则） vs 斯多葛主义（生活方式）



七大状态分类的13神


类别
定义
关键词
对应OC席位



1. 完全依赖精神
世界本质完全由精神或意识构成
理念、直觉、灵性、超越
711


2. 精神→行为原则
以精神为核心制定行为规范
道德律令、品格完善、绝对命令
610


3. 精神→行为原则+举止
精神塑造整体生存方式
克己、自由选择、知行合一
32-1（夜）


4. 完全依赖物质
世界本质由物质构成
物理实体、客观规律、实证
124


5. 物质→行为原则
物质条件决定行为准则
实效、多数利益、工具理性
89


6. 物质→行为原则+精神
物质基础反向塑造思想
经济决定、阶级意识、文化塑造
513（阿贝斯）2-2（昼）


7. 精神与物质统一
双向动态影响不可分割
矛盾转化、有机整体、心物一体
1（菱）


分类详表


类别
定义
典型流派



1. 完全依赖精神
世界本质完全由精神或意识构成
- 唯心主义  - 神秘主义  - 超验主义


2. 精神→行为原则
以精神为核心制定行为规范
- 义务论  - 德性伦理学


3. 精神→行为原则+举止
精神塑造整体生存方式
- 斯多葛主义 - 存在主义（责任维度）


4. 完全依赖物质
世界本质由物质构成
- 唯物主义  - 科学实在论


5. 物质→行为原则
物质条件决定行为准则
- 实用主义  - 功利主义- 怀疑主义


6. 物质→行为原则+精神
物质基础反向塑造思想
- 历史唯物论 - 酒神精神- 社会建构主义


7. 精神与物质统一
双向动态影响不可分割
- 辩证法  - 过程哲学  - 泛心论- 荒诞主义- 解构主义





类别
哲学流派
核心特征
核心思想
代表名言
代表人物



1. 完全依赖精神
唯心主义
否定物质的独立性，强调意识本体
精神是世界的本源，物质是意识的投射
“存在即被感知”（Esse est percipi）
贝克莱、黑格尔



神秘主义

通过直觉与灵性体验直接触及终极真理
“真理在寂静中被知晓”
普罗提诺、埃克哈特



超验主义

精神超越物质，个体灵魂与宇宙合一
“世界是精神的象征”（The world is emblematic of spirit）
爱默生、梭罗


2. 精神→行为原则
义务论
通过内在理念约束外部行为
行为的道德性取决于是否符合绝对律令
“要这样行动：你的行为准则能成为普遍法则”
康德



德性伦理学

道德的核心是培养卓越品格而非遵循规则
“德性是一种中庸之道”
亚里士多德


3. 精神→行为原则+举止
斯多葛主义
内外一致的精神实践
通过理性控制情感，顺应自然法则生活
“控制你能控制的，接受你不能控制的”
爱比克泰德、塞涅卡



存在主义（责任维度）

自由选择决定存在本质，需承担选择后果
“人被判定为自由”（L’homme est condamné à être libre）
萨特


4. 完全依赖物质
唯物主义
精神为物质产物或副现象
物质是唯一实在，意识是物质的产物
“不是意识决定存在，而是存在决定意识”
马克思



科学实在论

科学描述的物理实体独立于人类感知存在
“电子真实存在，即使我们看不见”
罗素、波普尔


5. 物质→行为原则
实用主义
依现实效用调整行动
真理是能产生实际效用的观念
“真理即有用”（Truth is what works）
威廉·詹姆斯、杜威



功利主义

道德的最高标准是最大化整体幸福
“最大多数人的最大幸福”
边沁、密尔


6. 物质→行为原则+精神
历史唯物论
物质环境渗透价值观
经济基础决定社会结构与意识形态
“物质生活的生产方式制约着整个社会生活”
马克思



社会建构主义

知识与价值观由社会互动与物质实践塑造
“现实是社会建构的”（The reality is socially constructed）
伯格、卢克曼



酒神精神

在毁灭与创造的交织中体验生命的壮美
“生命必须被肯定，直到它的最后一刻，直到它的痛苦、它的无常、它的谜团都被肯定。”
尼采


7. 精神与物质统一
辩证法
拒绝主次之分
矛盾双方通过对立统一推动发展
“矛盾是一切运动的根源”
黑格尔、马克思



过程哲学

实在的本质是动态的生成过程
“现实即生成”（Reality is a process）
怀特海



泛心论

物质与精神是同一实体的两面
“每一粒尘埃都包含着宇宙的精神”
斯宾诺莎、莱布尼茨



解构主义


“文本之外别无他物”
德里达


</content>
    <url>/2021/05/12/%E5%8E%9F%E5%88%9BOC%E6%A6%82%E5%BF%B5%E8%AE%BE%E8%AE%A1%E7%BD%91%E7%AB%99-%E6%B8%B8%E9%B2%B8JING17/</url>
  </entry>
  <entry>
    <title>前端网站项目——满记甜品更新日志  2026.1.28</title>
    <content>前端网站项目——满记甜品更新日志  2026.1.28满记甜品这个项目是2022年时前端结课答辩时小组合作写的。原本的网站是无需渲染的MPA模式，作为答辩还是太简单了些。于是我们将纯静态展示的满记甜品官网复刻下来，并调整为组件化开发、新增预加载和预加载动画、媒体查询，新增网购功能，新增用户系统。
很有趣的是，当年的小组成员并不会使用git，唯一会UI设计的我也是把设计新页面的大活交给了SAI这个绘画软件来做。时至今日已经学了更多UI设计与UX设计的内容，满记甜品也从2022年的扩展线下店变成了如今发展零售业加盟，还换了官网。时过境迁打算对满记甜品进行更新一次。
（不过既然时代变了，我已经能从UI设计到前端开发到后端开发到项目部署一气呵成了，或许这次可以尝试直接采用Vue做SPA架构再上线？）
更新日志：
2026年1月28日至2026年1月30日：全网站页面设计
展示地址：https://jinzijundshiyong.my.canvasite.cn/honeymoon


2026年1月28日至2026年1月30日利用可画全面重新设计了满记甜品官网，修改了所有的网页，新增的功能也一并设计并借助可画部署。（发现了新大陆）
网站的动效本身不多，考虑是否要用Figma再复刻一遍。
</content>
    <url>/2026/01/30/%E5%89%8D%E7%AB%AF%E7%BD%91%E7%AB%99%E9%A1%B9%E7%9B%AE%E2%80%94%E2%80%94%E6%BB%A1%E8%AE%B0%E7%94%9C%E5%93%81%E6%9B%B4%E6%96%B0%E6%97%A5%E5%BF%97-2026-1-28/</url>
  </entry>
  <entry>
    <title>以【叙事性线构插图】为目的的绘画知识库-1</title>
    <content>本篇是一个持续更新的、包含：个人总结的绘画学习路线图、练习经验学习笔记，主要针对ACG绘画的笔记，是绘画爱好者的个人学习过程中的所思所想。
本篇将以构成为主要目的和连接手段，将绘画学习分为四个大步骤：【寻找，欣赏，拍摄】、【观察，认识，理解】、【练习，刻画，表达】、【内容，题材，风格】，其中包含各自的小的内容。
ps：这里只是个人意见分类储存了各种绘画知识的知识库，包含大量个人观点，仅供寻找知识点使用
第一部分：以【叙事性线构插图】为目的的绘画知识库-1
第二部分：以【叙事性线构插图】为目的的绘画知识库-2


写在最前面本篇是持续更新的，笔者也在不停的学习和更新本篇笔记。作者非科班，不能保证特别全面，某些部分只是浅尝则之。如有错误或其他内容补充请联系~(^▽^) 联系方式在文章末尾。
由于“绘画学习路线”是个非常主观的内容，绘画涵盖的方向又极其广泛，笔者收集了常见的几种分类方式先做一个全面的扫盲介绍。
科班的学习科目清单笔者以中国传媒大学为例，收集了动画专业、动漫专业、美术专业、数字媒体艺术专业、视觉传达专业等需要学习的科目名称列表，详情请查看附录：
【附录：动画、美术、动漫相关专业的完整学习科目清单】
【附录：动画&amp;#x2F;美术&amp;#x2F;动漫专业科目分类表】
网络绘画班学习内容网络绘画班为非常常见的网络兴趣班，笔者会持续收集专业性较强的绘画班的教学思路。详情见附录：
【附录：Krenz绘画教室的三门核心课程学习重点】
【附录：西哥特——绘画技能树】
【附录：曼奇立德绘画课程体系】
以进入市场为目的绘画学习路径个人绘画谋生路径总结为卖课、进公司、接外包、个人原创创业四大核心方向。以市场需求为目的的途径为卖课、进公司、接外包。
详情查看附录：
【附录：个人画师四大生存路径全景表】
市场主流美术岗位的分类及详解详情查看附录：
【附录：市场主流美术岗位的分类及详解】
完整的生产端的资源规范，特别是针对角色美术资源的生产标准和类型定义详情请查看附录：
【附录：角色美术资源类型（图像）总览】
总览：ACG绘画究竟要学多少东西我将这些以上多维度多种学习内容进行分类整理：
相对简单的表格为：



分类
细分内容



1. 理论素养
艺术史、作品鉴赏、符号学、色彩心理学、艺术哲学


2. 技术基础
素描、线条、透视、解剖、速写、纹理、质感表现


3. 视觉语言
构图、光影、色彩、动态设计、空间层次


4. 专项设计
角色&amp;#x2F;场景&amp;#x2F;服装&amp;#x2F;生物设计、叙事性构图


5. 工具与媒介
传统绘画材料、数字软件操作、3D辅助工具


6. 创作思维
世界观构建、概念设计、情感表达、隐喻设计、跨学科灵感


7. 行业与商业
插画&amp;#x2F;漫画&amp;#x2F;游戏原画技能、版权意识


8. 练习与进阶
写生、默写、风格实验、行业案例研究


更加全面的表格请查看附录：
【附录：美术专业能力体系分类表】
绘画全领域知识体系等级表请查看：
【附录：绘画全领域知识体系总览表】
笔者个人路线：以叙事性构图为核心的绘画学习笔者在自学了科班内容、就读过网络绘画班后，个人非常喜欢叙事性构图，认为：
构图是美术的核心和重点，构图是绘画学习的中心也是重心，平面构图、色彩构图、等等一切其他技巧与技能均为叙事性构图服务。
故事是艺术载体呈现的主要内容，叙事是艺术作品的核心。
笔者认为，叙事性构图部分最容易学到内容的应该是平面设计与影视分镜。
在平面设计与分镜设计中，比起绘画技术，作者更加需要考虑如何将点、线、面等基本元素合理地安排在画面中，以达到预期的视觉效果。
于是笔者写下了下列针对叙事性构图单向训练的学习顺序：

一阶段以寻找故事感、发现故事感、从日常生活中寻找故事感、拍出故事感为主要内容。通过简单观看影视剧、优秀的卡牌设计、平面设计、摄影作品等，还可以自己拍摄，寻找喜好的表达内容的方式，拍摄记录故事。【这一阶段通过摄影了解画面中通用的基本的构图、透视、景深、景别、光影、色彩、动态设计、空间层次、叙事性绘画】
二阶段以基础学习为主要内容，学习过程中先学会观察，再学习一些简单的钢笔画景物简笔画。学习控笔。学习一些基础的图形符号关联，观察想要画的事物，对事物有自己的认识和理解。这个阶段还要学习一些地理、或者人文相关的常识。【观察这一项中包括学习：基本的艺术史、作品鉴赏、质感体会、光影体会等】
三阶段开始重点训练，我个人以钢笔画为主，还学习一些素描，学习根据构图练习，等等，常识开始原创创作，原创一些小插画。这一阶段重点在于练习，练习将自己理解的事物展现在纸上，并尝试创作一些容易找参考的主题系列画。【重点练习所有需要的内容，练习画出自己看见的、理解的内容，练习线条，色彩，纹理，细节，质感，光影】
四阶段加强画技训练和原创性训练。这阶段的构图也更加复杂，要考虑透视构图，色彩构图，等等，画面也要求更高刻画更细节。需要思考自己的原创性展示内容，选择适合自己表达内容的题材和风格。【思考自己想通过绘画这一形式表达什么内容，传达什么思想与理念，寻找最适合传达内容的题材，插画或漫画或动画或其他内容，形成自己的题材和风格】

步骤2与3通常会放在一起使用。步骤1是贯穿整个绘画路程的不可缺失的内容——在有了新的认识后很容易对之前的概念有所推翻，这是很正常的，有新的认识，再不断更新自己的追求和要求。而4也绝不是准备几年之后才确定的东西。
最重要的一点是：叙事性作品中，构图的中心也是重心。进行想象力训练是也是最主要的练习内容。
详细计划具体看后面的章节。



步骤
细分内容



寻找，欣赏，拍摄
构图、透视、景深、景别、光影、色彩、动态设计、空间层次、叙事性绘画


观察，认识，理解
艺术史、作品鉴赏、符号学（符号与隐喻）、色彩心理学、艺术哲学


练习，刻画，表达
素描、线条、解剖、速写、透视、纹理、质感表现、写生、默写、角色&amp;#x2F;场景&amp;#x2F;服装&amp;#x2F;生物设计、传统绘画材料、数字软件操作、3D辅助工具


内容，题材，风格
世界观构建、概念设计、情感表达、隐喻设计、跨学科灵感、插画&amp;#x2F;漫画&amp;#x2F;游戏原画技能、版权意识、风格实验、行业案例研究




零、笔者个人对ACG绘画的喜好和理解以及作者个人的学习方式（仅限ACG）
有关单独属于ACG绘画的个人经验：
0.1大纲概览1️⃣ 基础期：学习摄影，培养导演之眼摄影驱动观察 (核心)：摄影迫使快速观察、提炼场景、思考取景框内的叙事元素（主体、环境、光线、瞬间），是训练“镜头感”和“决定性瞬间”捕捉的高效方式。
目标明确： 每次拍摄设定一个“微型故事”主题。例如：“孤独”、“重逢”、“期待”、“冲突的预兆”、“城市的脉搏”。
大师作品“偷师”。学习重点： 构图基础（认识三分法、引导线、框架、留白等概念）、基础视觉元素（点线面）、符号学初步感知（无意识积累阶段）。
“单幅叙事”挑战： 给自己设定任务：只用一张照片讲一个清晰的故事或传达一种强烈情绪。避免依赖组图。
2️⃣ 深化期：想象力训练，隐喻与象征坚持速写与摄影，更有意识地运用构图法则服务于叙事主题。
系统进行想象力训练（概念具象化、属性嫁接、情境悖论）。
开始将想象力成果用钢笔画表达。
学习色彩基础理论，尝试在速写中加入有限色彩或单色练习。
文化符号积累。开始“符号解构”与“文化象征”研究，做笔记和视觉记录。
3️⃣ 深入期：扎实功底，提升叙事深度和广度速写本不离身： 随时随地画生活场景、人物动态、建筑细节、静物组合。重点捕捉“故事性瞬间”（等车的人、交谈的友人、市场的一角）。核心目标： 将观察、技能、符号知识整合，进行有明确叙事意图的原创创作，开始探索构图和视角的叙事力量。
钢笔画为主+有限色彩&amp;#x2F;质感尝试： 此阶段钢笔画技能应能支撑较细致的刻画。可在局部尝试添加单色（如文人茶杯的釉色、蛋糕的奶油色）或用不同肌理纸表现质感（如粗糙纸表现普通人家桌面）。
构图专项训练：同一场景，多种构图： 选一个简单场景，用钢笔画小稿（拇指草图）尝试至少5种构图（中心构图、三分法、框架构图、极简留白、倾斜视角等），体会不同构图带来的叙事重点和情绪变化。
镜头语言实践： 在“主题系列画”创作中，有意识选择特定景别和视角来强化叙事。
素描基础引入。
4️⃣ 系统期：原创内容，独立的世界观叙事构建为了让作品超越表面好看，拥有文化厚度、引发深度共鸣、精准传递复杂信息，丰厚的文化功底是关键。理解符号的普遍性和文化特异性，能更有效运用视觉语言。
大量人物动态速写（捕捉各种情绪和动作）。研究微表情和肢体语言心理学。设计角色时，思考其性格如何通过外在形象和动作体现。
系统学习色彩理论（色相、明度、饱和度、冷暖、对比、调和），理解色彩心理学（不同色彩引发的普遍情绪联想），以及色彩如何建立氛围、象征、区分时空或心理状态。电影美术、经典绘画的色彩运用是极好的学习对象。
有意识地练习用不同景别和视角去表现同一个场景，体会叙事效果的差异。练习如何在单幅内暗示时间流逝&amp;#x2F;前因后果，以及如何设计多幅画面的节奏、连贯性和视觉焦点转移。
持续所有输入性练习（速写、摄影、观察、理论学习）。定期进行完整创作： 构思小故事 -&amp;gt; 提炼关键帧 -&amp;gt; 深入创作（尝试不同媒介，不局限于钢笔）。刻意运用所学： 在创作中有目的地应用构图、色彩、符号象征、角色表演、镜头语言。
深入研究特定文化&amp;#x2F;主题： 选择感兴趣的方向深挖其视觉符号和叙事传统。
学习重点： 复杂空间透视、细节的叙事性设计、色彩理论与叙事性配色的深度结合、钢笔与色彩的融合技巧、完整世界观的视觉化呈现。
0.2寻找风格0.2.1画风广义上的画风具体分为：纯线条、色块、厚涂、平涂、水彩、写意（抽象）
笔者个人总结的画风具体分为：
画面内容：是否是具体的事物（区分具象画与意识流）
线条方面：是否有线条、线条是否按照物理规律、线条能否单独存在、线条是否与色彩融合
上色方面：是否上色、是否按照物理规律上色、是否根据光影上色、使用哪种笔墨形式上色
根据上面三个分类，排列组合成为各种各样的画风。
看过众多画师与画师的作品后，作者总结出了个人的喜好：

①喜欢以漫画感线条为主、上色为辅的日系平涂画风

②通过线条展现出角色长相区别

③光影对比明显的画风

④有较强的故事感和叙事感，能解读出内容


0.3载体载体是内容的呈现形式，也叫“艺术表现形式”或“艺术媒介”。
0.3.1ACG的核心对ACG来说，角色本质上是ACG内容的核心。
传统的艺术形式有：文学，绘画，雕塑，建筑，音乐，舞蹈，戏剧，电影。
0.3.2故事性载体ACG中常见的基本的故事性的载体有：小说、轻小说、绘本（连环画）、漫画（条漫）、歌曲（PV）、动画[10分钟以上10集以上的番剧]（短动画）、电影、游戏。部分ACG作品也有舞蹈、舞台剧等等衍生和补充形式。
以上的载体分类具有越来越复杂的趋势。从只需要文字的小说，到需要配备插图与角色设定是轻小说，到文字与图画几乎五五开的绘本、漫画，再到文字做了“脚本”和“台词”的区分，加入音乐元素、人声配音、更多动作特效元素后，动画与电影的制作越来越复杂，融合的内容也越来越多。
而在游戏阶段将融合所有的内容，用程序辅助增加了交互性，将原本只能通过直线叙事阅读的故事变得自由且更加沉浸式，让游戏逐渐被认可成为“第九艺术”。
从简单到复杂，ACG的载体形式逐渐融合了更多的艺术元素和技术手段，每种形式都有其独特的优劣势。小说和轻小说以文字为核心，适合深度叙事；漫画和动画通过视觉表现增强感染力；游戏则通过交互性和自由度，成为一种综合性的艺术形式。
这些载体不仅是形式上的不同，在传播难易度、大众认可度方面也有很大的差异。
例如小说缺乏视觉呈现，对于一些视觉化的概念（如角色外貌、场景细节），可能需要读者自行想象，尤其是在ACG中难以形成大众认可的角色形象。绘本、漫画虽然增加了丰富的画面，但动态效果和声音无法呈现，部分情感表达依然受限。而歌曲和PV通常篇幅较短，难以深入展开复杂的故事，大多情况还需要其他的形式补充无法表达的内容。动画与电影更是需要大量的资金与人力，无法独立完成，在依靠团体的情况下很难完全还原原作者的表达内容。游戏开发更需要整合多种艺术形式和技术，需要更大的制作团队，融合了更多人的情感与故事。
小说、动画、游戏，无论哪种载体，由于其带有的独特的故事性，都能很好的承载各种性格鲜活的角色。
有没有离开这些艺术载体独立存在的角色呢？
举例1：没有依赖大众公认的载体的原创角色（OC），既众多爱好者们在社交平台上发布个人绘制的OC立绘、插图、短篇小说、问答帖子等方式展现的个人的原创角色。
举例2：例如近些年随着4G网络的普及，网络中出现了“虚拟主播”这样的形式。不同与其他载体，虚拟主播是独立于任何载体之外的——角色的形象绝大部分来自于皮套之下的“中之人”的言行，通过表情包、短视频、直播切片等等来展现原创“虚拟形象”。
如果拿出当下最独立的虚拟AI主播 Neuro-sama 做为反驳这个观点的例子，可以说，她的确脱离了传统的艺术载体形式，但她依然需要代码运行、live2d形象、虚拟音声和网络直播平台等来与观众的互动产生故事，她利用了新时代的直播平台与技术做为载体，才能在直播中产生故事，在故事中形成被大众接受和传播的角色形象。
尽管未来还可能会出现诸如增强型电子书、区块链角色(NFT角色)等新的虚拟角色，在这样的技术条件下依然离不开技术这一载体。
可见，无论是传统的小说、漫画与动画，还是最新依靠科技的虚拟角色的形象建构，仍主要依赖于艺术载体系统。
0.3.3关于原创角色——”OC“【结合0.2.1和0.2.2关于故事性载体的思考，本篇开始探讨角色与故事性载体之间的关系，以及没有故事性载体的个人原创角色是否被大众记住接受认可或广泛传播。这个问题涉及两个层面：一是角色与故事性载体的关系，二是原创角色的独立性。】
问题1：如果角色脱离故事性载体，那它可能只是一个概念或设定而没有故事，是不是无法被大众认识和记住？
问题2：没有故事就没有人物弧光，没有人物弧光的角色是否太过单薄无法留下印象？
【人物弧光是指角色在故事中经历的心理、情感或道德上的变化过程。人物弧光是角色塑造的核心，它通过角色的成长和变化赋予故事深度和张力。不同的载体以不同的方式呈现人物弧光，但其本质是相同的：通过角色的变化反映人类的普遍经验，引发观众的共鸣。】
我想这两个问题不同的人有不同的答案。这里仅写出我的想法：
我认为，角色想要获得鲜活的被认可的形象，就需要有内容，内容需要故事，故事需要有故事性的载体来呈现。所以对角色来说，故事必不可少，承载故事的载体也必不可少。仅仅是“图像”的美术资源无法完全承载故事。
角色是ACG内容的核心，而故事是角色的载体。没有故事，角色就像没有灵魂的空壳，无法展现出鲜明的个性和情感。故事通过情节、冲突和角色的成长来赋予角色生命力，使他们能够与观众产生共鸣。
0.3.4如何设计原创角色新增一项附录：结合了动画相关专业的学习内容后如何设计一个原创角色
【附录：设计原创角色的步骤】
一、寻找，欣赏，拍摄这部分的主要内容为：从摄影的角度出发，学习构图、透视、光影、色彩、景深、动态设计、空间层次、叙事性绘画等的基础理论。
【本章节只介绍最基本的理论，最主要的目的是列举包含哪些内容。更加详细的内容请参考第三章练习部分】
1.0解释：为什么先以摄影为出发点：1.0.1摄影和绘画在构图上的相同点摄影迫使快速观察、提炼场景、思考取景框内的叙事元素（主体、环境、光线、瞬间），是训练“镜头感”和“决定性瞬间”捕捉的高效方式。

构图的基本原则：两者都遵循一些基本的构图原则，如黄金分割、三分法、对称式构图、曲线构图等。这些原则有助于在画面中创造平衡、和谐和美感。
对画面元素的组织：无论是摄影还是绘画，作者都需要考虑如何将点、线、面等基本元素合理地安排在画面中，以达到预期的视觉效果。
空间感的营造：两者都通过一定的手段来表现空间感和深度，如利用透视法、景深控制等，使画面更具立体感和真实感。
情感和主题的表达：构图的最终目的是为了更好地表达作品的情感和主题，引导观者的视线，使他们能够理解并感受到创作者想要传达的内容。

1.0.2本阶段大纲和目标学习重点
构图基础（认识三分法、引导线、框架、留白等概念）、基础视觉元素（点线面）、符号学初步感知（无意识积累阶段）。
1.0.2.1摄影目标 每次拍摄设定一个“微型故事”主题。例如：“孤独”、“重逢”、“期待”、“冲突的预兆”、“城市的脉搏”。
分析大师作品： 不要只拍，更要深度分析优秀纪实摄影、电影剧照、甚至古典绘画的构图和叙事手法。问自己：主体是谁？环境如何烘托主体？光线营造了什么情绪？引导线指向哪里？留白的作用是什么？这个画面暗示了什么之前或之后的故事？
“单幅叙事”挑战： 给自己设定任务：只用一张照片讲一个清晰的故事或传达一种强烈情绪。避免依赖组图。
关注“关系”与“瞬间”： 人物与人物、人物与环境、人物与物体的互动关系。捕捉有张力的瞬间（悬而未决、情感爆发点、微妙反应）。
光线即语言： 刻意练习不同光线（侧光、逆光、顶光、柔光、硬光）对氛围和故事感的影响。
1.0.2.2基础期基本功
大量钢笔画速写（生活场景、人物动态、静物）→ 训练手眼协调、造型能力、细节观察。
摄影练习（单幅叙事、分析大师作品）→ 训练构图思维、瞬间捕捉、光影理解。
学习基础构图法则、视觉元素原理、图形设计基础。

1.0.2.3每日任务随身携带手机&amp;#x2F;相机，主动寻找并拍摄1-3张“有故事感”的照片。主题不限，但要求：单幅画面能引发观者猜想“发生了什么？”或“他&amp;#x2F;她&amp;#x2F;它在想什么？”。
分析： 每晚回顾照片，问自己：

这张照片哪里体现了故事感？（人物表情&amp;#x2F;动作？物体状态？光影氛围？特殊组合？）
它可能讲述了一个什么故事？（编一个微小说）
构图（主体位置、引导线、留白）如何服务于这个“故事感”？
每天&amp;#x2F;每周分析1-2幅优秀的纪实摄影、电影海报、经典叙事性绘画（如爱德华·霍珀）。重点看：主体如何突出？环境如何烘托？瞬间如何抓取？情绪如何营造？ 用文字或草图笔记你的发现。

1.1构图1.1.1构图是什么构图是摄影中的一项基本技能，它涉及到如何在画面中安排和组织各种元素，以达到预期的视觉效果和表达特定的主题或情感。
构图黄金公式：功能性构图 &amp;#x3D; 网格系统 + 视觉动线叙事性构图 &amp;#x3D; 焦点链 + 情绪留白
1.1.2构图的作用
引导观众视线：

• 通过构图，可以引导观众的注意力，使他们的视线按照创作者的意图在画面中移动。例如，使用引导线（如道路、河流、人物的视线等）可以将观众的视线引向画面的重点。

表达主题和情感：

• 构图可以帮助突出画面的主题，传达创作者的情感和意图。例如，对称构图可以传达稳定和和谐的感觉，而不对称构图可以传达动感和紧张感。

营造空间感和深度：

• 通过透视、层次、重叠等构图手法，可以在二维平面上营造出三维空间感和深度，使画面更加真实和立体。

平衡画面：

• 构图可以实现画面的视觉平衡，避免画面显得过于拥挤或空旷。通过合理安排元素的位置和大小，可以使画面看起来更加稳定和舒适。
1.1.3构图组成
点：画面中的兴趣点，可以是人物、花朵、建筑等，能够吸引观众的注意力，使画面更具焦点。
线：包括直线、曲线、折线等，线条可以引导观众的视线，增加画面的动感和方向感，如河流的曲线、建筑物的直线。
面：大面积的色块或形状，如天空、水面、草原等，可以营造画面的整体氛围和基调。
形状：不同的形状（如圆形、三角形等）具有不同的视觉感受，圆形给人柔和、完整的感觉，三角形则显得稳定、庄重。
色彩：色彩的搭配和对比可以影响画面的情绪和主题，如暖色调给人温暖、活力的感觉，冷色调则显得宁静、冷峻。
明暗：明暗对比可以增强画面的立体感和层次感，突出主体，营造氛围，如强烈的光影对比可以增加画面的戏剧性。

1.1.4构图元素
主体：

• 主体是画面中最重要、最吸引人的部分，是创作者想要传达的核心内容。构图时需要突出主体，使其在画面中占据合适的位置和比例。

陪体：

• 陪体是辅助主体的元素，用于衬托主体，增强画面的表现力和深度。陪体可以是人物、景物、道具等。

前景：

• 前景是画面中最靠近观众的部分，可以用来增加画面的深度感和层次感，也可以作为引导线引导观众的视线。

背景：

• 背景是画面中最远离观众的部分，用于衬托主体，营造氛围和环境。背景可以是简单的颜色、图案，也可以是复杂的场景。

空间：

• 空间是指画面中各个元素之间的距离和位置关系。通过合理安排空间，可以使画面更加自然和舒适，避免过于拥挤或空旷。透视的学习内容及与构图的结合
1.1.5构图基本法则除了黄金分割，还有许多其他常见的构图方法，这些方法可以帮助创作者更好地组织画面元素，引导观众的视线，并传达特定的情感或主题。以下是一些主要的构图方法：
1.三分法（九宫格构图）
• 定义：将画面水平和垂直方向各分为三等份，形成九宫格。画面的主体或重要元素可以放在四个交叉点或沿着分割线上。
• 优点：这种构图方式简单易用，能够使画面更加平衡和稳定，同时避免了过于对称的呆板感。
• 应用：适用于风景、建筑、人物等多种题材，是摄影和绘画中常用的构图方法。
2.对称构图
• 定义：画面的左右或上下部分在形状、大小、位置等方面基本相同。
• 优点：传达稳定、和谐、庄严的感觉，适合表现建筑、风景等具有对称性的场景。
• 应用：常用于拍摄建筑物、雕塑等具有明显对称性的对象。
3.框架构图
• 定义：通过前景元素构建一个“框架”，将主体置于其中。
• 优点：增强画面的深度感和层次感，同时引导观众的视线进入画面的核心部分。
• 应用：在风景摄影中，可以利用树枝、门窗等作为前景框架。
4.引导线构图
• 定义：使用画面中的线条（如道路、河流、栏杆等）引导观众的视线。
• 优点：使画面更具方向性和引导性，增强视觉效果。
• 应用：常用于风景摄影，引导观众的视线向画面深处延伸。
5.三角形构图
• 定义：将画面的元素组成一个三角形的形状。
• 优点：具有稳定感，同时又能引导观众的视线。
• 应用：适用于人物群像或需要表现稳定感的场景。
6.S形构图
• 定义：画面的元素沿着S形曲线展开。
• 优点：富有动感和韵律感，增强画面的流动感。
• 应用：常用于表现河流、道路、人物动态等场景。
7.填充构图
• 定义：画面被主体完全填满，几乎没有多余的空间。
• 优点：突出主体的细节和质感。
• 应用：常用于特写镜头。
8.留白构图
• 定义：在画面中故意留下空白区域。
• 优点：突出主体，传达宁静、简洁的感觉。
• 应用：在东方绘画和现代设计中非常常见。
9.对角线构图
• 定义：将主体或重要元素放在画面的对角线上。
• 优点：增强画面的动态感和活力。
• 应用：适用于需要表现动感的场景。
10.黄金螺旋构图
• 定义：基于黄金分割比例的螺旋线，将主体放在螺旋线的起点或关键位置。
• 优点：使画面更具视觉吸引力和自然美感。
• 应用：常用于需要引导观众视线的场景。
1.1.6构图的注意事项
避免过于复杂：

• 构图时要注意画面的简洁性，避免过于复杂和混乱。过多的元素会使画面显得杂乱无章，分散观众的注意力。

保持平衡：

• 画面需要保持视觉平衡，避免一侧过重或过轻。通过合理安排元素的位置和大小，可以使画面看起来更加稳定。

突出主体：

• 主体是画面的核心，需要通过构图手法突出其重要性。可以通过大小、位置、色彩等方式使主体更加突出。

考虑观众的心理：

• 构图时要考虑观众的心理反应，不同的构图方式会传达不同的情感和氛围。例如，对称构图传达稳定感，不对称构图传达动感。
1.2透视透视是绘画和设计中用来表现三维空间的重要技术，主要通过在二维平面上模拟人眼看到的视觉效果来实现。以下是学习透视的理论内容：
1.2.1透视的基本原理• 近大远小：物体离观察者越近，看起来越大；离观察者越远，看起来越小。
• 近宽远窄：物体的宽度也会随着距离的增加而变窄。
• 近实远虚：远处的物体看起来更模糊，颜色更淡。
1.2.2透视的类型• 一点透视（平行透视）：当物体的一个面与画面平行时，所有平行线会汇聚到一个消失点（灭点）。这种透视适用于表现正面视角的场景，如正面的建筑或房间。
• 两点透视（成角透视）：当物体的两个面与画面成一定角度时，会产生两个消失点。这种透视是最常用的，适用于表现侧面视角的场景，如街道、建筑物的侧面等。
• 三点透视：当物体的三个面都与画面不平行时，会产生三个消失点。这种透视适用于表现高层建筑、俯瞰或仰视的场景。
1.2.3透视的术语• 视点（SP）：观察者眼睛的位置。
• 地平线（HL）：与观察者眼睛等高的一条水平线。
• 消失点（VP）：平行线在远处汇聚的点。
• 基线（GL）：地面与画面的交线。
1.2.4透视的应用• 建筑和室内设计：通过透视可以准确表现建筑的结构和空间关系。
• 风景画：利用透视营造出深远的空间感。
• 人物绘画：通过透视表现人物在空间中的位置和动态。
1.3景深1.3.1景深的作用1.3.2景深的种类1.3.2.1浅景深当希望画面中主体突出明显时就可以用上浅景深，通常叫作微距拍摄，可以用来拍摄花卉、昆虫或者是人物。抑或想要营造一种梦幻的效果时也可以用上浅景深。
1.3.2.2大景深当希望画面中所有的内容都清晰显示时就用大景深。
1.3.3景深控制摄影的基本技术之一是对景深的控制，景深效果对照片的构图影响非常明显。
扩大景深，使所有被摄体在画面上都清晰可见。缩小景深，清晰地表现主要的物体，让次要的物体虚化隐去。
1.4景别1.4.1景别的作用1.4.2 景别的种类1.4.2.1远景
定义：远景是指画面中包含非常广阔的场景，通常用于展示自然风光、城市全景、大型活动等宏大的场景。
特点：远景能够营造出一种宏观的视角，使观众感受到场景的壮丽和宏大。画面中主体相对较小，重点在于环境的整体氛围。
适用场景：适用于拍摄山脉、海洋、城市天际线、大型集会等需要表现广阔空间的题材。

1.4.2.2全景
定义：全景是指画面中包含整个场景或主体的全貌，从前景到背景都能完整地呈现在画面中。
特点：全景能够全面展示场景的广阔性、整体性和空间感，让观众对整个场景有一个宏观的认识。
适用场景：常用于风景摄影、建筑摄影、大型活动拍摄等需要展现宏大场景的题材。
注意构图的平衡和画面的简洁。

1.4.2.3中全景
定义：中全景是指画面中包含主体的大部分和部分周围环境，通常以人体的腰部或膝盖以上为范围。
特点：中全景既能展示主体的全貌，又能体现主体与周围环境的关系，具有一定的叙事性和空间感。
适用场景：适用于拍摄人物活动、事件场景等，能够较好地表现人物之间的交流和互动。
可以利用引导线或前景元素来增强画面的层次感。

1.4.2.4中景
定义：中景是指画面中包含主体及其周围部分环境的景别，通常以人体的膝盖以上为标准。
特点：中景能够展示主体的动作和表情，同时体现主体与周围环境的关系，具有一定的叙事性和空间感。
适用场景：适用于拍摄人物活动、对话交流等场景，能展现人物动作和部分环境。
可以利用前景元素来引导观众的视线。

1.4.2.5近景
定义：近景是指画面中主体占据较大比例，通常以人体胸部以上为范围的景别。
特点：近景能够突出主体的细节、表情和情感，使观众更关注主体的内心世界和细微动作。
适用场景：常用于人物肖像、访谈、情感表达等需要突出主体的场合。
注重对主体的刻画和细节的表现。

1.2.4.6特写
定义：特写是指画面中主体的局部被放大，占据整个画面，以突出主体的某个细节或特征。
特点：特写具有强烈的视觉冲击力和艺术感染力，能够吸引观众的注意力，强调主体的某个特定部分或情感瞬间。
适用场景：适用于拍摄人物的面部表情、手部动作，以及物体的细节特征等，常用于广告、艺术摄影等领域。
需要精确对焦以确保主体细节清晰。

1.2.4.7大特写
定义：大特写是指极端放大主体的某个细节，突出其质感和特征，几乎占据整个画面。
特点：大特写具有极强的视觉冲击力和艺术感染力，能够吸引观众的注意力，强调主体的某个特定部分或情感瞬间。
适用场景：常用于艺术摄影、广告摄影、微距摄影等需要突出细节的场合。
需要精确对焦以确保主体细节清晰。

二、观察，认识，理解艺术史、作品鉴赏、符号学、色彩心理学、艺术哲学、文化与象征
2.0解释：为什么要学习画面文化与象征2.0.1历史的作用2.0.2本阶段大纲和目标核心目标： 提升观察精度，掌握基础描绘工具（钢笔画），初步建立“视觉符号库”和“文化联想库”。
2.0.2.1钢笔画基础控笔与质感： 大量练习线条（直线、曲线、长线、短线、排线）、点画。重点练习用不同线条表现不同质感（木纹、布料、金属、玻璃、植物）。
静物写生： 从简单几何体过渡到复杂静物组合。目标：准确捕捉结构、比例、透视、光影（用排线表现明暗）。
场景速写： 在户外或室内，用钢笔快速捕捉有生活气息的小场景（咖啡馆一角、书架、厨房台面、街边小摊）。重在整体氛围和关键细节，不求面面俱到。
2.0.2.2文化符号积累定向输入： 根据你选择的“主题发散”方向，针对性阅读相关地理、民俗、历史、神话的科普文章、纪录片、图片资料。做视觉笔记（画下关键符号！）。
建立“符号速查本”： 按类别（自然、动物、植物、人造物、颜色、数字等）或文化区域，整理你学到的符号及其常见含义（用钢笔画小图标+关键词）。
“概念具象化”练习
输入： 抽象概念（如：自由、束缚、时间流逝、记忆、希望、绝望、嫉妒、成长）。
输出： 用具体的、可画的物体或场景来表达这个概念。避免直白（如自由&amp;#x3D;鸟）。思考更深层、更个人化、更有冲击力的联系（自由&amp;#x3D;被剪断的线团？束缚&amp;#x3D;被植物根系缠绕的脚踝？时间流逝&amp;#x3D;沙漏里流出的不是沙而是老照片？）。
“属性嫁接&amp;#x2F;扭曲”练习
选一个普通物体（如：椅子、苹果、钟表、钥匙）。
改变它的一个关键物理属性（材料、功能、状态、大小、重力影响）或赋予它一个矛盾的情感属性（如：温暖的冰、悲伤的气球、愤怒的枕头）。
思考这个改变暗示了什么故事或情感？（如：融化的金属椅子 - 暗示高温、压力、不稳定？长出藤蔓和花朵的破旧椅子 - 废弃与新生的结合？）
“情境悖论”练习 
将两个看似矛盾或不相关的元素&amp;#x2F;情境强行组合，并寻找合理的叙事解释或强烈的情绪冲击。

例：图书馆 + 深海潜水；废弃工厂 + 芭蕾舞者；雨伞 + 沙漠；微笑 + 破碎的镜子。
思考：为什么会这样？发生了什么？结果会如何？这表达了什么？

文字转译图像练习
找一段富有画面感的小说、诗歌、歌词段落。
不要画文字直接描述的场景，而是画出这段文字在你心中唤起的核心情感、隐喻意象或象征性画面。
建立“视觉词典”： 随身携带小本子或手机备忘录，随时记录生活中看到的、想到的、感受到的有趣意象、符号、光影效果、人物动态组合。这些都是你未来创作的宝贵素材库。
2.0.2.3每日任务基于你的摄影作品或日常观察，进行简单快速的视觉笔记（非精细绘画）。例如：
主题： “等待” + 地点（车站长椅、医院走廊、咖啡店窗边） → 快速勾勒不同场景下“等待”的人物动态、环境特征（用简笔画、火柴人+简单场景元素即可）。
主题： “光” + 情绪（温暖的台灯、刺眼的霓虹、孤独的路灯） → 用简单的线条和明暗块面记录光影氛围和你的情绪联想。
目标： 建立“故事感元素”与“视觉联想”的快速链接，积累素材库。重在思考和记录，不在画技。
2.0.2.4“主题发散系列画” - 初级记录灵感。
深化期融入想象力与叙事：
坚持速写与摄影，更有意识地运用构图法则服务于叙事主题。
系统进行想象力训练（概念具象化、属性嫁接、情境悖论）。
开始将想象力成果用钢笔画表达。
学习色彩基础理论，尝试在速写中加入有限色彩或单色练习。
开始“符号解构”与“文化象征”研究，做笔记和视觉记录。
练习“角色表演”和肢体语言速写。
2.1艺术史2.2作品鉴赏2.3符号学2.4色彩心理学2.5艺术哲学2.6文化与象征三、练习，刻画，表达素描、线条、解剖、速写、透视、纹理、质感表现、写生、默写、角色&amp;#x2F;场景&amp;#x2F;服装&amp;#x2F;生物设计、传统绘画材料、数字软件操作、3D辅助工具等
3.0解释：为什么表达线条、纹理、质感表现等写生选用钢笔画钢笔画（尤其是针管笔、蘸水笔）强迫关注线条质量、疏密节奏、明暗对比（通过排线）、造型的精确性和概括力。它训练“做减法”，用有限的工具清晰地表达结构和细节，这对于叙事插画中清晰传达信息至关重要。它能让画的东西“像”且“有力度”。非常适合作为入门和基础训练工具。 它相对简单（工具少）、成本低、便于携带、效果直接。专注于线条和黑白灰，能让你更纯粹地练习构图和造型。
3.0.1钢笔画与素描基础引入目的： 强化形体、结构、空间感的理解，为更复杂场景和角色打基础。
练习： 几何石膏、静物（理解块面）、简单人物动态速写（抓大形和动态线）。不必追求长期素描，侧重理解结构和空间关系。
学习重点： 构图服务于叙事的策略、视角与景别的叙事效果、符号的选择与组合叙事、从写生到原创的转换、素描基础支撑形体。
3.0.2本阶段大纲和目标核心目标： 将观察、技能、符号知识整合，进行有明确叙事意图的原创创作，开始探索构图和视角的叙事力量。
3.0.2.1质感尝试练习钢笔画为主+有限色彩&amp;#x2F;质感练习
此阶段钢笔画技能应能支撑较细致的刻画。可在局部尝试添加单色或用不同肌理纸表现质感。
3.0.2.2构图专项训练同一场景，多种构图： 选一个简单场景（如一个人坐在窗前），用钢笔画小稿（拇指草图）尝试至少5种构图（中心构图、三分法、框架构图、极简留白、倾斜视角等），体会不同构图带来的叙事重点和情绪变化。
镜头语言实践： 在“主题系列画”创作中，有意识选择特定景别（特写茶杯的裂痕？中景看人物姿态？）和视角（仰视表现压迫？俯视表现渺小？）来强化叙事。
构图设计

视角： 平视？略带俯视（展现桌面细节）？
景别： 中景（聚焦桌面和手部）？还是带一点环境（如文人背后的书架一角）？
布局： 主体（茶杯组合）的位置？陪衬物（竹简&amp;#x2F;蛋糕&amp;#x2F;西红柿）如何摆放能引导视线并暗示关系？留白区域在哪？有何作用？

3.0.2.3如何用于叙事训练
速写本不离身： 随时随地画生活场景、人物动态、建筑细节、静物组合。重点捕捉“故事性瞬间”（等车的人、交谈的友人、市场的一角）。
场景构图小稿： 用钢笔快速勾勒不同构图方案（拇指草图），只关注布局、主体位置、视觉引导，不追求细节。
“黑白电影”练习： 找经典黑白电影的截图或有强烈光影的剧照，用钢笔画临摹，重点分析光影如何塑造形体、营造氛围和引导视线。
结合想象力： 用钢笔画出你想象力训练中产生的那些隐喻意象。钢笔画特有的力度和质感能为这些意象增添表现力。

3.0.2.4原创入门举例：
“下午茶” + 身份&amp;#x2F;时代。
目标： 单幅画面清晰传达“这是谁的下午茶？”以及“透露了主人什么信息&amp;#x2F;状态？”
方法：
构思： 明确你想表达的三种身份&amp;#x2F;状态（文人、西方小姐、普通人家）。
符号选择： 精心挑选最具代表性、能形成对比的符号（竹简 vs 古典茶杯；精致蛋糕+玻璃杯 vs 塑料杯+小西红柿；掉漆桌子）。
3.0.2.5“主题发散系列画” - 进阶 符号联想：主题更具体，融入文化&amp;#x2F;符号学习：
举例：
“雨” + 地域&amp;#x2F;情感：

江南梅雨：钢笔画 - 青瓦白墙、朦胧远山、打着油纸伞的模糊背影、湿漉漉的石板路。符号： 油纸伞、白墙黛瓦、青苔、氤氲水汽。
海上暴风雨：钢笔画 - 翻滚的巨浪、低垂的乌云、颠簸的小船（或象征海燕的飞掠剪影）。符号： 巨浪、乌云、孤舟、海燕（简化轮廓）。
都市夜雨：钢笔画 - 霓虹灯在水洼中的倒影、匆匆行人的雨伞、湿漉漉的玻璃幕墙。符号： 霓虹、倒影、匆忙的剪影。

“书” + 性格&amp;#x2F;命运：

学者：堆满笔记的旧书、磨损的书脊、老花镜。符号： 笔记、磨损、眼镜。
冒险家：摊开的泛黄地图、指南针、压在书页里的干树叶&amp;#x2F;羽毛。符号： 地图、指南针、异域标本。
被遗忘的书：布满灰尘、书页卷曲、角落有蛛网&amp;#x2F;鼠洞。符号： 灰尘、破损、虫蛀、蛛网。

方法：
先研究： 选定主题后，快速查阅相关文化背景、典型意象、象征物。
再构思： 为每个联想方向构思一个具体的、可画的场景或物体组合。
钢笔画表现： 用第二阶段的钢笔画技能，完成5张该主题下的系列小画（尺寸可小，如A5），清晰表达核心符号和氛围。
3.1多维度练分类习一、线条维度


学习目标
推荐领域
深度强化方向




线条透视
工程制图
- 三视图投影逻辑 - 曲面拓扑分析



线条表现力
黑白漫画+速写+概念艺术线稿
- 情绪化笔触节奏 - 负形轮廓提炼
速写练生物动态线（《伯里曼人体结构》）


二、构图维度


学习目标
推荐领域
不可替代价值



功能性设计感构图
平面设计+卡牌设计+UI设计
信息密度管理 - 卡牌：元素层级压缩 - UI：费茨定律应用


故事性叙事性构图
影视分镜+漫画分镜+摄影作品
时空叙事技巧 - 分镜：视线引导轴 - 摄影：决定性瞬间


三、色彩维度


学习目标
推荐领域
核心技术&amp;#x2F;理论




技术性色彩
摄影后期
- 色轮校准 - 通道混合器应用



叙事性色彩
色彩心理学+影视美术+游戏原画
- 色彩符号学 - 环境光叙事
影视美术依赖 色彩心理学的文化编码游戏原画需掌握 摄影后期中的LUT调色


四、内容，题材，风格世界观构建、概念设计、情感表达、隐喻设计、跨学科灵感、插画&amp;#x2F;漫画&amp;#x2F;游戏原画技能、版权意识、风格实验、行业案例研究
4.0分类讨论：如何选用主题4.0.14.0.2本阶段大纲这是让作品超越表面好看，拥有文化厚度、引发深度共鸣、精准传递复杂信息的关键。理解符号的普遍性和文化特异性，能更有效运用视觉语言。
4.0.2.1原创内容铺垫书籍： 《视觉符号学基础》（入门读物），《图像学：形象、文本、意识形态》（W.J.T. Mitchell），《符号学原理》（罗兰·巴特）— 这些可能有些学术，但核心思想很重要。也可以找一些面向设计师&amp;#x2F;插画师的视觉传达、符号象征类书籍。
图形设计原理： 学习点、线、面、色彩、肌理、空间、平衡、对比、节奏等基本视觉元素和原则。这些是构建画面和叙事的基础语法。推荐《设计中的设计》（原研哉）、《写给大家看的设计书》（Robin Williams）。
广泛阅读： 不同文化的神话传说、民间故事、宗教艺术。了解常见的象征物（动物🐍、植物🌹、颜色🎨、数字、自然现象）在不同文化中的含义（如：龙在东西方的差异，乌鸦的吉凶寓意，白色在婚礼与葬礼的不同）。
艺术史： 学习不同时期、流派艺术大师如何处理叙事、运用象征（如：文艺复兴宗教画、浪漫主义、象征主义、超现实主义）。
电影分析： 电影是动态的叙事艺术，分析其镜头语言、色彩运用、道具象征（麦高芬）、场景设计如何服务于故事。
“符号解构”练习 
选择一个常见符号（心形、钥匙、阶梯、面具），研究它在不同文化&amp;#x2F;语境中的含义，尝试画出它在不同叙事场景中可能代表的不同东西（钥匙可以是希望、禁锢、秘密、权力）。
“文化转译”练习 
取一个西方童话&amp;#x2F;故事，尝试用东方的视觉符号和审美重新构思画面（反之亦然）。思考如何保留核心叙事但转换视觉语言。
“角色表演”与“肢体语言” 
叙事插画中，角色是故事的载体。他们的表情、姿势、动态、互动方式是传达情节和情绪的核心。需要专门练习：

大量人物动态速写（捕捉各种情绪和动作）。
研究微表情和肢体语言心理学。
设计角色时，思考其性格如何通过外在形象和动作体现。

创作中刻意运用
在构思自己的叙事插画时，有意识地思考：这个物体&amp;#x2F;颜色&amp;#x2F;构图除了本身功能，还能象征什么？它能否承载更深层的含义？是否符合目标受众的文化背景？
“镜头”语言与视角 

景别： 特写（强调情感、细节）、中景（人物关系、动作）、全景&amp;#x2F;远景（环境、氛围、规模感）。不同景别传递的信息量和重点不同。
视角： 平视、俯视（渺小、弱势、全局）、仰视（高大、压迫、敬畏）、倾斜视角（不稳定、紧张）。视角选择能极大影响观众对角色和事件的感受。
有意识地练习用不同景别和视角去表现同一个场景，体会叙事效果的差异。

</content>
    <url>/2025/03/20/%E4%BB%A5%E3%80%90%E5%8F%99%E4%BA%8B%E6%80%A7%E7%BA%BF%E6%9E%84%E6%8F%92%E5%9B%BE%E3%80%91%E4%B8%BA%E7%9B%AE%E7%9A%84%E7%9A%84%E7%BB%98%E7%94%BB%E7%9F%A5%E8%AF%86%E5%BA%93-1/</url>
  </entry>
  <entry>
    <title>公众号散文合集</title>
    <content>闲暇时间写的公众号散文
——随笔日记——
同步更新至微信公众号：NoName_Library


拾阶而上人总是爱说见识，说认知，却常忘了它们的来处与归途。
昨日与友闲谈，论及“何谓长进”。友蹙眉道：“书也读了不少，理也听了许多，却总觉如浮云过眼，不留痕迹。”我闻之默然，心下却有所触动。
多看，自然是好的。眼睛是心灵的窗牖，开得愈大，进来的光亮便愈多。世间万象，人生百态，无不是学问。有人看山是山，看水是水；有人看山不是山，看水不是水。这其中分别，不在眼而在心。看的多了，心便大了，能容之物自然也多了。
然而单是看，终究不够。所见所闻，若只堆积于心，不过是一团混沌的云雾。须得说出口来，方能理出个头绪。说话之际，字字句句须得从脑海中打捞出来，排列整齐。这一捞一排之间，模糊的便清晰了，杂乱的便有序了。有时自以为明白的道理，一经说出，竟发觉漏洞百出；而原本朦胧的想法，却在言语间渐渐成形。
但说话如风过耳，说过便散了。今日明白的道理，明日或许又模糊了；此刻理清的思路，彼时可能又乱了。这便是为什么要写下来。
写，是一件极郑重的事。笔尖落在纸上，或指尖敲在键盘上，都是将飘忽的思绪定格成形。写下来的过程，又是一番梳理与锤炼。白纸黑字，不容含糊；成文成篇，必要逻辑。于是那些浮于表面的浅见，不得不沉下去；那些零散碎乱的想法，不得不聚拢来。
写下来了，还不算完。须得保存下来，常常回看。人的记忆不可靠，人的认知也会反复。今日之我，未必强于昨日之我；此刻之悟，未必深于彼时之悟。唯有将每一步的见识都记录下来，才能踩着自己的思想阶梯，步步向上。
回看旧文字，有时不免赧然——当初何以那般浅薄！但这赧然正是进步的明证。若看旧文而不觉其浅，反倒危险了。那阶梯若不能引你向上，便成了禁锢你的围栏。
如此，看、说、写、存、回看，循环不已，认知便不再是空中楼阁，而成了可以拾级而上的实实在在的台阶。每一步都踏实，每一阶都稳固。登高望远时，也不忘来路；迷茫困顿时，尚有迹可循。
友闻我言，颔首不语。我知道他心下已在盘算，要从何处说起，从何处写起了。
人这一生，原就是在给自己筑阶。筑得一道好阶梯，方能稳步上升，看清来路，也望见前程。
动与思之间人常容易陷入一种单一的节奏里，以为专注就是将所有时间投注在一件事上。然而真正的生活，或许不在于固守一隅，而在于找到动静之间的平衡。
常见许多学生或职场人，终日坐在桌前，对着书本或电脑屏幕，一坐就是一整天。起初效率尚可，时间久了，不仅腰酸背痛，连思维也渐渐变得滞重。这时候，需要的不是更多的坚持，而是起身活动：去跑步，让身体出汗；去登山，让视野开阔；去打球，让精神振奋。运动不只是为了健康，更是为了清醒头脑。久坐不仅让身体僵硬，也会让思维变得固化。
反过来，也有人终日奔波劳碌，或忙于体力工作，或四处奔波办事。一天下来，身体疲惫不堪，晚上只想躺着休息，再无余力思考或学习。久而久之，身体或许强健，但思维却可能停滞不前。这个世界在快速变化，若只动手不动脑，难免会感到越来越吃力。
认识一位程序员，曾经整天对着代码，后来开始每天健身。他说运动后不仅身体好了，连写代码的思路都更清晰了。也听说过一位装修师傅，闲暇时喜欢看各种装修设计的视频和书籍，不仅手艺越来越好，还能给客户提出专业建议，收入自然也水涨船高。
其实，劳心者需要运动，劳力者需要学习。这不是什么高深的道理，而是让身心保持活力的基本方法。就像手机需要充电也需要使用一样，人的身体和大脑也需要交替使用和休息。
现代人总说“全面发展”，其实不是说要做全才，而是不要偏废任何一方面。只动脑不动身体，人会变得虚弱而空洞；只动身体不动脑，人会变得机械而停滞。最好的状态，是让身体和思维都能保持活跃。
傍晚时分，常看到工地旁的工人们在休息时看着手机学习新技术，也见到写字楼里的白领们换上了运动服去健身房。这或许就是现代人追求平衡的方式吧。
生活从来不是非此即彼的选择。在动与思之间找到自己的节奏，或许才能走得更远，也更自在。
经历之重人常道早熟是好事，我却以为未必。早熟犹如早开的花，虽抢了先机，却未必能经得起风雨。看懂了，不等于学会了；知道了，更不等于经历了。
今人多有一种通病：捧一方手机，便自以为窥尽了世间百态。看旁人创业维艰，便道商海浮沉不过如此；见他人情场失意，便说男女之事无非这般。未曾亲历，先得结论，且多是灰心丧气的结论——“这个不行”，“那个太难”，“我早就知道了”。
这般“早知道”，最是害人。二十岁的年纪，偏生揣着四十岁的顾虑；尚未起步，已经畏葸不前。看见别人跌倒，便以为自己也一定会摔跤；听闻某事艰难，就断定自己必定不能胜任。于是这也不敢试，那也不愿碰，终日困在方寸屏幕里，对着别人的生活指指点点，自己的生活却寸步难行。
这哪里是早熟？分明是未老先衰。真知灼见，从来不是从旁观看得来的。须得亲身去经历，去触摸，去感受——成功的喜悦，失败的痛楚，坚持的艰辛，放弃的遗憾。这些滋味，任是再生动的视频、再详尽的文字也难以传达其万一。
我见过一个年轻人，读过许多创业失败的故事，因而对开办自己的工作室望而却步。后来在朋友的鼓励下，接了一个小项目来做。三个月后，他告诉我：“原来实际操作中遇到的困难，和我在文章里看到的完全不同。”那些他曾经畏惧的难题，真正面对时反而激发了解决的勇气和智慧。
又记得一位女子，因看了太多婚姻不幸的案例而对爱情失去信心。直到她自己也投入一段感情，才明白关系中虽有磕绊，但也有温暖和支持是外人无法体会的。
看人游泳，永远学不会凫水；听人谈食，终究不知真味。生命中的诸多事务，只有亲身经历，才能形成真正属于自己的认知。别人的教训可以借鉴，但不能替代自己的体验；别人的经验可以参考，但不能成为自己的借口。
放下手机，走出房门，去尝试那些你“早就知道”的事情。或许你会发现，真实的世界远比别人讲述的更加复杂，也更加有趣。失败不可怕，可怕的是从未尝试；受伤不要紧，要紧的是不敢再去爱。
年少时不该有老年的心态，正如朝阳不该有夕阳的沉暮。生命需要亲自经历，才能活出真正的宽度与厚度。故事等待被书写，而不是被阅读。
变之录人总是怕听一句话：“你变了”。这话仿佛带着指控的意味，让人不由得心头一紧，急于辩解。然而变化何罪之有？岁月流转，人岂能不变？真正关键的，不是变或不变，而是如何变、为何变，以及变得是否如自己所愿。
近来友人相见，多有慨叹：“你和从前大不相同了。”这话若是放在十年前，我必惶恐不安；如今听来，却只淡然一笑。不是不在乎，而是知道自己在变化中走到了何处，又将去往何方。这份自知，不是凭空而来，而是得益于案头那几本日记。
日记之为物，看似琐碎，实则重如金石。它不声不响地收录了我们的每一天：那些转瞬即逝的念头，那些不足为外人道的悲喜，那些在时光流转中悄悄发生的变化。若无记录，往事便如烟云散去，再也寻不回当初的真切。
去年此时，我曾为什么而欣喜？为何事而忧虑？对何人抱有期待？又因何而失望？若无日记，这些问题的答案恐怕早已模糊不清。人总是善于遗忘的，尤其是遗忘自己的来路。于是年复一年，虽然总觉得有所成长，却说不出究竟成长在何处。
而有日记的人则不同。他能够清晰地指出：去年的今日，我还是那般思虑；今年的此刻，我已能如此观照。这变化不是偶然发生，而是有意为之；不是随波逐流，而是自有方向。翻开日记，便是翻开了一部个人成长的史册，上面清清楚楚地写着：某年某月某日，我决定要成为一个怎样的人；某时某刻，我又向这个目标靠近了几分。
曾有一个年轻人对我说：“我不知道自己这些年到底有没有进步。”我问他：“你可曾记录？”他默然不语。这便是问题的关键了。没有记录，就没有参照；没有参照，就难知进退。人在时光中行走，若无标记，怎能不迷失方向？
所以我劝人写日记，不是为着消遣，而是为着自知。当你能够从容地对那些说“你变了”的人回应：“是的，我变了，我知道自己哪里变了，而且这变化正是我所期望的”，那时你便会明白日记的价值。
变化不可怕，可怕的是不知不觉地变；成长不可疑，可疑的是说不清道不明的成长。愿我们都能在日记中看清自己的轨迹，走出自己的道路，变得一天比一天更加明白：我是谁，从何处来，要往何处去。
如此，当有人再说“你变了”时，我们自可坦然应答：“自然要变，而且变得正好。”
阅读的胃口人的胃口生来就知道挑拣。孩童时偏爱甜食，不喜苦味；长大后，口味或宽或窄，各有所好。然而身体需要五谷杂粮、蔬果肉蛋，方能健康强壮——阅读之事，又何尝不是如此？
曾见一位朋友，沉迷于心理学大家荣格的学说。起初是兴趣，后来成了痴迷，最后竟变得只信荣格一人之言。与人交谈，开口便是“荣格说”，闭口便是“分析心理学认为”。世界在他眼中，仿佛只剩下原型、集体无意识、阴影与人格面具。原本开阔的视野，渐渐收束成一条窄缝。
这使我想起乡下老农常说：单吃一种粮，人要得病。阅读亦然，单读一个人的书，思想便会“营养不良”。再伟大的思想家，其视野亦有边界；再深邃的智慧，其观点亦有时限。若只守着一家之言，无异于画地为牢，将自己的心智困在一方小天地里。
人接触思想，当如种子生长。种子需要水分，也需要阳光；需要土壤中的养分，也需要空气中飘来的花粉。它不拒绝清晨的露珠，也不排斥午后的小虫；它接纳微风送来的远方种籽，也吸取落叶化作的腐殖质。这种开放与包容，才是生命茁壮的道理。
读书亦当有此胸怀。东方西方，古代现代，文学科学，哲学艺术……各种书籍，各有滋味。读诗使人灵秀，读史使人明智，读科学使人精确，读哲学使人深刻。每一种都是养分，缺了哪一种，心智都可能生出看不见的“暗病”。
有人问：“读多了不同观点，不会混乱吗？”初时或许会的。但正如食物需要时间消化，思想也需要时间融汇。各种观点在脑中碰撞、交锋、融合，最终会形成你自己的见解——那将不是任何人的复制品，而是真正属于你自己的思想体系。
偶像崇拜最是危险。把一个人当作精神支柱，就如同把房子建在独木之上。万一木朽了，房子便塌了。若能博采众长，便是打下了坚实的地基，任凭风吹雨打，自是岿然不动。
我的朋友后来终于走出“荣格圈”，开始涉猎其他学派。再见时，他笑着说：“原来世界这么大。”是啊，思想的天地原本辽阔，何必自限于一隅？
放开阅读的胃口吧，尝百家饭，饮千江水。让不同的思想在脑中相遇，让对立的观点在心中对话。如此，你的精神世界才会真正丰盈起来，既有高度，也有广度，更有深度。
书海无涯，没有人能够穷尽。但我们至少可以做到：不偏食，不挑食，让阅读成为一场永不散席的盛宴。
标签之外人活于世，难免被贴上种种标签。有的来自他人之口：“你真是个理性的人”；有的来自各种测试：“你是INTP型人格”；有的甚至来自我们自己：“我天生就不擅长社交”。这些标签如同一个个小小的盒子，我们不知不觉就把自己装了进去。
曾见过一个平日温文尔雅的同事，因为被众人称赞“好脾气”，即使在遭受不公待遇时也强忍怒火，结果抑郁成疾。也认识一个被测出是“内向型”的女孩，明明渴望陪伴，却因害怕不符合“人设”而独自承受孤独。
这多么可惜。
那些测试和评价，本是为了帮助我们了解自己，不知何时却成了禁锢自我的牢笼。人们忘了，再精确的测评也只是工具，再深入的了解也只是片面之词。人心之复杂，岂是几道选择题能够穷尽？人性之丰富，又怎会被几个字母简单定义？
你可知道？河流不会因为被标注在地图上就停止改道；树木不会因为被冠以学名就拒绝生长新枝。自然万物都在不断变化、突破边界，为何独独人类要用标签束缚自己？
那个被称为“理性至上”的人，也有权利在深夜里为一场电影泪流满面；那个被认定是“社交达人”的活跃分子，也可以在某天拒绝邀约，享受独处的宁静。人本就是一个矛盾的集合体，时而勇敢，时而怯懦；时而开朗，时而内向。这又有什么不可以呢？
测评结果和他人评价，应当是一扇窗，而不是一堵墙；应当是一面镜子，而不是一个模具。它们帮助我们看见一种可能性，而不是规定一种必然性。知道“有人这样看我”和“测评这样显示”是有价值的，但这价值在于拓宽而非限制。
真正重要的是：你感觉自己想要什么？在什么样的状态下你最自在？什么样的选择让你感到充实和快乐？这些问题的答案，只有你自己能够给出。
不妨把那些标签看作衣橱里的衣服——今天可以穿这件，明天可以换那件，没有哪一件能够定义完整的你。你是穿衣服的人，而不是衣服本身。
所以，下次当有人试图用某个标签定义你时，不妨微笑回答：“那只是我的一部分。”遇到测评结果与内心感受不符时，大可说：“这个不太像我。”
你远比任何标签都要复杂、丰富、精彩。你是流动的河，不是标注在地图上的线；你是生长的树，不是植物图鉴里的插画。
打开那些盒子，走出来吧。天地广阔，何必蜷缩在一个小小的标签里？你自己，才是最好的定义者。
水的诗意昨日与二三友人小聚茶室，窗外骤雨初歇，竹叶上缀着将落未落的水珠。友人品着今春的龙井，不知怎地，话题就转到了水上。
研习化学的友人先开口，语气平和：“从科学上说，水就是两个氢原子和一个氧原子的结合，化学式是H₂O。”她说话时，手指轻轻点着桌面，像是在陈述一个再自然不过的事实。
从事文学创作的朋友听了，眼中含笑，温声道：“可我总觉得，水不止于此。你看檐角滴落的水珠，映着天光云影，分明是天地间最美的诗句。”她望向窗外，雨后的竹林青翠欲滴。
我静坐其间，听着二人交谈，不觉莞尔。这样的对话在我们之间已是常事，却从不令人厌倦。
科学家友人又道：“水在零度结冰，百度沸腾，这都是分子运动的规律。”
文学友人唇角轻扬：“那我宁愿说，冰是水的沉睡，沸是水的欢歌。你看窗上的冰花，千姿百态，岂是分子排列所能尽述？”
她们就这样你一言我一语，一个以理性剖析世界，一个以感性品味人生。如同在聆听一曲和谐的二重奏，我欣赏着她们的一言一语。
科学家友人忽而笑道：“我虽常言水是H₂O，却最记得小时候井边打水，那入口的清甜滋味。”文学友人亦点头：“我虽爱以诗词咏水，却也感佩科学让我们明白为何水能解渴润物。”
二人相视而笑，再无争执。窗外的雨又淅淅沥沥地下了起来。
我忽然明白，认识世界如同品茶，既要知道茶叶中含有茶多酚、氨基酸，也要静心品味茶香氤氲、回甘悠长。最高明的认知，应当是既明白分子运动之理，也懂得感受杯水温暖之情；既知晓化学反应之则，也体会生活体验之趣。
临别时，科学家友人细心提醒：“雨后路滑，小心行走。”文学友人则望着雨幕轻吟：“好雨知时节。”我撑着伞，既留心脚下之路，也欣赏沿途之景。
想来，认识世界何尝不是如此？既要低头看路，以求行稳；也要举目赏景，以养心神。二者兼备，方得圆满。
今晨沏茶时，我既知水温宜在八十度以存茶香，也静观茶叶在水中舒展如舞，感受茶香沁人心脾。两种认知相得益彰，让一盏清茶既润喉又怡神。
人生在世，若能既以科学之眼观世界之真，又以人文之心感生活之美，或许就能活得更加明白，也更加丰盈。
独飞与共翼民间有句俗语说，每个人都是单翼的鸟儿，唯有找到另一半才能拥抱飞翔。这话听来浪漫，细想却令人不安：若此生无缘相遇，莫非就要永远困守地面，望天兴叹？
我以为不然。
人确如飞鸟，但何必等待另一只翅膀？何不用知识的羽毛，以能力为骨，为自己铸就另一只翼？读书明理，可丰其羽翼；实践历练，可强其筋骨。待到时日，自能振翅而起，翱翔于九天之上。那时，清风在翼，流云在侧，天地广阔，任尔遨游。
飞行途中，或遇同道。两只独立的飞鸟，各自有力，各自有方向，却愿比翼齐飞，共历风雨。你无需依附于我，我不必拖累于你。我们相视一笑，然后一同飞向更高的天空。这样的相遇，方是锦上添花，而非雪中送炭。
倘若无缘，亦无妨碍。你已见识过破晓时分的霞光，穿越过正午的云海，沐浴过夕阳的余晖。一个人的天空，同样精彩万分。
爱情不是两个半圆的拼接，缺了谁都不完整。而是两个完整个体的相知相惜，如同夜空中两颗独立的星辰，既各自闪耀，又交相辉映。它们按照自己的轨道运行，却又因为彼此的引力，共舞出一曲壮美的宇宙之舞。
最好的爱情观，或许应该是：我自盛开，清风自来；我自翱翔，有缘同行。
不必焦急地寻找那另一半翅膀。若能成为能够独飞的大鸟，也能拥有自己的天空和方向。那时，若遇同行者，自可携手共览云海；若无，亦已拥有一片苍穹。
行路的哲思人生犹如驾驶，你我皆是那握方向盘的人。车厢内时而喧哗，时而寂寥，而路途始终在前方延伸。
常见公交车行驶于城市街巷，不论满载而行或空车而返，总是循着既定路线，一站复一站，直至终点。这寻常景象，暗合着某种深意：生命的价值，不在于载客多寡，而在于是否完整走完自己选择的道路。
我们的人生车上，曾坐满亲爱的乘客。父母在侧呵护备至，友人相邻谈笑风生，爱侣相伴共赏风景。那时以为这热闹会是永恒，却不知人生月台上，从来聚散无常。
有人到站离去，有人中途换乘，有人不告而别。车厢由喧闹转为寂静，最后或许只剩驾驶座上的自己。此时最易彷徨：是否因无人相伴就改变路线？是否因孤独难耐就停驻不前？
一位老司机曾说：“我的职责不是计较乘客多少，而是将车安全驶达终点。”朴素之言，却有金石之音。人生何尝不是如此？父母会老去，友人会星散，爱侣或许只能同行一程。他们的来去皆是常态，而我们却不能因任何人的离去，就放弃既定的行程。
空荡的车厢固然寂寥，却也因此让人更清晰地听见内心的声音，更专注地把稳前行的方向。在这独行的时刻，你与自我深度对话，反而能领悟生命的本真。
前方还会有新的站台，还会遇上新的同行者。或许还会与旧日下车的故人重逢。但无论乘客几何，你的车都要继续前行。既享受人群中的热闹，也能安守独行时的寂静。不论车厢空满，都专注地驶向前方。这一路的风景，早已因你的坚持而显得壮丽。
棱角之说常听人叹惋：“生活磨平了我的棱角。”这话说来轻松，细思之下，却透着几分将就与无奈。棱角若真是被磨平的，那磨石何在？又为何自愿俯身其上？
我以为，人之为人，贵在有选择之权。生活固然有它的重量，但如何承受，如何应对，主动权终究在自己手中。所谓棱角，不过是个人特质与坚持的外现，它们或许会因阅历而变得圆润通达，却不应被简单地“磨平”。
曾遇见一位朋友，多年前曾是热血青年，凡事都要争个分明。几年后再见，却变得唯唯诺诺，逢人便说“被生活磨平了棱角”。细问之下，方知他所谓“磨平”，不过是放弃了坚持，选择了顺从；所谓“成熟”，不过是学会了妥协，忘记了初心。
这哪里是被生活所磨？分明是自己交出了选择的权柄。
生活从来不会主动磨去谁的棱角，它只是提供各种各样的境遇。有人在这些境遇中变得圆滑，有人却变得更加棱角分明。其中的差别，不在生活本身，而在每个人面对生活的态度。
那些能够保持本色的人，并非生活特别优待他们，而是他们始终记得：无论外界如何，选择权始终在自己手中。他们或许会调整方向，但不会改变航向；或许会迂回前进，但不会放弃目的地。
成熟，不是棱角被磨平，而是知方圆而不失本心；不是随波逐流，而是外圆内方。就像河中的石头，历经水流冲刷，变得光滑润泽，但它的质地从未改变，它的核心依然坚硬。
所以，不要轻易说“被生活磨平了棱角”。你的棱角，只有你自己能够放弃；你的选择，只有你自己能够交出。生活给予我们的，从来不是磨石，而是试金石。它在考验：你是否还记得自己想要什么？是否还有勇气去追求？
愿你在这场考验中，既不莽撞地棱角毕露，也不懦弱地圆滑世故。而是在知世故的同时，保持自己的本真；在明事理的同时，坚守自己的原则。
生命最美的状态，或许就是：外表温润如玉，内心棱角分明。知世故而不世故，处江湖而不忘初心。
解焦虑之结人常为焦虑所困，细细想来，多半源于那些“本可为而未尽为”之事。心向往之，身却不能至；志在千里，却踌躇于足下。这其间的落差，恰是焦虑生长的土壤。
见过一位朋友，想写文章却终日不安。问起缘由，他说：“怕写不出精彩。”我劝道：“何不先允许自己写出些平淡的文字？美玉在雕琢之前，也不过是普通的石头。”朋友于是放手去写，初稿虽平淡，但修改之后渐入佳境。不过数日，文章已成，焦虑也随之消散。
世间的完美，多是从“不完美”中蜕变而来。工匠制作器物，总是从粗糙的胚胎开始；画家创作，也是先勾勒出大致的轮廓。倘若因为害怕不完美而不敢开始，就永远不会有完成的一天。
焦虑如影，专追停滞不前的人。当站在原地，它便如影随形；当迈步前行，它就只能退居身后。化解焦虑最好的方法，莫过于选择一两件小事，立即去做。清晨跑一小段路，傍晚读几页书。事情虽小，但日积月累，自信便慢慢生长。
这种自信不是凭空而来，而是从一次次兑现对自己的承诺中积累而来。每完成一件小事，就是对自己许下的诺言兑现了一次。这样的自我信任，比任何外界的赞美都更加坚实。
常见有人困于宏大的目标，不知从何入手。不如将大目标化为小行动，千里之行，始于足下。今天整理书桌，明天完成报告，后天读一本一直想读的书。在行动之间，焦虑自然渐渐消散。
更有人因为害怕别人的评价而不敢尝试。殊不知，他人的言论如同风中的絮语，飘忽不定。唯有自己最清楚：是否已经尽力，是否已经尽心。
人生在世，岂能事事完美？不如先求完成，再求完善。允许自己有一个“不够好”的开始，才能走向“足够好”的结局。
当你开始行动，那些曾让你夜不能寐的焦虑，自然会转化为前进的动力。行动处的灯火，足以照亮焦虑的暗室。
若感到焦虑缠身，不妨自问：此刻我能做的最小的一件事是什么？然后起身去做。在行动之处，焦虑自会退散；在实践之地，自信悄然生长。
人生没有万全之策，唯有尽力而为。先打破心中对完美的执念，方能见到真实的风景。
相遇的学问人世间的相遇，原是一门深奥的学问。常听人说寻伴侶之难，要遇见许多人，真正相处过，方知合与不合。其实何止伴侶，朋友、师长、医者，乃至一份差事，何尝不如此？
见过有人与恋人争执，便断定“此人非我良配”；与朋友龃龉，却反思“我是否不擅交友”；听不明师长所授，就自责“非此道之材”；求医未见速效，竟疑心“患了不治之症”；在公司处事不顺，甚至怀疑“自己不适宜工作”。
细想来，这般思虑未免有失偏颇。人与人相遇，犹如钥匙与锁孔，未必每一把都能开启；亦如琴瑟和鸣，未必每一具皆能谐振。天下之人如林中之叶，无一完全相同，相遇不合本是常事，相得益彰反是难得。
记得幼时读诗，“人生不相见，动如参与商”。参星与商星此出彼没，永不相见。人与人能相遇已属难得，能相知更是可贵。既如此，何必因一二不合，就否定自己？
友人中曾有一位，连换三位导师方得投契。起初他也自责，是否自己资质驽钝。后来终于明白，不过是尚未遇到教学方法与他相宜的师长罢了。如今他已学业有成，回想往事，只笑叹当时年轻，不该那般苛责自己。
又有相识求医问药，连访七位医师，才得遇良医。前六位未能妙手回春，并非他病入膏肓，不过是医缘未到。
所以，与人相处不谐，不必即刻归咎自己。也许只是尚未遇到投缘之人，尚未找到适合之处。就像寻路的人，不能因为走错一条巷子，就断定自己不会走路。
世间人海茫茫，各有各的脾性，各有各的缘法。与人相遇，需要一点耐心，需要一些机缘，更需要多次尝试的勇气。不必因一时不合而自责，更不必因此否定自己的价值。
愿你在这茫茫人海中，既有相遇的幸运，也有错过的豁达。既珍惜相知的难得，也释怀不合的寻常。毕竟，最好的相遇，总是在不断的寻找之后。
人生三宝世间传说，人皆有三件宝物伴其一生：一曰罗盘，可辨方向；二曰纸笔，可绘地图；三曰锦囊，可藏所得。此三物非金非玉，无形无质，却自人初生时便相伴左右，直至终老。
修行之路，漫漫其修远兮。或有幸得遇明师，引你入门，授你心法。此时当以纸笔细细记之，如春蚕食叶，沙沙有声。师者之言，或如明灯，照亮前路；或如清泉，涤荡心灵。若能虚心受教，勤加记录，便是积累了最初的行路资粮。
然天下岂能人人得遇明师？多半时候，我们要独自远行。此时方知三宝之珍贵。罗盘在手，纵使前路迷雾重重，亦能辨明方向；纸笔在怀，纵然山川险阻，也能绘出属于自己的地图；锦囊在身，哪怕风雨兼程，也可将一路所得悉心收藏。
曾见有人徒有罗盘而不之用，随波逐流，终其一生不知所往；也有人备纸笔而懒于记录，待到迷途，方悔当初未曾留心；更有人空负锦囊而不知珍藏，让无数机缘从指间溜走。如此，纵有宝物在身，亦与无物何异？
修行之道，贵在善用三宝。以罗盘定方向，明白己心之所向；以纸笔绘地图，记录走过的每一步；以锦囊收藏所得，将经历化为智慧。日积月累，地图日益详尽，锦囊日渐充盈，前路也愈发明朗。
人生天地间，忽如远行客。有的行者匆匆赶路，忘了欣赏沿途风景；有的徘徊不前，困于一时的迷障。唯有善用三宝之人，既能坚定前行，又不失欣赏风景的闲情；既能勇往直前，又懂得适时调整方向。
其实，得道成仙不在远方，而在当下；不在结果，而在过程。若能善用罗盘辨明本心，勤用纸笔记录人生，妙用锦囊珍藏感悟，则每一步都是修行，每一刻都在接近真谛。
当某日夕阳西下，回顾来时路，当会发现：最珍贵的不是最终到达何处，而是这一路上，如何用这三件宝物，绘就了独一无二的人生图卷，收藏了无可替代的生命馈赠。
如此修行，纵不能得道成仙，亦可谓不负此生了。
学无涯人常道“学海无涯”，然多数人只当此是少年时的功课。殊不知，人生漫漫，学习之事，实无终时。
幼时所学，不过识得世界之基。咿呀学语，方知人间有千万声音；执笔描红，乃晓文字藏古今智慧；数豆算珠，才解世间有规律可循。这是推开世界之门的第一道缝隙，门后天地，尚待探寻。
及至成年，步入社会，方知学问之广，远超想象。不仅要学会炊爨之事，懂得与人往来，谋职求生，安家置业；更要学会与自己的身体和解，同自己的情绪共处。最难的学问，却在追问：“我是何人？”“为何而行？”“何处是归途？”
这些问题的答案，从来不是少年时能够参透的。须得经历世事后，在某个清晨或深夜，忽然灵光一现，方得些许真谛。
曾遇一位妇人，年过四十始学绘画。旁人笑她迟暮之年，何苦来哉。她却道：“如今学画，才知年少时所不能知的美。”果然，她的画作里有岁月沉淀的韵味，非少年人所能及。
又识得一位老先生，七十高龄开始学习外文。问他何故，他笑言：“想看看外国人写的书，究竟与译本有何不同。”这种求学之乐，岂是年少时为了应试所能体会？
学习从来没有为时已晚之说。三十岁问“为何学习”，得到的答案必然与十岁时不同；五十岁学琴，弹出的旋律自然与十五岁相异；七十岁习画，笔下的意境绝非少年所能及。
每个年岁有每个年岁的领悟，每个阶段有每个阶段的了然。正如树木年轮，每一圈都记录着不同时节的风雨阳光。
所以，不必羞于发问，无论年龄；不必怯于学习，无论早晚。那个小学时没来得及问的问题，现在问出来，或许能得到更深的解答；那个年轻时没学会的技能，现在去学，或许能悟出更妙的门道。
知识的海洋没有岸边，求学的道路没有终点。只要生命还在继续，就有新的东西可学，就有新的境界可至。
愿你永远保持求知的热情，在每个年岁里，都能发现学习的乐趣。毕竟，人生最美好的事情，莫过于永远有机会成为更好的自己。
言诠人问词义时，常有三态：或敷衍了事，或避而不谈，或悉心解说。其中深意，非止于言语往来，更关乎认知深浅。
昔人云：“言之不文，行而不远。”今可续曰：“词之不析，思而不透。”每有友人问词，若只以“大约如此”、“大抵这般”应之，恐是自己也未尝真懂。真知者，必能化繁为简，喻深以浅，使童子亦能了然。
常见人好以大词饰浅见，以玄语掩空虚。殊不知，真正的见识，往往见于对细微之处的把握。若能以具象代抽象，以实例代理论，则不仅听者易明，说者亦自臻明晰。譬如说“美”，不如细描“新月如钩，挂于柳梢”；论“悲”，何如诉说“离人掩面，泪湿青衫”。
语言之妙，不在堆砌辞藻，而在精准达意。每个词语都如一面镜子，映照出使用者的思维图景。若镜面蒙尘，则映照不清；若词语模糊，则思虑必紊。
至于友人间的争辩，更不必回避。小至一字之义，大至天下之事，辩中自有真知。记得与友论“仁”字，初时各执一见，争至面红耳赤。而后互相阐发，参酌古今，终得新解。事后思之，非为争胜负，实为共寻真义。
这些看似琐碎的辩论，实则是将碎片化的认知，编织成完整的思想图景。如同散珠得线，顿时成为璀璨项链。拒绝辩论，往往就是拒绝思考的深化。
苏格拉底街头问答，孔子与弟子坐论，皆在辩论中启迪智慧。今人虽不能至，然于日常交谈间，亦可效法其精神。毋畏争议，毋避疑难，在言语往来间，磨砺思维，淬炼见解。
语言的边界，就是思维的边界。拓展词义，即是拓展心智；明晰表达，即是明晰思想。下次若有人问及词义，不妨视之为共同探索的契机，而非简单的问答。
须知：善解词者，必善思考；善表达者，必善理解。在这言诠往复之间，不仅传递了知识，更开启了智慧之门。
</content>
    <url>/2025/06/19/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%95%A3%E6%96%87%E5%90%88%E9%9B%86/</url>
  </entry>
  <entry>
    <title>日记--无法成功的看板娘</title>
    <content>突发奇想要给博客装一个live2D的看板娘，尝试了一下基本确认是模型本身太复杂导致目前所有的live2D插件都无法兼容，目前兼容最好的是oh-my-live2d，但也依然无法正常显示模型。决定留给日后学习自己制作live2D模型时再做简化。


1. Vtuber Studio 中使用的模型文件Vtuber Studio（以及大多数Vtuber软件如VUP、PrprLive等）使用的Live2D模型通常是一个打包好的成品文件，目的是为了方便导入和运行。

核心文件：
*.cmo3 文件：这是最常见的格式。它是由Live2D Cubism Editor导出的一种整合包，里面已经包含了模型数据（moc3）、纹理（图片）、物理、动作（motion）、表情（expression）等所有必要文件。用户只需要这一个文件即可导入软件。
[模型名称].model3.json：有时软件也会要求这种格式。它本质上是一个模型配置清单文件（JSON格式），但它需要与一个包含所有资源（moc3文件、纹理集、动作等）的文件夹配套使用。


支持文件：
纹理图片（通常是.png格式）
动作文件（.motion3.json）
表情文件（.exp3.json）
物理文件（.physics3.json）
等等。但这些文件通常都被打包在.cmo3里了，用户看不见。



特点：封闭、整合。为了方便普通用户，所有东西都打包在一起，只需一键导入。

2. 个人博客看板娘使用的文件网页端的Live2D看板娘（例如使用hexo-helper-live2d、Live2D Widget等插件）需要被浏览器加载和渲染，因此文件必须是离散的、可被网络请求的。

核心文件：
[模型名称].model3.json：这是必须的！ 它是模型的“说明书”，告诉JavaScript库如何组装这个模型，比如moc文件在哪、贴图用哪张、动作和表情文件有哪些。
*.moc3 文件：这是模型的核心骨骼和变形数据，由Cubism Editor导出，是二进制文件。
纹理图片：通常是.png格式的图片，可能有多张（如texture_00.png, texture_01.png）。
动作文件：.motion3.json 文件，定义了模型的一系列动作。
表情文件：.exp3.json 文件，定义了模型的各种表情。
物理文件：.physics3.json 文件，定义了头发、衣物等部位的物理模拟规则。
其他：可能还包括pose.json（初始姿势）和userdata.json等。



特点：开放、离散。每个文件都是独立的，需要被网页逐个请求加载。

3. 两者有很大的区别吗？有很大的区别，但核心模型数据是相通的。



特性
Vtuber Studio 模型
网页看板娘模型



格式
主要是单一的 .cmo3 整合包
离散的多个文件（.model3.json, .moc3, .png 等）


目的
为桌面软件优化，一键导入
为网络加载优化，可分块请求


使用方式
封闭，用户不直接操作内部文件
开放，需要明确指定每个文件的路径


核心数据
内部包含 .moc3 和纹理
外部需要 .moc3 和纹理文件


简单比喻：

Vtuber Studio的.cmo3 像一个压缩好的.zip安装包，双击就能安装。
网页看板娘 像是一个文件夹里的源代码和资源文件，需要被程序读取并组装。

它们的底层都是Live2D Cubism引擎，所以模型本身（moc3数据）是通用的，只是打包和分发的方式不同。

4. 如何将Vtuber Studio的模型变为博客看板娘？这是最关键的一步。因为你手里只有.cmo3文件，而网页需要离散的文件。你有以下几个选择，按推荐度排序：
如果有原始模型文件（最佳方案）这是最直接、最完美的方法。.cmo3文件是无法反向解包出原始离散文件的。

联系模型师：直接联系为你制作模型的画师或模型师，向他说明你需要将模型用于网页端，请他提供“用于Web发布的模型文件包”。
他会提供什么：一个包含model3.json、.moc3、所有.png贴图、以及motions（动作）文件夹的完整资源包。你只需要把这个文件夹放到你的博客目录下，并在看板娘插件中配置model.json的路径即可。

文件夹结构通常如下：
your_model/├── your_model.model3.json  &amp;lt;-- 这是核心配置文件├── your_model.moc3├── texture_00.png├── texture_01.png└── motions/    ├── idle.motion3.json    ├── tap_body.motion3.json    └── ...


将整个 your_model 文件夹上传到你的博客服务器或博客相关的目录下（例如 /live2d_models/your_model/）。

根据你使用的看板娘插件（如 hexo-helper-live2d），在博客的配置文件中指定模型路径：
live2d:  enable: true  scriptFrom: local  model:    use: your_model # 模型文件夹名称    scale: 0.8  display:    position: right    width: 150    height: 300  mobile:    show: true

插件会自动去找到 /live2d_models/your_model/your_model.model3.json 文件并加载。


文件结构这里以TN_2025Q_V1.0.0模型举例，模型作者：TN酱
核心必需文件（有了这些，看板娘就能正常运行）：

TN_2025Q_V1.0.0.model3.json：这是最重要的配置文件，是网页看板娘的“大脑”，它会告诉加载器如何使用其他所有文件。
TN_2025Q_V1.0.0.moc3：模型的核心骨骼和变形数据。
texture_00.png, texture_01.png, texture_02.png：模型的纹理贴图（皮肤、衣服等）。

增强功能文件（有了这些，看板娘会更生动）：

TN_2025Q_V1.0.0.physics3.json：物理文件，负责让头发、尾巴、衣物等部位产生物理晃动效果。
motions/ 文件夹（虽然你没列出，但 model3.json 里几乎肯定会引用这个文件夹）：里面应该包含了所有的动作文件（.motion3.json），比如 idle（待机）、tap（点击）等动作。

其他文件（与网页看板娘无关，可忽略）：

TN_2025Q_V1.0.0.model.moc：这是旧版 Live2D Cubism 3 的模型文件，新版使用 .moc3，这个文件可以忽略。
TN_2025Q_V1.0.0.cdi3.json：参数定义文件，主要用于在 Live2D Cubism Editor 中编辑或在 Vtuber 软件中设置参数映射，网页端不需要。
TN_2025Q_V1.0.0.vtube.json：专门为 VTube Studio 软件生成的配置文件，包含参数映射、热键设置等，网页端不需要。
TN_2025Q_V1.0.0.xyplugin.json：可能是某个特定插件（如面捕插件）的配置文件，网页端不需要。
items_pinned_to_model.json, package.json：通常是模型编辑项目相关的元数据文件，网页端不需要。

使用 hexo-oh-my-live2d 插件来部署它的步骤。
核心步骤指引
安装插件：在你的 Hexo 博客根目录下，通过 npm 安装 hexo-oh-my-live2d 插件。
放置模型：将你拥有的整个模型文件包（包含 model3.json, moc3, png 等所有文件）放入博客目录中，例如 source/live2d_models/TN_Model/。
配置插件：在 Hexo 的全局配置文件 _config.yml 中添加 OhMyLive2d 字段进行配置，关键是指定本地模型 path。
部署验证：清理并重新生成博客，启动本地服务器查看效果。

详细操作步骤步骤一：安装插件在你的 Hexo 博客根目录下，打开终端（如 Git Bash），运行以下命令安装 hexo-oh-my-live2d 插件：
npm install hexo-oh-my-live2d



步骤二：整理并放置模型文件
在你的 Hexo 博客根目录下，创建一个专门存放模型的文件夹，例如 source/live2d_models/。这样做的好处是当执行 hexo generate 时，该文件夹内的内容会被复制到最终生成的静态网站中。

将你拥有的所有模型文件（TN_2025Q_V1.0.0.model3.json, *.moc3, texture_00.png, texture_01.png, texture_02.png, 以及 motions 文件夹（如果提供的话）等）全部放入刚刚创建的 source/live2d_models/ 文件夹下的一个子文件夹中，例如命名为 TN_Model。
你的博客目录/├── source/│   └── live2d_models/│       └── TN_Model/        ├── TN_2025Q_V1.0.0.model3.json        ├── TN_2025Q_V1.0.0.moc3        ├── TN_2025Q_V1.0.0.physics3.json        ├── TN_2025Q_V1.0.0.cdi3.json        ├── texture_00.png        ├── texture_01.png        ├── texture_02.png        └── motions/            └── idle.motion3.json├── _config.yml└── themes/    └── ayer/

⚠️ 非常重要：请确保 motions 文件夹（包含动作文件）和模型文件在同一目录下，且 TN_2025Q_V1.0.0.model3.json 文件中对这些资源的引用路径是正确的。通常模型师在导出时已经设置好，所以你只需保证所有文件都在同一个文件夹里即可。
步骤三：配置插件打开 Hexo 博客的全局配置文件 _config.yml。通常位于博客的根目录下。
在文件的末尾，添加以下配置段落（注意： 这是 hexo-oh-my-live2d 的配置，不是旧的 hexo-helper-live2d 的配置）：
OhMyLive2d:  enable: true  CDN: https://unpkg.com/oh-my-live2d  option:    dockedPosition: &amp;#x27;left&amp;#x27;    mobileDisplay: false # 改为false        # 尝试使用不同的Cubism版本（解决遮罩兼容性问题）    importType: &amp;#x27;cubism5&amp;#x27; # 专门使用Cubism5版本    libraryUrls:      cubism5: https://registry.npmmirror.com/oh-my-live2d/latest/files/lib/cubism5.js        models:      - path: /live2d_models/TN_Model/TN_2025Q_V1.0.0.model3.json # 修正路径        position: [0, 50] # 调整位置        scale: 0.12 # 调整缩放比例（根据你的模型大小调整）        stageStyle:          width: 320          height: 400        mobilePosition: [0, 30]        mobileScale: 0.08        mobileStageStyle:          width: 200          height: 250        motionPreloadStrategy: IDLE # 改为IDLE，减少初始加载压力        expression: &amp;quot;默认表情&amp;quot;  # 对应表情文件中的Name        # 或者直接指定文件        expressions:        - file: &amp;quot;表情.exp3.json&amp;quot;          name: &amp;quot;默认表情&amp;quot;            parentElement: document.body    primaryColor: &amp;#x27;var(--btn-bg)&amp;#x27;    sayHello: false    tips:      style:        width: 230        height: 120        left: calc(50% - 20px)        top: -100px      mobileStyle:        width: 180        height: 80        left: calc(50% - 30px)        top: -100px      idleTips:        interval: 3600        message:          - 你好呀，我是你的看板娘~          - 欢迎来到我的博客~

创建基础动作文件创建 motions 文件夹，并在其中创建 idle.motion3.json：
&amp;#123;  &amp;quot;Version&amp;quot;: 3,  &amp;quot;Meta&amp;quot;: &amp;#123;    &amp;quot;Duration&amp;quot;: 10,    &amp;quot;Fps&amp;quot;: 30.0,    &amp;quot;Loop&amp;quot;: true,    &amp;quot;AreBeziersRestricted&amp;quot;: true,    &amp;quot;CurveCount&amp;quot;: 0,    &amp;quot;UserDataCount&amp;quot;: 0,    &amp;quot;TotalSegmentCount&amp;quot;: 0,    &amp;quot;TotalPointCount&amp;quot;: 0,    &amp;quot;FadeInTime&amp;quot;: 1.0,    &amp;quot;FadeOutTime&amp;quot;: 1.0  &amp;#125;,  &amp;quot;Curves&amp;quot;: []&amp;#125;

快速修复脚本创建一个修复脚本 fix_model.js：
const fs = require(&amp;#x27;fs&amp;#x27;);const path = require(&amp;#x27;path&amp;#x27;);// 读取模型文件const modelPath = path.join(__dirname, &amp;#x27;source&amp;#x27;, &amp;#x27;live2d_models&amp;#x27;, &amp;#x27;TN_Model&amp;#x27;, &amp;#x27;TN_2025Q_V1.0.0.model3.json&amp;#x27;);const modelData = JSON.parse(fs.readFileSync(modelPath, &amp;#x27;utf8&amp;#x27;));// 修复纹理路径if (modelData.FileReferences &amp;amp;&amp;amp; modelData.FileReferences.Textures) &amp;#123;  modelData.FileReferences.Textures = modelData.FileReferences.Textures.map(texturePath =&amp;gt; &amp;#123;    return texturePath.replace(&amp;#x27;TN_2025Q_V1.0.0.4096/&amp;#x27;, &amp;#x27;&amp;#x27;);  &amp;#125;);&amp;#125;// 添加基础动作if (!modelData.Motions) &amp;#123;  modelData.Motions = &amp;#123;    &amp;quot;idle&amp;quot;: [      &amp;#123;        &amp;quot;File&amp;quot;: &amp;quot;motions/idle.motion3.json&amp;quot;      &amp;#125;    ]  &amp;#125;;&amp;#125;// 保存修复后的文件fs.writeFileSync(modelPath, JSON.stringify(modelData, null, 2));console.log(&amp;#x27;模型文件修复完成&amp;#x27;);// 创建motions文件夹和基础动作文件const motionsDir = path.join(__dirname, &amp;#x27;source&amp;#x27;, &amp;#x27;live2d_models&amp;#x27;, &amp;#x27;TN_Model&amp;#x27;, &amp;#x27;motions&amp;#x27;);if (!fs.existsSync(motionsDir)) &amp;#123;  fs.mkdirSync(motionsDir, &amp;#123; recursive: true &amp;#125;);&amp;#125;const idleMotion = &amp;#123;  &amp;quot;Version&amp;quot;: 3,  &amp;quot;Meta&amp;quot;: &amp;#123;    &amp;quot;Duration&amp;quot;: 10,    &amp;quot;Fps&amp;quot;: 30.0,    &amp;quot;Loop&amp;quot;: true,    &amp;quot;AreBeziersRestricted&amp;quot;: true,    &amp;quot;CurveCount&amp;quot;: 0,    &amp;quot;UserDataCount&amp;quot;: 0,    &amp;quot;TotalSegmentCount&amp;quot;: 0,    &amp;quot;TotalPointCount&amp;quot;: 0,    &amp;quot;FadeInTime&amp;quot;: 1.0,    &amp;quot;FadeOutTime&amp;quot;: 1.0  &amp;#125;,  &amp;quot;Curves&amp;quot;: []&amp;#125;;fs.writeFileSync(path.join(motionsDir, &amp;#x27;idle.motion3.json&amp;#x27;), JSON.stringify(idleMotion, null, 2));console.log(&amp;#x27;基础动作文件创建完成&amp;#x27;);



运行这个脚本：
node fix_model.js



测试修复结果修复后，在浏览器控制台运行这个测试：
// 测试修复后的模型fetch(&amp;#x27;/live2d_models/TN_Model/TN_2025Q_V1.0.0.model3.json&amp;#x27;)  .then(response =&amp;gt; response.json())  .then(modelData =&amp;gt; &amp;#123;    console.log(&amp;#x27;修复后检查:&amp;#x27;);    console.log(&amp;#x27;纹理路径:&amp;#x27;, modelData.FileReferences.Textures);    console.log(&amp;#x27;是否有动作:&amp;#x27;, !!modelData.Motions);        // 测试纹理加载    modelData.FileReferences.Textures.forEach((texture, index) =&amp;gt; &amp;#123;      fetch(&amp;#x27;/live2d_models/TN_Model/&amp;#x27; + texture)        .then(response =&amp;gt; &amp;#123;          console.log(`纹理 $&amp;#123;texture&amp;#125;: $&amp;#123;response.status === 200 ? &amp;#x27;可访问&amp;#x27; : &amp;#x27;不可访问&amp;#x27;&amp;#125;`);        &amp;#125;)        .catch(error =&amp;gt; &amp;#123;          console.log(`纹理 $&amp;#123;texture&amp;#125;: 加载失败`);        &amp;#125;);    &amp;#125;);  &amp;#125;);



尝试不同的渲染引擎配置在你的配置中尝试不同的Cubism版本：
OhMyLive2d:  enable: true  CDN: https://unpkg.com/oh-my-live2d  option:    # 尝试不同的导入类型    importType: &amp;#x27;complete&amp;#x27;  # 完整版本，兼容性最好    # importType: &amp;#x27;cubism5&amp;#x27;  # 或者尝试Cubism5专用版本    # importType: &amp;#x27;cubism2&amp;#x27;  # 或者尝试旧的Cubism2版本

加载表情文件1.修改模型配置文件（推荐）
在你的 TN_2025Q_V1.0.0.model3.json 文件中添加表情文件引用：
&amp;#123;  &amp;quot;Version&amp;quot;: 3,  &amp;quot;FileReferences&amp;quot;: &amp;#123;    &amp;quot;Moc&amp;quot;: &amp;quot;TN_2025Q_V1.0.0.moc3&amp;quot;,    &amp;quot;Textures&amp;quot;: [      &amp;quot;texture_00.png&amp;quot;,      &amp;quot;texture_01.png&amp;quot;,       &amp;quot;texture_02.png&amp;quot;    ],    &amp;quot;Physics&amp;quot;: &amp;quot;TN_2025Q_V1.0.0.physics3.json&amp;quot;,    &amp;quot;DisplayInfo&amp;quot;: &amp;quot;TN_2025Q_V1.0.0.cdi3.json&amp;quot;,    // 添加表情文件引用    &amp;quot;Expressions&amp;quot;: [      &amp;#123;        &amp;quot;Name&amp;quot;: &amp;quot;默认表情&amp;quot;,        &amp;quot;File&amp;quot;: &amp;quot;表情.exp3.json&amp;quot;      &amp;#125;    ]  &amp;#125;,  &amp;quot;Groups&amp;quot;: [    // ... 你现有的Groups内容 ...  ],  &amp;quot;Motions&amp;quot;: &amp;#123;    &amp;quot;idle&amp;quot;: [      &amp;#123;        &amp;quot;File&amp;quot;: &amp;quot;motions/idle.motion3.json&amp;quot;      &amp;#125;    ]  &amp;#125;,  // 添加表情配置  &amp;quot;Expressions&amp;quot;: [    &amp;#123;      &amp;quot;Name&amp;quot;: &amp;quot;默认表情&amp;quot;,       &amp;quot;File&amp;quot;: &amp;quot;表情.exp3.json&amp;quot;    &amp;#125;  ]&amp;#125;

2.通过插件配置加载表情
检查 oh-my-live2d 是否支持直接加载表情文件：
OhMyLive2d:  enable: true  option:    models:      - path: /live2d_models/TN_Model/TN_2025Q_V1.0.0.model3.json        scale: 0.1        # 尝试通过配置加载表情        expression: &amp;quot;默认表情&amp;quot;  # 对应表情文件中的Name        # 或者直接指定文件        expressions:          - file: &amp;quot;表情.exp3.json&amp;quot;            name: &amp;quot;默认表情&amp;quot;    display:      position: right

3.手动初始化模型参数
如果插件不支持直接加载表情，可以通过JavaScript在模型加载后手动应用表情：
创建一个自定义脚本文件 source/js/live2d-custom.js：
document.addEventListener(&amp;#x27;DOMContentLoaded&amp;#x27;, function() &amp;#123;  // 等待Live2D加载完成  const checkLive2D = setInterval(function() &amp;#123;    if (window.OhMyLive2D &amp;amp;&amp;amp; window.OhMyLive2D.instances.length &amp;gt; 0) &amp;#123;      clearInterval(checkLive2D);      applyExpression();    &amp;#125;  &amp;#125;, 500);    function applyExpression() &amp;#123;    const instance = window.OhMyLive2D.instances[0];        // 加载并应用表情文件    fetch(&amp;#x27;/live2d_models/TN_Model/表情.exp3.json&amp;#x27;)      .then(response =&amp;gt; response.json())      .then(expression =&amp;gt; &amp;#123;        console.log(&amp;#x27;加载表情文件成功&amp;#x27;, expression);                // 应用表情参数到模型        if (instance.model &amp;amp;&amp;amp; instance.model.setExpression) &amp;#123;          instance.model.setExpression(expression);        &amp;#125; else &amp;#123;          // 如果插件没有暴露API，尝试直接设置参数          applyExpressionParameters(expression, instance);        &amp;#125;      &amp;#125;)      .catch(error =&amp;gt; &amp;#123;        console.error(&amp;#x27;加载表情文件失败:&amp;#x27;, error);      &amp;#125;);  &amp;#125;    function applyExpressionParameters(expression, instance) &amp;#123;    // 手动应用表情参数    if (expression.Parameters &amp;amp;&amp;amp; instance.model.coreModel) &amp;#123;      expression.Parameters.forEach(param =&amp;gt; &amp;#123;        try &amp;#123;          instance.model.coreModel.setParameterValueById(param.Id, param.Value);        &amp;#125; catch (e) &amp;#123;          console.log(&amp;#x27;设置参数失败:&amp;#x27;, param.Id, e);        &amp;#125;      &amp;#125;);      // 强制重绘      instance.model.update(0);    &amp;#125;  &amp;#125;&amp;#125;);

然后在主题布局文件中引入这个脚本。
依然存在的问题解决了兼容性、配置等等的问题，依然绕不开模型过于无法无法使用的问题，于是这里放弃

模型使用了高级的遮罩功能（mask count 20-21），但当前渲染器不支持
WebGL着色器程序设置失败，导致无法渲染模型
hexo-helper-live2d（经典插件）也无法兼容

修改遮罩数量的可行性
需要的工具

Live2D Cubism Editor（官方编辑器，付费软件）
或者 第三方工具（如社区开发的转换工具）

修改步骤（技术复杂）

使用Cubism Editor打开模型：
导入你的 .model3.json 文件
在”蒙版”或”遮罩”设置中调整数量
重新导出为网页兼容格式


技术挑战：
遮罩数量与模型复杂度直接相关
减少遮罩可能导致渲染效果丢失
需要重新调整材质和绘制顺序



如果确实需要修改模型，可以尝试：

使用Cubism Viewer（免费工具）：
下载Cubism Viewer
导入模型查看基本兼容性
尝试导出简化版本


在线转换服务：
搜索”Live2D模型转换”或”Live2D web兼容性转换”
有些社区提供转换服务



最终备份
OhMyLive2d:  enable: true  CDN: https://unpkg.com/oh-my-live2d  option:    # 尝试不同的导入类型    #importType: &amp;#x27;complete&amp;#x27;  # 完整版本，兼容性最好    # importType: &amp;#x27;cubism5&amp;#x27;  # 或者尝试Cubism5专用版本    # importType: &amp;#x27;cubism2&amp;#x27;  # 或者尝试旧的Cubism2版本    importType: &amp;#x27;cubism5&amp;#x27; # 专门使用Cubism5版本    libraryUrls:       #complete: https://registry.npmmirror.com/oh-my-live2d/latest/files/lib/complete.js       #cubism2: https://registry.npmmirror.com/oh-my-live2d/latest/files/lib/cubism2.js      cubism5: https://registry.npmmirror.com/oh-my-live2d/latest/files/lib/cubism5.js        # 如果插件支持，添加渲染器配置    renderer:      type: &amp;#x27;pixi&amp;#x27;  # 或者 &amp;#x27;webgl&amp;#x27;, &amp;#x27;canvas&amp;#x27;          models:      - path: /live2d_models/TN_Model/TN_2025Q_V1.0.0.model3.json # 修正路径        position: [0, 50] # 调整位置        scale: 0.12 # 调整缩放比例（根据你的模型大小调整）        stageStyle:          width: 320          height: 400        mobilePosition: [0, 30]        mobileScale: 0.08        mobileStageStyle:          width: 200          height: 250        motionPreloadStrategy: IDLE # 改为IDLE，减少初始加载压力        expression: &amp;quot;默认表情&amp;quot;  # 对应表情文件中的Name        # 或者直接指定文件        expressions:        - file: &amp;quot;馍馍.exp3.json&amp;quot;          name: &amp;quot;默认表情&amp;quot;            parentElement: document.body    primaryColor: &amp;#x27;var(--btn-bg)&amp;#x27;    sayHello: false    tips:      style:        width: 230        height: 120        left: calc(50% - 20px)        top: -100px      mobileStyle:        width: 180        height: 80        left: calc(50% - 30px)        top: -100px      idleTips:        interval: 3600        message:          - 你好呀，我是你的看板娘~          - 欢迎来到我的博客~





另：live2D模型文件包打包到https://unpkg.com
核心条件：你的文件必须在一个 npm 包中unpkg.com` 是一个为 **npm** 生态系统提供服务的 CDN。它的工作流程是：`unpkg.com/:package@:version/:file


:package: npm 上的包名
:version: 包的版本号 (或 latest)
:file: 包内的具体文件路径

因此，最关键的一步是：你必须将你的 Live2D 模型文件发布到一个 npm 包中。
如果你没有 npm 账号，先去 npmjs.com 注册一个。

操作步骤1. 准备你的 Live2D 模型文件和 package.json创建一个新文件夹，例如 my-live2d-model。

放入文件：将你的 Live2D 模型文件（如 .model3.json, .moc3, .png 等纹理文件, .physics3.json 等）放入这个文件夹。保持原有的文件结构非常重要，因为 JSON 文件中的路径是相对的。

**创建 package.json**：在这个文件夹根目录下运行 npm init 并按照提示填写信息。或者手动创建一个 package.json 文件，内容最少需要包含：
&amp;#123;  &amp;quot;name&amp;quot;: &amp;quot;my-live2d-model&amp;quot;, // 取一个独一无二的包名，先在 npm 上搜索是否被占用  &amp;quot;version&amp;quot;: &amp;quot;1.0.0&amp;quot;,        // 版本号  &amp;quot;main&amp;quot;: &amp;quot;index.js&amp;quot;,        // 这个对于模型文件不是必须的，但必须要有。可以随便指向一个文件。  &amp;quot;description&amp;quot;: &amp;quot;My Live2D model package&amp;quot;&amp;#125;

package.json
&amp;#123;  &amp;quot;name&amp;quot;: &amp;quot;tn2025q&amp;quot;,  &amp;quot;version&amp;quot;: &amp;quot;1.0.0&amp;quot;,  &amp;quot;description&amp;quot;: &amp;quot;My Live2D model package&amp;quot;,  &amp;quot;main&amp;quot;: &amp;quot;index.js&amp;quot;,  &amp;quot;scripts&amp;quot;: &amp;#123;    &amp;quot;test&amp;quot;: &amp;quot;echo \&amp;quot;Error: no test specified\&amp;quot; &amp;amp;&amp;amp; exit 1&amp;quot;  &amp;#125;,  &amp;quot;keywords&amp;quot;: [],  &amp;quot;author&amp;quot;: &amp;quot;&amp;quot;,  &amp;quot;license&amp;quot;: &amp;quot;ISC&amp;quot;&amp;#125;

你的目录结构应该看起来像这样：
my-live2d-model/├── package.json├── shizuku.model3.json├── shizuku.moc3├── shizuku.physics3.json├── textures/│   └── texture_00.png└── index.js (可选)

检查包名是否可用在发布前，先检查包名是否可用：
npm view tn2025q

如果返回 404，表示包名可用；如果返回包信息，则需要选择其他名称。
2. 发布到 npm
在终端中，进入你的项目文件夹 my-live2d-model。
运行 npm login 登录你的账号。
运行 npm publish 发布你的包。

发布成功后，你的包就可以在 npm 上搜索到了。
npm 包名必须符合以下要求：

包名长度应大于零
所有字符必须是小写字母
可以包含连字符、数字和下划线，但不能以它们开头或结尾
不能包含任何非URL安全字符（因为包名会出现在URL中）
不能与现有包名重复

3. 构建 unpkg URL现在，你可以使用 unpkg 来访问你的文件了。
npm i tn2025qnpm install --save tn2025q



oh-my-live2d
在-hexo-中使用
https://zhuanlan.zhihu.com/p/98597931
https://mugaiashe.github.io/posts/82785c10.html
https://blog.phlin.cn/2024/08/25/live2d-using/
https://blog.empty-city.top/posts/de3e4889/index.html
https://makkishizu.github.io/2024/11/28/Live2D/
</content>
    <url>/2025/09/22/%E6%97%A5%E8%AE%B0-%E6%97%A0%E6%B3%95%E6%88%90%E5%8A%9F%E7%9A%84%E7%9C%8B%E6%9D%BF%E5%A8%98/</url>
  </entry>
  <entry>
    <title>日记角</title>
    <content>新开了一个日记角，有什么日记都会丢进这里
【FlowUs 息流】♪♫日记角♩♬

</content>
    <url>/2025/10/07/%E6%97%A5%E8%AE%B0%E8%A7%92/</url>
  </entry>
  <entry>
    <title>有关设计到代码、可视化开发与低代码或无代码建站的技术总结</title>
    <content>注意到Canva可画的设计图直接建站的技术十分新奇，打算特地研究一下。
核心概念
设计到代码（Design-to-Code）：最直接的描述，指将视觉设计稿自动转换为前端代码（HTML&amp;#x2F;CSS&amp;#x2F;JS）的技术。
可视化开发（Visual Development）：通过拖拽、配置等可视化操作生成页面，无需手动编码。
低代码&amp;#x2F;无代码建站（Low-code&amp;#x2F;No-code Website Builder）：通过预设模块和逻辑快速搭建网站，Canva属于典型的无代码工具。



类似产品：Webflow、Framer、Wix Editor X等专业可视化网页工具。
关键差异：可画更侧重“平面设计感”的用户体验，而Webflow等更强调代码级控制。
技术实现原理结构化设计约束：Canva可画的设计工具并非完全自由的“PS式”操作，而是基于栅格、组件和响应式规则，保证设计可被系统解析。
组件化映射：每个设计元素（如按钮、文本框）对应一个前端组件库中的预置组件，生成的是结构化的代码而非图片转译。
CSS Grid&amp;#x2F;Flexbox 布局生成：系统根据用户布局自动生成符合现代标准的响应式CSS代码。
静态站点生成（SSG）：部署时，系统将设计数据编译为优化的静态HTML&amp;#x2F;CSS&amp;#x2F;JS文件，并托管到CDN。
局限性输出类型：通常生成静态页面（MPA），复杂交互需嵌入第三方工具。
代码可控性：生成的代码可能不够语义化或难以深度定制。
SEO优化：相比手动开发的网站，自动化工具生成的网站在SEO结构化数据等方面可能存在限制。
考虑到有些网站类型就需要无代码开发和MPA，Canva可画的技术已十分成熟，可以扩展到其他赛道。
其他竞品对比：



设计师转网页：Canva、Wix Editor X
创业者&amp;#x2F;营销人：Carrd、Typedream（快速上线）
前端开发者：Webflow、Framer、Builder.io
企业团队：Figma+Anima、Webflow Enterprise
开源自建：GrapesJS

首选推荐GrapesJS
定位：最成熟、功能最全面的开源网页构建器框架。
特点：
模块化设计，通过插件扩展一切（组件、样式、代码生成、存储等）。
默认生成干净的HTML&amp;#x2F;CSS，可通过插件生成React&amp;#x2F;Vue&amp;#x2F;等。
拥有完整的画布、图层管理、样式面板、组件库。
社区活跃，有丰富的第三方插件。


开源地址：https://github.com/GrapesJS/grapesjs
行动建议：这是你想自己打造一个“类Canva设计转代码网站”的绝对首选起点。克隆仓库，运行Demo，然后研究其插件机制，开始定制你自己的组件和代码生成器。

umbrella
定位：一个现代化的开源网站构建器，设计美观，技术栈较新（TypeScript, SolidJS）。
特点：相对GrapesJS更轻量、更现代，但功能和生态还在成长中。适合喜欢前沿技术栈的开发者。
开源地址：https://github.com/learn-anything/umbrella

Appsmith &amp;#x2F; ToolJet
定位：开源的低代码平台，主要用来构建内部管理后台（连接数据库、API）。
特点：它们的UI构建部分本质也是设计转代码（生成JSON配置或React代码）。如果你想做的工具偏向企业级、数据驱动的应用，可以参考它们的UI构建器实现。
开源地址：https://github.com/appsmithorg/appsmith, https://github.com/ToolJet/ToolJet

</content>
    <url>/2026/01/30/%E6%9C%89%E5%85%B3%E8%AE%BE%E8%AE%A1%E5%88%B0%E4%BB%A3%E7%A0%81%E3%80%81%E5%8F%AF%E8%A7%86%E5%8C%96%E5%BC%80%E5%8F%91%E4%B8%8E%E4%BD%8E%E4%BB%A3%E7%A0%81%E6%88%96%E6%97%A0%E4%BB%A3%E7%A0%81%E5%BB%BA%E7%AB%99%E7%9A%84%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/</url>
  </entry>
  <entry>
    <title>存在的天平--心理与哲学的交汇</title>
    <content>本文旨在探索心理学与哲学的交叉领域，分析它们如何相辅相成地揭示人类思维与行为的本质。
（非专业，非专业，非专业！主观观点较多，甚至包含原创结合心理学与哲学两者的思维模型，请谨慎查阅和参考。）


引言通过近几年课余时间对心理学相关书籍的深入阅读，有所新的发现：心理学通常以人类的外在行为为依据、探究心理现象及其发生发展规律。然而，人类的心理活动复杂且隐秘，仅仅依靠外在的说与做，我们还是难以直接知晓自己和他人的想法。当前的心理学相关的内容得到的结果也多是对行为的总结，而非直接揭示心理原因。
第一章：理论基础1.1当今存在理论的单一性哲学理论：
存在主义、虚无主义、唯物主义、唯心主义、葛多斯主义
心理学理论：
PTSD、自恋型人格障碍、回避型人格依恋、
荣格八维、九型人格、大五人格测试、霍兰德职业测试、以及娱乐的十六人格理论。
仔细看过这些理论，会发现，当前主流心理学测试多聚焦行为总结，哲学多聚焦于精神，而涉及较为全面且深入一点的荣格八维理论，虽然分析了精神方面的部分内容和外在的部分表现，但依然侧重于精神的主观能动性，没有结合物质现实中精神科真正会遇到的现象来讨论。
这些理论无一不只聚焦了人的单一层面，几乎没有问题会结合黄金圈法则中三者均考虑到的问题。
1.1.1理性与感性的传统定义理性‌的定义是：指一个人在处理问题时，能够冷静、客观地分析情况，基于现有的理论和合理的逻辑推导来做出决策。理性的人通常具有自信和勇气，能够冷静地面对现状，全面了解现实情况，分析出多种可行性方案，并判断出最佳方案且有效执行。理性的特征包括冷静的态度、全面的认识、详细的分析和后果的预知。它强调逻辑思维和客观分析，避免情感干扰，是评判一个人或社会精神面貌高低质量的重要指标。‌
感性‌的定义：指一个人在处理问题时，更多地依赖于个人的情感和直觉，而不是逻辑推理。感性的人通常情感丰富，容易多愁善感，对别人的遭遇会感同身受，感受力很强，并能体会到事物的情感变化。他们在待人处事过程中，更遵从自己的内心感受，习惯于从自己的想法出发，而较少考虑客观条件。感性的特征包括情感丰富、重视人际关系和谐、容易感情用事等。‌
关于理性和感性的定义，笔者认为：它们实际上描述的是人的外在表现，而非思维本身。同理，性格和人格的描述也多聚焦于外在行为表现。
既然理性与感性其实是在描述人的外在表现而不是在描述人的思维，那么，性格呢？人格呢？是否也是在描述一个人的外在行为表现？
1.1.2理性与感性的重新定义截止目前笔者的结论为：

哲学更侧重于对深层意识与存在意义的追问，而心理学通过行为推断心理机制，两者共同构成对人类心灵的完整认知。

理性与感性形容的都是一个人的外在表现。


理性 ：指那些依据严谨的逻辑推理、客观的分析以及深思熟虑后所做出的行为或展现出的样子，会给人带来一种冷静、理智且合理的感受。
感性 ：意味着凭借自身的情感起伏、瞬间的直觉以及个人内心的感受来行事或呈现的状态，会使人在接触时感受到其中蕴含的丰富情感与独特的个人主观体验。
而【如何思考哲学中的问题】才是人的内心深处，人的内在思想与性格应该用【唯心主义】【唯物主义】【现实主义】【虚无主义】等等哲学词汇来形容。
一个有个人独立意识的人类应当是以思考哲学问题为起点，以在社会中实际行动为目的与结果的。



传统定义
作者新定义



理性&amp;#x3D;逻辑分析思维
理性&amp;#x3D;基于逻辑的外在行为表现


感性&amp;#x3D;情感驱动思维
感性&amp;#x3D;情感驱动的状态呈现


1.1.3哲学理论的片面性1.1.4荣格的八维理论在讲述荣哥的八维理论之前，首先需要明确：
荣格本人从未提出过“16型人格”这个概念。所谓的“MBTI 16型人格”确实是后人（凯瑟琳·布里格斯和伊莎贝尔·布里格斯·迈尔斯母女）基于荣格的心理类型理论发展出来的、高度简化和类型化的工具，它更侧重于分类和标签，在学术严谨性和深度上远不及荣格的原著理论或后续的分析心理学发展（如毕比的理论）。 这种简化使其更易于传播和商业化，但也丢失了荣格理论中关于心理动力、发展和个体独特性的核心精髓。
完全摒弃MBTI的16型框架，专注于荣格的原始八维概念以及毕比等分析心理学家对其的深化和发展。
1.1.4.1荣格八维的核心概念（基于荣格《心理类型》）
荣格认为，人类意识通过特定的心理功能来理解和应对外部世界及内心世界。他区分了两种基本态度和四种基本功能，组合形成了八种心理类型&amp;#x2F;功能态度：

两种基本态度：
外倾： 心理能量的流动主要指向外部世界（人、事、物、环境）。兴趣和注意力主要集中在外在客体上，行为受外部因素影响较大。
内倾： 心理能量的流动主要指向内心世界（想法、感受、内在意象）。兴趣和注意力主要集中在内在体验上，行为受内在因素（价值观、理解）影响较大。


四种基本功能：
理性功能（判断功能）： 用于做出决定和判断。
思维： 关注逻辑、因果关系、客观真理、原则和结构。目标是理解事物如何运作以及什么是正确的。
情感： 关注价值、关系、和谐、同理心和个人或群体的重要性。目标是评估事物是否令人愉悦、有价值或值得关注（注意：荣格说的“情感”是价值判断功能，不是情绪&amp;#x2F;情绪化）。


非理性功能（感知功能）： 用于收集信息和感知。
感觉： 关注通过五官（视、听、触、味、嗅）直接感知到的具体、实在的信息。关注“是什么”，当下的、实际的事实细节。
直觉： 关注可能性、模式、联系、潜在含义和未来趋势。关注“可能是什么”，从无意识中接收到的印象和整体图景。




八种功能态度：将四种基本功能分别与两种基本态度结合，就形成了荣格提出的八种心理功能类型：
外倾思维： 思维过程由外部客观事实、数据和逻辑规则主导。关注构建外部世界的逻辑体系和客观真理。实用、分析、有条理。
内倾思维： 思维过程由内在的主观理念和逻辑结构主导。关注发展深刻、连贯的内在理论框架。独立、反思、概念化。
外倾情感： 情感判断由外部情境、社会规范和人际和谐主导。关注建立和维持外部关系与群体价值。适应性强、善交际、重视和谐。
内倾情感： 情感判断由内在的、深层的、个人化的价值标准主导。情感体验深刻但通常不外显。关注内在的和谐与一致性。真挚、有深度、价值观坚定。
外倾感觉： 感知主要聚焦于外部世界的具体感官刺激和即时体验。关注当下、现实、享受具体事物。实际、享乐、注重细节。
内倾感觉： 感知主要聚焦于内在的主观感官印象和对过去的体验记忆。关注事物的内在品质和个体化的感受。安静、怀旧、有强烈的个人审美。
外倾直觉： 感知主要聚焦于外部世界蕴含的多种可能性、新联系和潜在机遇。关注变化、新事物、未来的潜力。充满创意、有远见、容易厌倦。
内倾直觉： 感知主要聚焦于内在无意识涌现的原型、意象和未来的内在图景。关注洞见、象征意义和内在的“灵光一现”。神秘、有洞察力、关注内在模式。



荣格理论的关键点（与MBTI的核心区别）：

主导功能与辅助功能： 荣格认为，在个体身上，这八种功能并非同等发展或使用。每个人通常有一个主导功能（最发达、最常使用的功能态度），一个辅助功能（发展次之，用于支持主导功能，通常是另一个“轴”上的功能，如理性主导则辅助常为感知功能，反之亦然），一个第三功能（发展较弱），和一个劣势功能（最不发达、常处于无意识中，常与主导功能态度相反）。功能的发展是动态的、个体化的。
发展与分化： 荣格强调心理类型是动态的、发展的。个体一生都在努力发展和整合各种功能，特别是劣势功能（个体化过程的一部分）。健康的心理状态是功能分化良好并能灵活运用的状态。
个体独特性： 八维框架是理解心理结构的工具，但绝不意味着把人塞进8个或16个僵化的盒子里。每个人功能组合的强度、发展顺序、整合程度都不同，加上个人经历、文化等因素，使得个体心理极其独特和复杂。荣格反对机械的类型划分。
无意识与阴影： 不发达的功能（特别是劣势功能）通常存在于个人无意识或集体无意识中，构成阴影。它们可能以笨拙、幼稚、甚至破坏性的方式表现出来。认识和整合阴影是心理成长的重要部分。
功能轴（毕比理论的桥梁）： 虽然荣格没有明确提出“轴”的概念，但后人（包括毕比）观察到思维-情感、感觉-直觉这两对功能是相互补偿和对立的，形成两条轴线。一个人在这两条轴线上通常有一个偏好（如思维&amp;gt;情感，或感觉&amp;gt;直觉），但主导功能和态度决定了具体表现。

1.1.4.2约翰·毕比对荣格八维理论的深化与发展约翰·毕比（John Beebe）作为杰出的荣格派分析师，对八维理论做出了极其重要的贡献，使其更具临床应用价值和动态性。他的核心理论是八种功能原型：

核心观点： 毕比认为，荣格提出的八种功能态度不仅仅是我们有意识使用的工具，它们各自在我们的人格结构中扮演着特定的原型角色，具有特定的能量、意图和行为模式。这些原型角色共同构成了一个动态的人格系统。
八种功能原型角色： 毕比将八种功能态度（如Ti, Fe, Se, Ni等）分别赋予了以下原型角色（通常按意识程度&amp;#x2F;发展程度排序）：
英雄&amp;#x2F;女英雄： 主导功能。这是我们最信赖、最强大的功能，是我们有意识身份的基石。我们用它来面对世界，实现目标。它代表我们的核心力量和自信来源。
父母&amp;#x2F;父亲： 辅助功能。这是我们的支持性、养育性功能。我们用它来照顾他人（外在父母）或照顾自己内在的需求（内在父母），提供指导和支持。它代表我们的责任感和关怀能力。
永恒少年&amp;#x2F;少女： 第三功能。这个功能带有一种年轻、有魅力、充满潜力或创造性的特质，但也可能不成熟、不可靠。它代表我们的好奇心、灵感和适应新事物的能力，但也可能是我们逃避责任的出口。
阿尼玛&amp;#x2F;阿尼姆斯： 劣势功能。这是与主导功能对立的、处于意识最底层的功能（如主导是Ti，劣势就是Fe）。它连接着无意识，常以投射（将自身特质归因于他人）或情绪化的方式表现出来。整合它是通往无意识宝藏（阿尼玛&amp;#x2F;阿尼姆斯）和完整人格的关键。它代表我们未开发的潜能和最大的成长挑战。
对立人格： 第五功能（与辅助功能同类型但态度相反）。常以批判、防御或竞争的方式出现，感觉像是内在的“反对派”或外在的“敌人”。代表我们未整合的阴影部分，常引发冲突。
老巫&amp;#x2F;老贤者： 第六功能（与第三功能同类型但态度相反）。可能表现为负面的、破坏性的建议（老巫），也可能在危机时刻提供深刻的智慧（老贤者）。代表更深层的、有时是阴暗的智慧。
骗子： 第七功能（与英雄功能同类型但态度相反）。具有颠覆性、解构性，能戳破自大和虚伪。可能表现为自我破坏、恶作剧或深刻的幽默感，提醒我们不要过于严肃。代表打破僵化的模式。
恶魔： 第八功能（与父母功能同类型但态度相反）。这是最原始、最无意识的阴影功能。常与最深层的恐惧、破坏性、生存本能或最不愿面对的东西相关。在极端压力下可能以毁灭性的方式爆发。代表我们最原始的、需要极大努力才能转化的黑暗面。



毕比理论的核心贡献：

赋予功能动态角色： 将静态的功能描述转化为活跃的、具有心理动力的角色，解释了它们在人格内部如何互动（合作、冲突、补偿）。
强调阴影与整合： 极大地深化了对阴影（特别是第五到第八功能）的理解，强调了整合劣势功能（第四功能）对于个体化（自性实现）的极端重要性。
解释内在冲突与外在关系： 功能原型模型能很好地解释个体内在的心理冲突、防御机制，以及人际关系中的投射、吸引和冲突模式（如对立人格、阿尼玛&amp;#x2F;阿尼姆斯投射）。
提供发展路径图： 清晰地描绘了心理发展的路径：从依赖英雄功能，到发展父母功能，再到接触永恒少年&amp;#x2F;少女的潜力，最终直面和整合劣势功能（阿尼玛&amp;#x2F;阿尼姆斯），并逐步认识和管理更深层的阴影功能（第五到第八功能）。
更贴近临床实践： 为荣格派分析师提供了理解个案心理结构、动力和干预方向的有力工具。

【注】“16人格”是MBTI对荣格理论的简化、类型化和商业化产物，它丢失了荣格理论中关于心理动力、发展、个体独特性和无意识的核心内涵，其专业性在深度心理学领域确实常受质疑。
荣格八维（心理功能态度） 是理解个体心理运作方式的基础结构框架。
毕比的功能原型理论 是对荣格八维的革命性深化和发展，将其从描述性分类提升到了理解人格动态结构、内在冲突与发展路径的层面，具有极高的专业深度和临床价值。
摒弃娱乐化与商业化的“16人格”，专注于荣格的原著（特别是《心理类型》）以及毕比等荣格派分析师的后续发展（如毕比的《类型与原型》），才是真正深入理解心理类型理论、避免MBTI标签化局限的最佳途径。
1.1.4.3荣格八维理论的片面性荣格理论最受争议的深层矛盾：个体心灵自由意志与社会压迫之间的张力。荣格更聚焦个体内在动力，较为忽视环境压迫。
荣格的“被迫人格”盲区：四个理论局限

过度强调“心灵自主性”

荣格认为即使在外界压迫下，心灵仍有创造性适应能力（如被虐待儿童通过幻想创造内在保护者）。但他低估了系统性暴力（如贫困、歧视）对心灵结构的根本性摧毁——当生存资源被剥夺时，心理功能根本无暇“自性化”。

对“阴影”来源的简化

他将阴影视为个人无意识的产物，但现实中：

母亲的控制欲可能源于父权社会对单亲母亲的污名化（集体阴影内化）
讨好型Fe本质是资本主义将人际关系工具化的缩影“被迫人格”常是集体创伤的个体显形。


整合命题的精英主义倾向

荣格假设人人都有“自性化”的心理资源，但：

流水线工人每日劳作12小时后如何觉察功能失衡？
被债主追杀的贫民如何发展劣势功能？生理与安全需求的匮乏会直接关闭高阶心理进程。

1.1.4.4针对荣格理论提出改进建议
荣格思想中被忽略的“被迫性”洞察
尽管有局限，荣格某些理论仍暗含对被迫人格的解释：

人格面具（Persona）的窒息性
他提出：社会角色（如“孝子”“贤妻”）会压迫真实自我，形成假性人格——这正是你案例中“孩子被迫迎合母亲”的机制。
关键洞见：当面具与自性冲突过大，人会陷入精神崩溃或极端反抗（如孩子宣称“理想大于生命”）。


集体无意识的压迫性传承
母亲A对“整齐”的病态执着，可能承袭自战乱中祖辈的生存经验（混乱&amp;#x3D;死亡），这种代际创伤会以功能僵化（Se过度发展）的形式强制重演。


心理能量（Libido）的被迫转移当外部环境封锁某功能通道（如男生E的Fe付出被践踏），心理能量会暴力转向对立功能（Fi自我封闭），荣格称之为“反向形成”——非自愿的人格逆转。


“被迫人格” vs “主观人格”：本质差异



维度
主观人格
被迫人格
现实案例印证



功能驱动力
内在生命冲动
生存恐惧驱动
母亲A：控制欲源于被歧视的恐惧


功能灵活性
可自由调节（如收放Fi自我）
功能锁死（如孩子无法停止迎合）
孩子：被迫一致形成心理反射


痛苦性质
成长性阵痛（如整合阴影）
存在性绝望（如男生E的心死）
男生E：冻结情感是精神自杀


疗愈路径
自我觉察+主动调整
需先解除外部压迫
单亲母亲需社会支持系统


当人长期处于被迫状态，所谓“人格”不过是创伤在时间中的化石。
1.2当今存在学科的单一性1.2.1心理学与哲学的定义与区别1.2.1.1心理学的定义与研究方法心理学的定义：心理学是一门研究人的心理现象及其发生规律的科学。
心理学主要研究人类心理现象及其影响下的精神功能和行为活动，涉及知觉、认知、情绪、思维、人格、行为习惯、人际关系、社会关系等许多领域，主要通过观察人类的行为、表情来描述、解释和预测其心理活动。
也就是说，心理学从实际的外显行为出发，基于物质层面的表现，推测和预测心理活动。
1.2.1.2哲学的定义与研究方法哲学的定义：哲学是关于世界观、方法论的学说。是在具体各门科学知识的基础上形成的，具有概括性、抽象性、反思性、普遍性的特点。
哲学的根本问题是思维和存在、精神和物质的关系问题。
黑格尔认为：哲学是一种特殊的思维运动，哲学是对绝对的追求。“哲学以绝对为对象，它是一种特殊的思维方式”。
哲学从意识层面出发，不同的个人意识会导致对事物的不同看法，物质的存在意义也可能因人的意识而异。
1.2.1.3心理学与哲学的关系与区别心理学关注人类的心理现象和行为，通过观察和实验来理解意识和行为的规律。而哲学则以更为抽象和思辨的方式，探讨世界的本质、意义以及人类在其中的位置。
1.2.2心理学的片面性1.2.3哲学的片面性第二章：新的人格模型——存在的天平2.1理论基础2.1.1黄金圈法则与人类思维模式本章要点：剖析黄金圈法则与唯物&amp;#x2F;唯心主义的关系，提出思维层次的整合模型。
2.1.1.1黄金圈法则模型介绍黄金圈法则模型由3个同心圆组成：它把思考和认识问题画成三个圈：最外面的圈层指的是事情的表象，中间的圈层指的是实现目标的途径，最里边的圈层指的是为什么要做这件事。①最外圈，What，做什么；②中间圈，How，怎么做；③最内圈，Why，为什么；
在黄金圈模型中，思维分为三个层次：what（表象）、how（措施）、why（原因）。
多数人习惯从外向内思考，遵循what→how→why的顺序；而部分人采用由内向外的方式，即why→how→what。
乔布斯是why→how→what思考模式的典型案例。他以‘why’（改变世界、追求极致用户体验）为驱动，设计产品时注重简洁与易用（how），最终推出如iPhone等创新产品（what），成功引领了智能手机革命。
由此将黄金圈法则与唯物主义、唯心主义结合起来。
what，是什么，对应唯物主义与科学认识发展阶段中人类首次认识一种物质时的疑问；how，怎么做，对应唯物主义与科学认识发展阶段中人类了解物质后使用这一物质时的探索why，为什么，对应唯物主义与科学认识发展阶段中人类去寻求物质的本质和抽象的规律。
2.1.1.2黄金圈法则与唯物主义、唯心主义的结合唯物主义、唯心主义、科学认识发展三阶段论的定义：
唯物主义的基本观点认为：世界就其本质来说是物质的，是不依赖于人的意识而客观存在的，意识是物质存在在人脑中的反映。
唯心主义认为意识、思维和精神活动在世界中居于首要地位，主张意识或心灵是创造和塑造现实的主体，物质世界则是意识的附属物。例如，主观唯心主义代表贝克莱提出“存在即被感知”，强调事物的存在依赖于被感知；而客观唯心主义代表黑格尔则认为绝对精神是世界的本原，物质世界是绝对精神的外化。
科学认识发展三阶段论依次包括现象论阶段（描述观察到的现象）、实体论阶段（探索产生现象的实体结构）和本质论阶段（揭示实体间的规律），这三个阶段是递进关系，逐步深入揭示科学真理。
唯物主义契合人类常规的认知路径：先识别事物本质，再探索其应用方式，最后思考应用的必要性。
相比之下，唯心主义侧重于先探讨世界的本质与物质的意义，再考虑物质的应用。
唯物主义以物质为起点，符合常规认知路径；唯心主义则从意识出发，更具抽象性。
这样看来，唯物主义正是人类认识世界的过程，而唯心主义就与正常的认识过程是相悖的。
笔者认为：心理学，唯物主义，人类对世界的认知过程，这三者是有很大关联的——以实际存在的表象向内在的探索，也就是以物质为起点向精神与思想探索。
而哲学，唯心主义，黄金圈推荐的思考方式，这三者也有大强的关联——以思想意识为起点向外在的行为或表现探索，也就是以精神与思想为起点向物质探索。



维度
唯物主义
唯心主义
黄金圈对应层



世界本质
物质决定意识
意识决定物质
Why（本质）


研究方法
实证、观察行为
思辨、追问意义
How（路径）


应用目标
解释现象、预测行为
探索存在、追问价值
What（表象）


黄金圈法则与唯物&amp;#x2F;唯心主义的关联为后续天平模型提供了理论框架。
2.2.2NLP模型与心理动力论的关系NLP的低三层（环境、行为、能力）对应心理动力论的“本我”，高三层（信念&amp;#x2F;价值观、身份、愿景&amp;#x2F;精神）对应“超我”，而“自我”则在两者之间起到平衡作用。
2.1.2NLP模型与心理动力论的结合2.1.2.1NLP思维逻辑层次模型介绍回头看黄金圈法则：what的外圈是现实，是物质世界，why的内在是思想，是精神世界，借此想到NLP思维模型：
NLP思维逻辑层次模型也称理解层次，Neuro-Linguistic Programming，翻译成中文就是神经语言程序学。
思维逻辑层次是NLP中的一个工具。
这个工具主要是说：人们在思考某些事情，或者解释一些社会现象的时候，会有不同的思维，然后这些思维分别处于不同的层次。在不同层次上思考问题，最终得到的答案和解决方案是不一样的。该模型认为，我们的大脑在思考和处理任何事情的时候，都分为六个层次，分别是：
1、愿景&amp;#x2F;精神（第六层，最高）2、身份（第五层）3、信念&amp;#x2F;价值观（第四层）4、能力（第三层）5、行为（第二层）6、环境（第一层）
在NLP思维逻辑层次模型中，环境、行为、能力称为低三层，这是我们大多数人都可以抵达到的层次，而信念&amp;#x2F;价值观、身份、精神&amp;#x2F;愿景称为高三层。
用简单的词来解释这6个层次：1、 精神：For whom For what (我与世界的关系)2、 身份：Who(我是谁)，身份角色3、 信念&amp;#x2F;价值：Why(为什么)，价值信念4、 能力：HoW(怎样做)，能力技巧5、 行为：What(做什么)，行动安排6、 环境：Where and When(何时、何地)，外部资源
在NLP思维模型中，第一、第二、第三偏向于黄金圈法则中的why的精神，第四偏向于黄金圈法则中的how，第五、第六偏向于黄金圈法则中的what的现实。
NLP模型可应用于个人目标设定：从环境（何时何地行动）到精神（人生意义），逐层拆解问题。



NLP层次
黄金圈对应层
心理动力论对应



精神&amp;#x2F;愿景
Why（本质）
超我


能力&amp;#x2F;行为
How（路径）
自我


环境
What（表象）
本我


尽管NLP模型被批评缺乏实证（Druckman, 2004），但其层级思维与黄金圈法则的契合性仍值得探讨。
2.1.3弗洛伊德的心理动力论：超我、自我与本我在弗洛伊德的心理动理论中，“本我”、“自我”和“超我”是人格结构的三个重要部分：
本我（Id）

概念：是人格结构中最原始的部分，从出生时就存在。它包含着与生俱来的本能和欲望，如饥饿、性欲等基本生物性需求。
特点：本我遵循“快乐原则”，追求即时满足，不考虑现实和道德约束，只追求快乐和避免痛苦。例如，一个婴儿感到饥饿时，就会本能地哭闹，直到得到食物满足为止。

自我（Ego）

概念：是在个体与现实世界接触过程中逐渐发展起来的，是人格结构中理性的部分。
特点：自我遵循“现实原则”，它在本我与外部现实世界之间起到调解作用。自我既要满足本我的需求，又要考虑到现实的可能性和限制。例如，当一个人感到饥饿（本我的需求）时，自我会考虑实际情况，如是否有食物、在哪里可以找到食物等，然后采取合理的行动，而不是像本我那样仅仅因为饥饿就无休止地哭闹。

超我（Superego）

概念：是人格结构中代表道德和良心的部分，它是在个体成长过程中，通过内化社会道德规范、父母的教导等逐渐形成的。
特点：超我遵循“道德原则”，它对自我和本我进行监督和批判，促使个体按照社会道德标准来行事。例如，当一个人有冲动要做一些不道德的事情（如偷窃）时，超我会提醒这是错误的行为，不应该去做。超我就像一个道德法官，评判着个体的行为是否符合道德规范。

在心理活动中，“本我”是能量的来源，“自我”是调节者，“超我”是道德监督者，三者相互作用、相互影响，共同构成了完整的人格。
2.1.4认知科学2.2三圈层与七状态2.2.1三圈层的脚手架——以黄金圈为基本1.Why2.How3.What


2.2.2黄金圈与人类本身的结合1.Why→精神2.How→原则3.What→物质

第一层 (Why - 核心&amp;#x2F;精神思想)： 对应黄金圈的 Why。这是驱动力的源泉，包含信念、价值观、深层动机、世界观、存在的意义等。它决定了 为什么 要做某事或成为某种人。
第二层 (How - 行为原则&amp;#x2F;方式)： 对应黄金圈的 How。这是连接思想与物质世界的桥梁，是指导行动的准则、策略、方法论、决策逻辑。它决定了 如何 去做，依据什么原则行事。
第三层 (What - 物质&amp;#x2F;结果&amp;#x2F;现象)： 对应黄金圈的 What。这是最外显的层面，包含具体的行动、产出、物质条件、生活环境、可观察的结果、感官体验。它展示了 做 了什么，产生了什么。

2.2.3七种基本的人格状态2.2.3.1七大状态1.完全依赖精神2.由精神向外延伸影响个人行为原则3.由精神向外延伸影响个人行为原则和整个人的行为举止4.完全依赖物质5.由物质向内延伸影响个人行为原则6.由物质向内延伸影响个人行为原则和个人精神思想7.精神与物质互相影响统一
2.2.3.2七大状态区分逻辑
本体论纯度
类别1与4为极端本体论立场（纯粹精神&amp;#x2F;物质）
类别7为对立统一的中和路径


影响方向性
类别2-3：精神向外辐射（从理念到行动）
类别5-6：物质向内渗透（从环境到认知）


实践深度
行为原则（浅层规则） vs 行为举止（深层习惯）
例如：义务论（规则） vs 斯多葛主义（生活方式）



2.2.3.3七大状态对应的人群
【安静的空想家，虚无主义者，只思考，不说话不做事不行动不改变】
类别：1.完全依赖精神
模式： （第一层：精神思想）×不对外输出任何内容
释义： 这类人完全内缩在Why层面，既无对外表达（How的一种），更无实际行动（How的核心），对What世界没有任何主动影响。× 符号完美体现了这种封闭和内耗状态。


【空谈者：只靠说来对外输出，不做事】
类别：由精神向外延伸影响个人行为原则 
模式：（第一层：精神思想）→对外输出语言→（第三层：物质） 
释义： 这类人“思想的巨人，行动的矮子”的特点。他们停留在Why的思考甚至表达（How的一种特殊形式：语言），但缺失了真正的行动（How的核心）去改变What。箭头停在第三层但没有真正作用于物质世界（改变现实）。语言输出（说）本身是一种行为（How的一种形式），只是它未能有效转化为改变物质世界的行动（另一种How）。模式可以更精确为：(精神思想/Why) → (How：语言输出) → (What：他人感知/可能的情绪影响)。其问题在于缺失了能直接改变目标物质世界的How（行动）。


【唯心主义者：只看自己认为的行为原则】
类别：由精神向外延伸影响个人行为原则和整个人的行为举止 
模式：（第一层：精神思想）←→（第二层：行为原则）
释义： 唯心主义者的核心：内在的Why（信念、理想）是绝对的，它直接决定了How（行为原则），并且他们努力让How符合Why。双向箭头强调了精神对行为的绝对主导，以及行为对信念的强化（自洽闭环）。他们可能相对忽略或选择性解释What层面的现实反馈。


【快乐的摆渡人：沉浸在物质世界不思考太多】
类别：4.完全依赖物质 
模式： →享受→（第三层：物质生活）
释义： 专注于What层面体验的人。他们可能没有深刻的Why（或不去深究），其How（行为方式）就是直接去体验和享受物质世界。箭头直接指向What，体现了其生活重心。其Why可能是“追求即时的感官快乐&amp;#x2F;舒适&amp;#x2F;避免痛苦”。模式可以补充为：(精神思想/Why：享乐/避苦) → 享受 → (物质世界/What)。箭头“→ 享受 →”本身就是一种非常直接的How。


【方舟的领航员：以生存和物质为目的影响自己的行为原则和观念】
类别：5.由物质向内延伸影响个人行为原则 
模式： （第二层：做事行为原则）←（第三层：外界物质生活） 
释义： 这类人是 实用主义者。他们的Why（生存、物质保障）直接塑造了他们的How（行为原则）。What（物质现实）的需求是驱动源，反向决定了How（策略）甚至间接影响了Why（观念&amp;#x2F;优先级）。体现了物质基础对行为乃至观念的决定性作用。(精神思想/Why：生存保障) → (行为原则/How) → (物质世界/What)，并且 (物质世界/What) → (反馈/调整) → (行为原则/How)，甚至 (物质世界/What) → (影响) → (精神思想/Why)（例如，物质极大丰富后可能追求更高层次Why）。这本质上也是一种动态循环，但其驱动源和核心关注点是What层面的需求。


【唯物主义者：以物质和经验为基本，不相信个人主观思想】
类别：6.由物质向内延伸影响个人行为原则和个人精神思想模式：（第二层：行为原则）←→（第三层：物质世界）
释义： 唯物主义的核心：从What（物质世界、客观经验）出发，总结归纳出How（行为原则、规律），并依据What的反馈不断修正How。双向箭头体现了实践检验认识、认识指导实践的循环。Why（个人主观思想）被认为可能不可靠或被物质基础决定，故不被强调为独立驱动源。唯物主义者更强调认识论（从物质总结规律），而领航员更强调目的论（以物质结果为驱动目标）。


【空而常满的智者：内心与物质不停地互相影响不断改进】
类别：7.精神与物质互相影响统一模式： （第一层：精神思想）←→第二层：行为原则）←→（第三层：物质世界）
释义： 这是框架中最理想、最动态、最完整的形态。三个层面形成了 完整的闭环和动态反馈系统：
Why (精神思想) 驱动 **How (行为原则)**。
How (行为原则) 作用于 **What (物质世界)**。
What (物质世界) 的 结果和经验 反馈回来，验证、修正甚至重塑 **How (行为原则)**。
对How的修正以及What带来的新认知，最终也会 **深化、拓展或调整 Why (精神思想)**。
调整后的Why再次驱动新的How，如此循环往复，不断进化。这体现了“知行合一”的最高境界和持续学习成长的动态过程。“空而常满”的比喻非常精妙，既强调开放心态（空），又代表持续充盈（满）。





2.2.4价值感来源、补偿机制及长期风险2.4.1 安静的空想家
价值感来源：→ 精神世界的宏大想象（自我构建的乌托邦）→ 颅内高潮般的思维快感（未实践的“完美方案”）
补偿机制：→ 标签收集者：用“INFJ”“高敏感人群”等身份标签证明独特性→ 知识囤积癖：收藏书单&amp;#x2F;课程替代行动，制造“即将伟大”幻觉
长期风险：→ 现实解体：丧失区分幻想与现实的能力→ 存在性抑郁：意识到思想从未落地后的自我厌弃


2.4.2 空谈者
价值感来源：→ 语言输出的即时反馈（辩论胜利、获得点赞）→ 批判他人产出的道德优越感
补偿机制：→ 立场表演：标榜“清醒者”“理想主义者”人设→ 责任外化：将不作为归咎于“环境太差”“他人愚蠢”
长期风险：→ 行动瘫痪：语言成为行动的替代性毒品→ 社会性孤立：被识破空谈本质后的信任崩塌


2.4.3 唯心主义者
价值感来源：→ 行为与精神准则的高度自洽（如“我永远诚实”）→ 对纯粹理念的殉道式坚持
补偿机制：→ 道德洁癖：用“初心纯净”掩盖现实失败→ 选择性失明：忽略物质反馈对理念的证伪
长期风险：→ 认知僵化：在变化世界中固守教条而衰亡→ 圣徒悖论：为维护理念完整性主动边缘化


2.4.4 快乐的摆渡人
价值感来源：→ 感官刺激的即时满足（美食、旅行、娱乐）→ 物质拥有的掌控感（新车、新衣带来的快感）
补偿机制：→ 体验消费主义：用购买新体验替代深度思考→ 存在感物质化：“我买故我在”（通过消费证明存在）
长期风险：→ 意义感真空：快乐阈值升高后的无尽空虚→ 反脆弱缺失：遭遇物质损失时精神崩溃


2.4.5 方舟的领航员
价值感来源：→ 物质世界的可验证成果（薪资、房产、项目完成）→ 生存安全保障带来的掌控感
补偿机制：→ 效率崇拜：用“忙”证明价值，回避精神追问→ 数据化自我：以KPI&amp;#x2F;银行数字衡量人生价值
长期风险：→ 工具化异化：自我沦为达成物质目标的工具→ 精神荒漠化：中年后突发的存在主义危机


2.4.6唯物主义者
价值感来源：→ 客观规律的可验证性（科学实验、数据分析）→ 经验积累带来的预测力提升
补偿机制：→ 绝对理性面具：用“冷静客观”压抑主观情绪→ 实用主义霸权：否定无法量化的精神价值
长期风险：→ 灵性萎缩：丧失审美、共情等软能力→ 系统性盲区：忽略意识对物质的反作用（如自证预言）


2.4.7 空而常满的智者
价值感来源：→ 三层动态平衡本身：思想-行动-结果的流畅转化→ 持续迭代的进化感：昨日之我滋养今日之我
补偿机制：→ 反标签化：拒绝固定身份，保持“未完成”状态→ 痛苦转化器：将挫折视为系统升级的必要反馈
长期风险：→ 无（动态平衡具抗风险性）→ 潜在挑战：需极高能量维持三层的活跃交互


2.4.8核心规律总结


维度
断裂层人格（1-2）
单极人格（3-6）
平衡人格（7）



价值感锚点
虚幻的精神自我
物质&amp;#x2F;理念的单一实现
过程本身


补偿本质
存在性止血
维度霸权
无需补偿


风险根源
层间通路断裂
维度失衡的指数级放大
自然熵增（需持续供能）



智者之“空而常满”的本质：空 &amp;#x3D; 不固化任何身份标签（开放系统）常满 &amp;#x3D; 三层能量流动的永续性

此框架不仅揭示人格状态，更指向修复路径——如“空想家”需建立最小行动闭环（精神→行为），“领航员”需注入精神反思（物质→精神）。
2.2.5不平衡状态的心理代价：标签化与价值焦虑2.5.1将标签作为存在感的证明虽然七种状态各自有各自的优点与缺点，但部分状态却能揭示部分人因缺点产生的精神与物质不平衡，这样的不平衡会让这些人感到不舒服，从而衍生许多坏习惯。例如：安静的空想家这类人更喜欢用标签标榜自己：没有产出的人才需要用各种各样的标签给自己的价值贴金。

心理机制：当精神活动（第一层）无法通过行为（第二层）转化为物质价值（第三层）时，人会陷入存在性焦虑——“我的思想有何意义？”→ 标签化成为低成本的价值补偿：用“INFJ”“佛系青年”“躺平主义者”等抽象符号替代真实产出，在认知层面伪造价值闭环。

关键矛盾：标签本质是精神层的自我殖民——用外部分类标准（第三层）反向定义精神世界（第一层），进一步脱离行为层（第二层）。

心理机制：语言输出制造“我已参与”的幻觉，但无行动结果会积累自我怀疑。→ 通过标榜“批判者”“理想主义者”等标签，将不作为美化为“众人皆醉我独醒”。

危险转化：长期失衡可能衍生 「杠精」模式——用否定他人产出（攻击第三层）掩盖自身行动缺失（第二层空洞）。


2.3天平——精神与物质的平衡2.3.1天平模型的提出根据心理动力论中的超我自我与本我画一个天平：
天平的左侧代表精神世界，代表人的思想与意识，代表了黄金圈法则中的why，代表了以思想为起点的哲学思想，代表了NLP模型中的第一、第二、第三层次，代表了心理动力论中的“超我”。
天平的右侧代表物质世界，代表人在现实中的物质与外在，代表了黄金圈法则中的what，代表了以在现实中接触物质与现象为起点的心理学思想，代表了NLP模型中的第五、第六层次，代表了心理动力论中的“本我”。
整个天平构成了“我”——一个人类。为了不让天平保持平衡，我需要寻找我所在的位置——我是一个移动的平衡点，“我”的行为是黄金圈法则中的how，“我”是心理动力论中的“自我”。我的所作所为体现着我的思想平衡，也是在维持我的生命存活。
[精神世界] ←─★─→ [物质世界]            （支点：自我）★旁标注：动态平衡点，左倾&amp;#x3D;哲学思辨主导，右倾&amp;#x3D;行为实践主导。  
支点的动态性体现在个体可通过自我觉察（如反思、冥想）或行动实践（如技能学习）主动调整精神与物质的权重。
当左侧的精神世界负担过重，若精神世界过载（如过度思考人生意义），“我”作为支点会向左侧倾斜，个体会忽视现实体验（如享受当下），将更多精力投入精神领域。然而，过度沉浸于精神内耗会使个体忽视现实生活的美好，如温暖的阳光、简单的满足感以及行动带来的成就感。此时需调整支点，回归行动。
当右侧的来自现实世界的压力过于沉重，“我”这个支点则无力顾及精神，只好让自己向右侧移动，来维持当下的现实生活。然而此时的我是被生活奴役的压迫的没有自己思想的傀儡，忘记了自己真正想做的是什么。
只有“我”这个天平的支点能够平衡好精神与物质的关系，平衡好内心思想与外在表现的关系，“我”才能呈现一个理性人类的样子。若天平偏向一侧或“我”并不在天平中间，“我”呈现出来的则是“感性”人类的样子。
2.3.2维持天平平衡：拥有三种爱好如何才能平衡好精神与物质的关系呢？或许可以尝试引入3个连接不同圈层的爱好：

运动型爱好
创造型爱好
智力型爱好

运动爱好  →  丰富物质世界，避免出现虚无主义者认为自己做什么都没有用（例如参加跑步公益活动，跑足多少米举办方种一棵树）
创作爱好  →  沟通精神世界和物质世界，可以把个人想法写下来或画下来，增加人与世界的链接，更多的接触世界了解世界，增加新的记忆，如画一幅画，三年后拿出来看回顾自己当时的心情
智力爱好  →  丰富精神世界，避免出现过于沉迷身边环境的紫醉金迷或随波逐流（例如读书，读一些启蒙类的书，或者玩迷宫等）



三爱好类型
对应三圈层
在七状态中的意义



运动型爱好
What层（物质&amp;#x2F;现象）
通过身体行动改变外在状态，是能量输出的起点或终点。


创造型爱好
How层（行为原则）
连接精神与物质的“转化器”，将内在思想外显为具象产物。


智力型爱好
Why层（核心精神）
深化认知、追问意义


刻意练习“三层贯通”
在任爱好中自问：

What：我此刻具体在做什么？身体&amp;#x2F;感官有何感受？
How：我遵循了什么方法？它反映何种价值观？
Why：这为何对我重要？它如何定义“我是谁”？

运动型爱好：保持身体敏锐、对物质世界感知敏锐

神经可塑性： 运动（尤其是有氧运动）能刺激大脑产生BDNF（脑源性神经营养因子），促进新神经元生长和神经网络连接，直接提升大脑功能（包括学习、记忆、专注力），让你思维更敏锐。

心血管健康： 增强心肺功能，改善血液循环，为大脑和身体提供更多氧气和营养，提升整体能量水平和耐力。

肌肉骨骼健康： 维持肌肉力量、骨密度、关节灵活性，预防衰老和久坐带来的功能退化（如你之前提到的身体掌控感、平衡感下降）。

代谢健康： 改善血糖调节、血脂水平，降低慢性病风险。

荷尔蒙平衡： 运动能有效调节压力荷尔蒙（皮质醇），并释放“快乐荷尔蒙”（内啡肽、血清素、多巴胺），显著改善情绪，缓解焦虑抑郁。

本体感觉和协调性： 如之前讨论，运动是维持和提升对身体感知与控制的关键。

可选运动 (强调多样性)：

有氧&amp;#x2F;心肺： 快走、慢跑、游泳、骑自行车、跳绳、跳舞、划船机、椭圆机、球类运动（羽毛球、网球、篮球等）。
力量&amp;#x2F;抗阻： 举重（自由重量或器械）、自重训练（俯卧撑、深蹲、引体向上）、弹力带训练、CrossFit（需基础）。
柔韧&amp;#x2F;平衡： 瑜伽、普拉提、太极拳、拉伸。
综合&amp;#x2F;功能性： 攀岩、徒步、功能性训练（结合力量、平衡、协调）、舞蹈。
核心原则： 选择你喜欢的、能长期坚持的，并尽量包含不同类型（心肺、力量、柔韧平衡）以达到全面健康效益。



创造型爱好：思想观点有所输出，由内在精神到外界物质

依据：
情绪调节与减压： 创造性活动（如艺术、音乐、写作、手工）提供了一种非语言的表达渠道，能帮助处理复杂情绪、释放压力、宣泄情感。专注于创作本身也能带来类似冥想的“心流”体验，暂时忘却烦恼。
自我表达与身份认同： 创造是将内在想法、感受、价值观外化的过程，有助于更清晰地认识自我，建立积极的自我认同感。
成就感与自我效能感： 完成一件创作（无论大小）能带来强烈的满足感和“我能行”的信心，提升自我价值感。
大脑激活与连接： 创造性活动通常需要同时调动大脑多个区域（负责情感、感官、运动控制、执行功能等），促进不同脑区之间的协同工作，增强认知灵活性。
意义感与目的感： 创造能带来一种“留下印记”或“产生影响”的感觉，为生活增添意义。


可选活动 (形式极其广泛)：
视觉艺术： 绘画（素描、水彩、油画、数字绘画）、雕塑、陶艺、摄影、书法、插花、园艺、手工艺（编织、缝纫、木工、模型制作）、烹饪&amp;#x2F;烘焙（美食创作）。
表演艺术： 演奏乐器、唱歌、作曲、舞蹈、戏剧表演。
语言艺术： 写作（日记、小说、诗歌、博客、剧本）、讲故事、脱口秀。
设计与建造： 室内设计、服装设计、编程（创造软件&amp;#x2F;游戏&amp;#x2F;网站）、发明小物件、乐高搭建。
其他： 学习一门新语言（也是一种创造新表达方式）、策划活动&amp;#x2F;旅行。
核心原则： 关键在于“输出”和“表达”，而非追求专业水平或他人评价。享受过程，关注内心的表达需求。



智力型爱好：积极思考，丰富精神世界

依据：
认知储备与神经可塑性： 持续学习新知识、解决新问题、进行深度思考，就像给大脑做“力量训练”。它能不断刺激神经元形成新的连接，增加大脑的复杂性和韧性（认知储备），延缓认知功能随年龄的衰退，降低阿尔茨海默病等风险。
保持思维敏锐： 挑战智力的活动锻炼记忆力、注意力、逻辑推理能力、批判性思维、问题解决能力等核心认知功能。
适应性与终身成长： 在快速变化的世界中，持续学习是保持适应力和竞争力的关键。智力型爱好培养好奇心和探索欲，让人保持开放心态，乐于接受新事物。
预防思维僵化： 主动接触不同领域的知识和观点，挑战固有思维模式，有助于避免陷入思维定势和偏见。
满足求知欲： 人类天生具有探索和理解世界的欲望，满足这种欲望能带来深层次的愉悦感。


可选活动 (核心是“动脑”和“学习新东西”)：
深度学习： 系统性地学习一门新学科（历史、哲学、科学、心理学等）、学习一门新语言（达到流利程度）、钻研专业技能。
策略与解谜： 下棋（国际象棋、围棋等）、玩解谜游戏（数独、填字、密室逃脱）、桥牌、复杂的策略桌游&amp;#x2F;电子游戏。
阅读与思考： 深度阅读非虚构类书籍（尤其是挑战你认知的）、阅读高质量长文&amp;#x2F;期刊、撰写评论或分析文章、参与哲学讨论、学习批判性思维方法。
探索与研究： 参观博物馆&amp;#x2F;科技馆并深入研究展品、进行家谱研究、研究自己感兴趣的特定主题（如天文、鸟类、某个历史时期）、进行小规模的“公民科学”项目。
技术性爱好： 编程、学习使用复杂软件（如图形设计、3D建模、数据分析）、研究新科技。
核心原则： 主动投入、带有一定的挑战性（需要走出舒适区）、追求理解和应用，而不仅仅是信息输入。



【结语】：根据自身情况，在三个圈层中分别选择一种适合自己的爱好，或许有助于达到精神和物质的平衡，使得天平稳定。
附录参考书籍列表
Smith, John. (2010). 新唯物主义. 上海: 学术出版社.  

Dilts, Robert. (2006). NLP新行为模式. 北京: 心理科学出版社.  

洛克, J. (2001). 心灵的哲学. 北京: 商务印书馆.

Sinek, S. (2009). 从“为什么”开始. 纽约: Portfolio.

Bargh, J. A., Chen, M., &amp;amp; Burrows, L. (1996). Automaticity of social behavior: Direct effects of trait construct and stereotype activation on action. Journal of Personality and Social Psychology, 71(2), 230-244.  

Druckman, D. (2004). Beacons of light in the fog of claims: A framework for evaluating NLP. Journal of Counseling &amp;amp; Development, 82(3), 343-354.


</content>
    <url>/2022/03/20/%E5%AD%98%E5%9C%A8%E7%9A%84%E5%A4%A9%E5%B9%B3--%E5%BF%83%E7%90%86%E4%B8%8E%E5%93%B2%E5%AD%A6%E7%9A%84%E4%BA%A4%E6%B1%87/</url>
  </entry>
  <entry>
    <title>“我”的使用说明书</title>
    <content>使用地址：“我”的说明书
项目地址：My-Manual


亲爱的“我”：
这是一份专属于你的「使用说明书」，也是一场温柔而深刻的自我对话。
我们总在探索世界，却常忘记聆听自己的声音——那些天赋与缺陷交织的独白，那些快乐与恐惧共舞的瞬间。这份说明书不是冰冷的问卷，而是一面镜子，映照出你独特的存在：你的身体如何呼吸，情绪如何流动，价值观如何扎根，灵魂如何向往自由。
填写它，不是为了定义“完美的我”，而是为了在混沌中厘清脉络：

当迷茫时，你能快速调用自己的“能量补给指南”；
当决策时，你能锚定价值观而非随波逐流；
当疲惫时，你知道如何用最适配的方式修复自己。

愿你在书写中，与真实自我赤诚相见。
功能特点
全面自我认知：涵盖基础信息、性格特征、个人偏好、价值观、目标成长、生活管理和社交互动7大维度
实时预览：填写表单时右侧实时生成说明书预览
数据持久化：自动保存数据到浏览器本地存储
多格式导出：支持导出为TXT文本或PNG图片
进度追踪：实时计算并显示表单完成百分比
响应式设计：完美适配桌面和移动设备

使用指南
打开应用后，从”基础信息”开始填写
通过顶部标签在不同部分之间切换
右侧预览区会实时显示您填写的内容
使用底部功能按钮：
保存数据：手动保存到浏览器
保存为TXT：导出为文本文件
保存为图片：导出为PNG图片
重置表单：清空所有内容



技术栈
前端：HTML5, CSS3, JavaScript

UI框架：原生CSS (Flexbox&amp;#x2F;Grid布局)

第三方库
：

html2canvas - 将HTML转为图片
FileSaver.js - 文件保存功能
Font Awesome - 图标库



贡献指南欢迎贡献！请遵循以下步骤：
Fork项目仓库
创建新分支 (git checkout -b feature/your-feature)提交更改 (git commit -am &amp;#x27;Add some feature&amp;#x27;)推送到分支 (git push origin feature/your-feature)创建Pull Request



基础信息
外貌特征  

身高：____cm，体重：____kg  
肤色：，肤质类型（油性&amp;#x2F;干性&amp;#x2F;敏感）：____，护理重点：______，常用的护肤品：___
发型：，最能凸显气质的发型&amp;#x2F;发色：  ，需要避免的发型&amp;#x2F;发色：_____
身体特别标记（胎记&amp;#x2F;疤痕）：____  
体型：，适合的穿搭风格：  ，适合的穿搭颜色：______
自信&amp;#x2F;不自在的身体部位：_________


身体需求  

每日所需睡眠：____小时  
每日所需休息：____小时
过敏&amp;#x2F;忌口食物：____ 
身体欠佳情况（咽炎&amp;#x2F;散光&amp;#x2F;胃痛） ：_____
过敏药物：_____
依赖的事物（玩偶&amp;#x2F;糖&amp;#x2F;护目镜）：_____


健康管理：

是否定期体检？频率是？

长期健身&amp;#x2F;养生习惯？具体项目是？

是否有药物依赖或需定期服用的保健品？



其他基本信息

生日：_____

自信的闪光点：______

最喜欢：_____

喜欢的生活方式：_____

记录自己的方式：_____





性格特征
优势  

擅长：____（如共情&amp;#x2F;逻辑分析&amp;#x2F;创意）  
他人常形容我：_________


待改善  

容易：____（如拖延&amp;#x2F;敏感&amp;#x2F;应激）  
性格缺点&amp;#x2F;缺陷（自认为）：_______
性格缺点&amp;#x2F;缺陷（他人认为）：_____
需避免的场景&amp;#x2F;场合：____


能量来源  

情绪恢复神器：____（如撸猫&amp;#x2F;听摇滚）  
充电方式：_________（独处&amp;#x2F;社交）
最需要的陪伴方式（小动物&amp;#x2F;朋友&amp;#x2F;书籍）：______


核心性格  

3个关键词：、____、  
来测测性格吧（荣格八维&amp;#x2F;九型&amp;#x2F;霍兰德）：______


底层性格  

压力下的人格倾向：____（如攻击型&amp;#x2F;逃避型）  
易被激怒的类型：____  
触发情绪崩溃的言论：____


负面情绪的原因

会因什么生气：_______

会因什么难过：_______

哪方面的压力最常让自己产生负面情绪：（生命&amp;#x2F;经济&amp;#x2F;人际关系&amp;#x2F;前途&amp;#x2F;兴趣爱好&amp;#x2F;自尊自信压力）______________________



情绪应对策略：

生气&amp;#x2F;难过时的缓解方式（如深呼吸&amp;#x2F;跑步&amp;#x2F;写日记）
压力管理的具体工具（如冥想App&amp;#x2F;心理咨询）


自我反思记录：

近期最成功的一次情绪控制案例
过去因性格缺陷导致的教训




个人偏好
穿搭风格  

舒适穿搭公式：____（如简约&amp;#x2F;复古）


口味倾向  

最爱：____  
坚决不吃：____  
各国不同的口味偏好（中餐&amp;#x2F;西餐&amp;#x2F;日料）：______
喜欢的食物做法：_____
无法忍受的食物做法：____


精神食粮  

单曲循环超100次的歌：，原因：  
精神避风港类的作品：____（如治愈系日剧）  
心情不好时治愈自己的良药：______
想要收到什么礼物：_______
喜欢送别人什么礼物：______
喜欢接受还是喜欢赠与：_____
保持精神状态的小癖好：______


艺术偏好

音乐风格&amp;#x2F;歌手：____  

书籍&amp;#x2F;影视偏好：（类型&amp;#x2F;代表作）  

喜欢的类型：_______

想自己创作的类型：_______

一眼就为之心动的事物：_____

愿意相信的理念&amp;#x2F;玄学：______

一直想要学习的艺术：______

想要与人分享的：______



运动偏好

喜欢的室内活动：____
喜欢的室外活动：____
最常做的运动：_____
想做没能做成的运动&amp;#x2F;活动：______
喜欢独自运动还是有运动搭子：_____


嗅觉倾向  

会放松的气味：____（如雨后泥土&amp;#x2F;烘焙咖啡）


数字生活：

常用的效率工具（如Notion&amp;#x2F;番茄钟）
偏好的数字娱乐方式（游戏&amp;#x2F;播客&amp;#x2F;短视频平台）


学习偏好：

适合的学习方法（视觉型&amp;#x2F;听觉型&amp;#x2F;动手实践）
最能集中注意力的学习时间段




价值观与原则
人生信条：____  
坚持的原则：______
坚信的事实：______
喜好的行为偏向（理性&amp;#x2F;感性）：______


交友原则  
不接受：____  
珍视的品质：____  
交友偏向：（理性&amp;#x2F;感性&amp;#x2F;乐观&amp;#x2F;悲观&amp;#x2F;同学&amp;#x2F;同事&amp;#x2F;网友）_____
边界感：______


金钱观  
储蓄占比：____% 
消费优先级：（衣食住行健康娱乐学习） ______
投资倾向：____  
有什么不必要但必须花钱的小癖好：______


价值观体系  
人生终极命题&amp;#x2F;人生要追求的意义：____（如自由&amp;#x2F;真理&amp;#x2F;爱）  
信仰（存在主义&amp;#x2F;虚无主义&amp;#x2F;乐观主义&amp;#x2F;悲观主义&amp;#x2F;等等）：______
希望如何被人记住：______


价值观内核  
触犯即断绝关系的原则：____  
绝不能容忍的事情&amp;#x2F;人：____


愿意支付溢价的领域：____（如有机食品&amp;#x2F;知识付费）  
最值得投资的3件东西：、____、  
最不愿意花钱的东西：____


道德红线：____  
能包容的事情：____
坚决不能包容的事情：____
可以视而不见的事情：____


社会责任：
对社会议题的关注方向（环保&amp;#x2F;平权&amp;#x2F;教育）
是否参与公益？具体形式是？


家庭观：
对亲情&amp;#x2F;婚姻&amp;#x2F;生育的核心态度


成就与遗憾：
人生至今最自豪的3件事
最想重来的1个决定及原因


灵性与哲学：
对死亡&amp;#x2F;命运&amp;#x2F;自由意志的看法
是否有宗教信仰或精神寄托？




目标与成长
短期目标（3-6个月）  
学习技能：____  
完成旅行：____


长期愿景  
理想居住地：____  
职业&amp;#x2F;生活状态目标：____


系统成长日志  
当前能力短板：____  
刻意练习的硬技能：____（如Python&amp;#x2F;插画）


每日仪式感小事：____  
心流状态领域：____  
未来3年不想成为的人：____  
目标拆解：
每个目标的阶段性里程碑（如3个月学会Python基础）
完成目标的奖励机制（如旅行&amp;#x2F;购物）


失败复盘：
过去未达成目标的原因分析




生活管理
快乐清单  
最愉悦的事：____（如阅读&amp;#x2F;烹饪）
享受&amp;#x2F;放松的环境&amp;#x2F;场所：_____
喜欢的生活节奏（清闲&amp;#x2F;忙碌）：_____


压力预警  
有压力的表现：______
压力过大需休息的症状：____


维护方式  
每周必做：____（如运动3次&amp;#x2F;写日记）


环境适配指南  
高效工作场景：____（如咖啡馆&amp;#x2F;书房）  
放松旅行目的地特质：____  
理想居住城市要素：____（如美术馆密度&amp;#x2F;绿化率）  
无法忍受的居住缺陷：____  
社交能量满格的场合：____


时间管理：
每日时间分配比例（工作&amp;#x2F;学习&amp;#x2F;娱乐&amp;#x2F;休息）
是否使用日程表？具体工具是？


财务管理：
月度消费分类占比（如饮食30%&amp;#x2F;学习20%）




社交互动
最佳互动模式  
喜欢的沟通方式：____（如直率&amp;#x2F;委婉）  
喜欢沟通的类型：____


社交频率  
可接受深度社交：____次&amp;#x2F;周


雷区提醒  
抵触行为：____  
讨厌的话题：_____


人际交往指南  
希望朋友联系的时刻：____  
触发疏离的行为：____  
深度聊天话题：____  
群体中的角色：____（如破冰者&amp;#x2F;观察者）  
最想对____时期的自己说：____


冲突处理：
面对人际矛盾时的解决风格（主动沟通&amp;#x2F;冷处理）
最希望他人如何向你道歉？


支持系统：
遇到困难时通常会向谁求助？
是否愿意担任他人的情绪支持者？



至此，你已完成了对自我的初步测绘。
但请记住：这不是终点，而是动态认知的起点。

你的口味会变，发型会改，目标会迭代；
昨天的雷区或许成为明天的乐园，曾经的短板可能进化为独特优势；
唯一不变的，是持续观察、接纳并塑造自我的勇气。

建议每半年重读此说明书：划掉已失效的答案，就像告别不再适合的旧衣；补充新发现的碎片，如同拼凑更完整的星图；对始终未填写的空白，温柔地问一句：“现在的我，准备好面对了吗？”
你是一本永远在续写的手账，愿未来的你翻阅此刻的笔迹时，能笑着说：“看啊，我始终在成为自己的路上。”
—— 来自此刻认真对待自己的你
</content>
    <url>/2022/05/19/%E6%88%91%E7%9A%84%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E%E4%B9%A6/</url>
  </entry>
  <entry>
    <title>毕设项目——前后端分离个人博客管理系统DiyWiki</title>
    <content>DiyWiki介绍项目适用人群&amp;#x2F;适用场景

独立游戏制作人&amp;#x2F;原创世界观制作人
拥有前台查看页面，后台管理页面的独立作者个人站、独立游戏WIKI网站



DiyWiki介绍项目适用人群&amp;#x2F;适用场景

独立游戏制作人&amp;#x2F;原创世界观制作人
拥有前台查看页面，后台管理页面的独立作者个人站、独立游戏WIKI网站

软件架构SpringBoot + MyBatis + Thymeleaf等

核心框架：SpringBoot
持久层框架：MyBatis
模板框架：Thymeleaf
分页插件：PageHelper
缓存框架：Ehcache
Markdown：Commonmark

前端
JS框架：Jquery
CSS框架：Bootstrap
富文本编辑器：editor.md
文件上传：dropzone
弹框插件：sweetalert

第三方
七牛云（文件上传）
百度统计

部署教程
下载&amp;#x2F;克隆该代码
本地部署Jdk1.8、Tomcat、MySQL
执行sql文件
application-dev.yml修改数据库账号密码
前台：http://localhost:8888/hole.html
后台：http://localhost:8888/admin/index.html
后台登录密码：admin

1.0版本功能基本功能：
点击左上角logo或点击“主页”，将进入首页hole.html展示最新剧情、最新角色

（最新周边展示功能将于后续版本实装）

在剧情中点击“点击查看”进入作者介绍about.html页面

点击“故事背景”将进入全部故事展示页blog.html，显示所有的故事剧情

点击某一个故事剧情，进入post.html，查看剧情全部内容

该页面可由游客进行评论

点击“角色设定”将进入全部角色展示页works.html，显示所有的角色

点击某一个角色，进入roles.html，查看该角色全部内容

点击“周边消息”，将进入全部周边展示页services.html，显示所有的周边

（该功能为静态页面试行版，1.0版本没有实际功能）

点击“联系方式”，可查看作者的联系方式，联系作者

点击“作者介绍”，可查看作者的个人公开信息和本模板网站提供的使用方式

地址栏输入localhost:8888&amp;#x2F;admin后可跳转至localhost:8888&amp;#x2F;login页面登录

登录成功后在localhost:8888&amp;#x2F;admin&amp;#x2F;index页面可查看后台管理相关功能仪表盘

仪表盘中可查看：角色、剧情、留言、文件、友链、最新发布、最新留言、系统日志

点击“发布角色”或“发布故事”，可添加相应角色&amp;#x2F;剧情

点击“故事管理”“角色管理”，可查看所有的剧情&amp;#x2F;角色，可在该页面编辑&amp;#x2F;删除

点击“评论管理”可管理他人的评论

点击“分类&amp;#x2F;标签”可管理设置的分类和标签

（分类标签页将在后续版本推出根据某一项tag查看全部内容的功能，目前该功能没有具体展现的方式）

点击“文件管理”可管理上传的文件

点击“友链管理”可管理网站相关文档友情链接

点击“系统设置”可设置网站相关信息，如站点名等

点击右上角头像可查看、设置用户信息，查看网站或注销账号等


其他扩展的功能
使用AES和MD5和BASE64等多重加密
在日志中记录客户端的IP地址
设置缓存并带过期时间
设置cookie
将 Markdown 格式的文本转换成 HTML 格式
替换HTML脚本防止XSS攻击
设置每分钟可评论的数量防止ddos攻击

项目指导老师Tokameine
</content>
    <url>/2023/06/28/%E6%AF%95%E8%AE%BE%E9%A1%B9%E7%9B%AE%E2%80%94%E2%80%94%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9FDiyWiki/</url>
  </entry>
  <entry>
    <title>纪念教程：Mirai Dice！骰娘搭建</title>
    <content>本篇Mirai Dice！骰娘搭建教程，写于2022年，截至2025年，因版本更新过快，该教程已不再支持Mirai Dice！骰娘的搭建与部署，本篇笔记仅保留作纪念。


观看本篇文章前请先跳转至链接：Dice!文档：https://v2docs.kokona.tech/zh/latest/
请先查看《骰娘是什么》
如果对跑团或骰娘感兴趣，想要搭建骰娘，请阅读完《Dice!文档》后，点击下方链接查看搭建指南。
Dice!导航帖：https://forum.kokona.tech/d/150-dice-dao-hang-tie
Mirai Dice 下载及搭建指南：https://forum.kokona.tech/d/448-mirai-dice-xia-zai-ji-da-jian-zhi-nan-zui-hou-geng-xin-20211214
Mirai Dice 搭建骰娘遇到的问题及解决方法：https://www.bilibili.com/read/cv13257089?spm_id_from=333.999.0.0
Mirai 开发文档：https://docs.mirai.mamoe.net/#%E4%BD%BF%E7%94%A8-mirai
【注：本篇教程主要针对在Windows搭建非24h骰娘、在Ubuntu服务器搭建24h骰娘】
【Dice不支持centos】
【本文主要参考以上教程，如想顺利搭建请仔细阅读以上教程，本文根据上诉教程只补充ubuntu部分】
其他或许有用的教程，选择查看：
Mirai环境准备：https://docs.mirai.mamoe.net/mirai-login-solver-selenium/
mirai-login-solver-selenium：https://github.com/project-mirai/mirai-login-solver-selenium
Mirai qq机器人ubuntu配置踩坑记录：https://blog.csdn.net/qq_43380015/article/details/108679731
前置Ubuntu要点：文件操作touch filepwdcd /homelsls -l

查看ip地址安装 net-tools 工具后使用 ifconfig
sudo apt install net-toolsifconfig

（服务器中第一个地址是内网ip地址，第二个是本机地址）
（虚拟机中第一个地址是NAT转换ip地址，第二个地址是桥接ip地址，第三个是本机地址）
vim使用#用vim打开文件vim test.txt #输入i#保存并退出:wq



Ubuntu系统环境部署：ubuntu安装lua：https://blog.csdn.net/yzf279533105/article/details/125448956
lua下载：http://www.lua.org/ftp/
下载好.gz包后解压，进入目录
运行
sudo apt-get install libncurses-devapt-get install libreadline-devmake linux test



java#更新源sudo apt-get update#安装openjdk-11-jresudo apt-get install openjdk-11-jre git





正式搭建骰娘windows、ubuntu下载Miraigit clone --depth=1 https://github.com/w4123/mirai-dice-release-noextracd mirai-dice-release-noextra



windows、ubuntu启动Mirai，运行./LaunchMirai.sh



在windows搭建成功后拷贝文件至Ubuntu服务器windows搭建教程擅长使用git可在github下载：https://github.com/w4123/mirai-dice-release-noextra
git安装教程：http://morlvoid.pro/2022/06/12/git/
打开文件夹，点击“启动Mirai.cmd”
windows配置自动登录账号添加自动登录：autologin add QQ账号 密码
根据提示进入WebUI界面，进行认主
认主后已经是Master，在这之后的其他配置请参考本文开头的Master手册
windows下进行滑块验证根据提示进行
如果出现报错信息为：Statuslogger Log4j2 could not find a logging implementation.Please ad log4j-core to the classpath. lsing SimpleLoger to log to the console…时
在ubuntu中修改日志文件
vim data/MiraiNative/config.json

将false 改为 true 后重启Mirai
windows向ubuntu拷贝文件通过Xshell 链接服务器后打开Xftp拷贝文件
Xmanager Enterprise 5安装教程：https://www.xshellcn.com/xmg_column/xshell-hjko.html
将windows配置好的文件复制进服务器的文件中，例如必须拷贝的文件：bots&amp;#x2F;QQ&amp;#x2F;device.json
退出Mirai/stop

如果想要在ubuntu服务器上始终运行，不需要退出命令
windows中关掉窗口即停止骰娘运行（也可运行命令）
服务器中后台运行骰娘程序（以下为可让程序在后台运行的三种方式，如一种不成功请更换其他方式）
nohupubuntu下让进程在后台运行：https://www.shuzhiduo.com/A/MAzAk6MR59/
（1）输入命令：nohup 你的shell命令 &amp;amp; 
nohup ./LaunchMirai.sh &amp;amp;



（2）回车，使终端回到shell命令行
（3）使用第二第三条，完全屏蔽掉信号。用disown -h jobspec来使某个作业忽略HUP信号。用disown -ah 来使所有的作业都忽略HUP信号。用disown -rh 来使正在运行的作业忽略HUP信号。
ubuntu查看进程和结束进程：https://blog.csdn.net/qq_42257666/article/details/124197052
screen安装screen
sudo apt-get install screen

创建 screen 窗口
screen -S  name



name可以设置为ssh、ftp，用于标注该 screen 窗口用途
​     注意，执行 screen -S name 之后系统会跳进一个新窗口，这个窗口就是我们创建的新进程，用来执行命令，在新窗口里面进行项目的启动即可
例：
cd mirai-dice-release-noextra./LaunchMirai.sh



退出保存
exit#完全退出#不会进行session保存


CTRL-a+d 
使用
screen -r

恢复到原来的工作状态
停止screen：
首先查看screen列表：
screen -ls



如果只有一个 screen 进程，命令行输入 
screen -r -d



 即可如果有多个screen，可以通过它的 PID 进入screen
 screen -r -d PID进入之后CTRL+C，终止
TmuxTmux 使用教程：https://www.ruanyifeng.com/blog/2019/10/tmux.html
安装Tmux
sudo apt-get install tmux



启动与退出
安装完成后，输入
tmux



命令进入 Tmux 窗口
查看后台运行程序ps -a



显示LaunchMirai.sh表示在后台运行
</content>
    <url>/2022/06/23/%E7%BA%AA%E5%BF%B5%E6%95%99%E7%A8%8B%EF%BC%9AMirai%20Dice%EF%BC%81%E9%AA%B0%E5%A8%98%E6%90%AD%E5%BB%BA/</url>
  </entry>
  <entry>
    <title>解决 Failed to connect to github.com port 443 的问题</title>
    <content>fatal: unable to access ‘https://github.com/username/repository-name/‘: Failed to connect to github.com port 443 after 21086 ms: Couldn’t connect to server
无法连接到github.com端口443：无法连接到服务器。


出现的问题：无法将本地代码提交到 Github 仓库。
经过查找发现许多人在克隆时也会遇到这种情况。
原因可能为：网络连接问题或防火墙限制。
下面为解决方式：
报错信息：$ git push -u origin mainfatal: unable to access &amp;#x27;https://github.com/username/repository-name/&amp;#x27;: Failed to connect to github.com port 443 after 21086 ms: Couldn&amp;#x27;t connect to server



网络连接问题测试与GitHub的连接：打开终端或命令提示符，尝试使用以下命令对GitHub服务器进行ping测试：
ping github.com

如果ping命令失败或显示高延迟，则表示存在网络连接问题。可能需要联系网络管理员或互联网服务提供商寻求帮助。
避免网络连接问题的方式1.临时禁用系统上的任何防火墙或防病毒软件，然后尝试再次推送。这些安全措施可能会干扰与GitHub的连接。
2.为GitHub存储库设置SSH身份验证，并使用SSH URL而不是HTTPS URL，可以绕过任何与端口或协议相关的问题。
如果以上设置均尝试过，且并非以上网络连接问题，而是由于国内网络无法连接Github时，解决方式就是配置访问GitHub的代理。
防火墙限制解决方式电脑本地开启代理，同时为Git设置代理
电脑本地开启代理这里就不多赘述，可以自由选择容易上手使用的VPN。
1.查找电脑代理打开电脑的设置，找到“网络和Internet”，找到代理，找到手动设置代理的地址。





2.配置Git代理打开 git bash，输入下列命令：
注意要将后面的地址修改为刚刚查找到的自己电脑的端口号
git config --global http.proxy http://127.0.0.1:1git config --global https.proxy http://127.0.0.1:1



解释：

--glboal 选项指的是修改 Git 的全局配置文件~/.gitconfig，而非各个 Git 仓库里的配置文件.git/config
port为端口号。

配置好后查看代理是否配置成功，再次尝试克隆或上传。
3.查看代理在git bash中输入下列命令git config --global --get http.proxygit config --global --get https.proxy



再次尝试：
git clonegit push -u origin main



其他取消代理git config --global --unset http.proxygit config --global --unset https.proxy



直接编辑 Git 的配置文件可以使用下列命令直接编辑 Git 的配置文件。
git config --global --edit

配置文件：
[http]proxy = http://192.168.0.1:1080[https]proxy = http://192.168.0.1:1080





参考文章：如何为Git设置代理
下列内容摘自这篇文章：
编辑 ~/.ssh/config 文件,给文件加上如下对应内容.windows 的 ~ 路径一般是C:\Users\用户名,可在 git bash 中 输入 cd ~进入 ~目录,再用pwd命令显示当前路径.
# HTTP代理Host github.com    User git    ProxyCommand connect -H 127.0.0.1:7890 %h %p    # SOCKS5代理Host github.com    User git    ProxyCommand connect -S 127.0.0.1:7891 %h %p

解释:

Host 后面 接的 github.com 是指定要走代理的仓库域名。
在 ProxyCommand 中，Windows 用户用的是 connect。
-H 选项的意思是 HTTP 代理
-S 选项指的就是 socks5 代理
在调用 ProxyCommand 时，％h 和 ％p 将会被自动替换为目标主机名和 SSH 命令指定的端口（ %h 和 %p 不要修改，保留原样即可）。

ssh 其他配置可以看这篇文章：如何在一个系统上同时使用 gitee 和 github
参考文章设置代理解决github被墙
Git 的代理配置
</content>
    <url>/2023/09/04/%E8%A7%A3%E5%86%B3-Failed-to-connect-to-github-com-port-443-%E7%9A%84%E9%97%AE%E9%A2%98/</url>
  </entry>
  <entry>
    <title>部分项目存档</title>
    <content>–项目存档–




自定义一周七日值日表网页应用-WeeklyDuty
部署地址：http://weekly-duty.morlvoid.pro
开源地址：https://github.com/Morlvoid/Custom-WeeklyDuty

年度绘画总结表格-MonthlyCanvas
部署地址：http://monthly.morlvoid.pro
开源地址：https://github.com/Morlvoid/MonthlyCanvas

带壳截图工具网页应用-Computer-case
部署地址：http://computer-case.morlvoid.pro
开源地址：https://github.com/Morlvoid/computer-case

八芒星模型图-Octagram
部署地址：http://octagram.morlvoid.pro
开源地址：

“我”的使用说明书-My-Manual
部署地址：http://manual.morlvoid.pro
开源地址：https://github.com/Morlvoid/My-Manual

备用：统一Readme.md格式[![在线演示](https://img.shields.io/badge/在线演示-点击体验-blue)](http://部署地址)![License](https://img.shields.io/badge/license-MIT-blue.svg)![HTML](https://img.shields.io/badge/语言-HTML/CSS/JS-orange)![HTML5](https://img.shields.io/badge/HTML5-E34F26?logo=html5&amp;amp;logoColor=white)![JavaScript](https://img.shields.io/badge/JavaScript-F7DF1E?logo=javascript&amp;amp;logoColor=black)

</content>
    <url>/2025/12/23/%E9%83%A8%E5%88%86%E9%A1%B9%E7%9B%AE%E5%AD%98%E6%A1%A3/</url>
  </entry>
  <entry>
    <title>静态网站托管的N种方式</title>
    <content>本篇为静态网站托管的多种方法。截止至2025年7月9日可行的托管方式有：Github Pages、阿里云对象储存OSS、Vercel。


Github PagesGithub Pages的全流程搭建方式在本站已经写过，详情查看：Github-Page博客搭建
阿里云对象储存OSS+CDN本方法的前提是在阿里云购买了且备案了自己的域名。（如果在其他地方购买了域名并在阿里云部署OSS可参考）
以 阿里云OSS 为例，其他云厂商（腾讯云COS, AWS S3+CloudFront等）逻辑类似，界面略有不同
基本流程创建Bucket → 开启静态托管 → 上传文件 → 绑定域名+HTTPS → 获取Endpoint → 解析域名



步骤1：创建与配置Bucket创建Bucket &amp;amp; 开启静态托管 &amp;amp; 上传文件：这是基础准备工作，创建存储空间，启用其作为网站的功能，并上传内容。
【注：】阿里云要求：所有绑定至中国内地 Bucket 的域名（包括二级域名）必须完成工信部 ICP 备案。例外情况：若 Bucket 位于 海外地域（如中国香港），则绑定域名无需备案。
域名备案（内地 Bucket 必选）
阿里云OSS控制台 (https://oss.console.aliyun.com/)
海外Bucket举例：

登录OSS控制台。
点击“Bucket列表”，创建 Bucket，选择地域为 “中国香港” 或其他海外节点
填写配置（华东举例）：
Bucket名称： 全局唯一，如 my-static-website 。
地域： 选择离您目标用户近的区域，如 华东1（杭州） 。
存储类型： 选标准存储。
读写权限： 务必选 公共读 。
其他选项： 如版本控制、日志等，按需开启，新手可默认。



Bucket名称最好与你的二级域名一致或相关（例如 blog-yourdomain-com）。注意： Bucket名称全局唯一。
选择与你的用户靠近的地域。
读写权限设置为公共读 (这是托管静态网站必须的)。
步骤2：开启静态托管数据管理 → 静态页面 → 设置：- 状态：开通- 默认首页：index.html- 默认404页：404.html (可选)

阿里云OSS控制台 -&amp;gt; 进入您刚创建的Bucket (my-static-website) -&amp;gt; 左侧菜单

在Bucket管理页面，点击左侧菜单 “数据管理”。
找到 “静态页面”选项。
点击或 “设置”。
选择 “静态网站” 模式 (通常有“关闭”、“默认首页”、“重定向”等选项，选 “默认首页” )。
设置：
默认首页： 输入 index.html (用户访问根目录时自动加载的文件)。
默认404页(可选)： 输入 error.html 或 404.html (访问不存在的路径时显示的文件)。


点击“保存”。

步骤3：上传文件将你的静态网站文件（index.html, 样式表、脚本、图片等）上传到这个Bucket中。
文件管理 → 文件列表 → 上传文件


点击左侧菜单 “文件管理”中的“文件列表”。
点击 “上传文件”。
将您本地开发好的网站文件（index.html, about.html, css/style.css, js/main.js, images/logo.png 等）拖拽到上传区域，或点击选择文件。
确保文件结构正确（例如，index.html 在根目录）。
点击 “上传”。

网站文件（菜品）已放入仓库（Bucket）。此时可通过OSS提供的临时Endpoint访问网站（能看到 index.html 内容），但速度慢且地址不友好。
步骤4：绑定域名+HTTPSBucket 配置 → 域名管理 → 绑定域名：- 域名：`blog.yourdomain.com`- 勾选 `自动添加CNAME记录`（域名在阿里云时）- 勾选 `开启HTTPS` + `强制跳转HTTPS`（系统自动申请证书）

阿里云OSS控制台 -&amp;gt; 进入您的Bucket (my-static-website) -&amp;gt; 左侧菜单 “Bucket 配置” -&amp;gt; “域名管理”

点击 “绑定域名”。
输入域名： 在“域名”框中填写您已购买并准备用于网站的自定义域名，例如 www.yourdomain.com (不能带 http:// 或 /)。 
开启HTTPS (强烈推荐)：
勾选 “自动开启HTTPS安全加速” 或类似选项。
阿里云会自动为您申请并部署免费的 DigiCert DV 单域名证书 (或 Let’s Encrypt)。过程完全托管，无需手动操作证书。


点击“下一步”或“确认” (这里触发关键验证！)
域名所有权验证 (最重要的一步！)：
阿里云会弹出一个窗口，要求您添加一条CNAME记录到您的域名DNS解析中！
记录类型： CNAME
主机记录： 系统自动生成的值，通常形如 _dnsauth.www (如果绑定 www.yourdomain.com) 或 _dnsauth (如果绑定根域名 yourdomain.com)。 
记录值： 系统自动生成的值，形如 oss-cn-hangzhou.aliyuncs.com.xxxxx.aliyuncs.com。


立即操作DNS：
打开一个新的浏览器标签页，登录您的域名注册商控制台 (如阿里云域名控制台、腾讯云DNSPod、Cloudflare等)。
找到域名 yourdomain.com 的 DNS解析设置。
添加一条 CNAME记录：
主机记录： 粘贴阿里云要求的主机记录 (如 _dnsauth.www)。
记录值： 粘贴阿里云提供的记录值。
TTL： 一般选默认或10分钟。


保存这条DNS记录。


回到阿里云OSS窗口：
确认已添加好验证记录，点击 “验证” 或 “我已添加”。
**等待验证通过 (需要几分钟，DNS刷新)**。阿里云会不断检查DNS，直到找到您添加的正确验证记录。
(如果开启HTTPS) 证书申请自动进行： 验证通过后，阿里云会自动为 www.yourdomain.com 申请并部署SSL证书，此过程可能需要额外几分钟 (2-15分钟)。


绑定成功：
当验证通过且HTTPS证书部署完成（如果开启），阿里云会提示 “域名绑定成功”。
此时，在“域名管理”列表里，您能看到状态为 “正常” 的域名 www.yourdomain.com，并且HTTPS状态为 “已开启”。
最关键信息出现： 在这个域名旁边或详情里，您会看到阿里云为您的CDN加速生成的 CNAME地址&amp;#x2F;Endpoint！它的格式通常是：www.yourdomain.com.&amp;lt;随机字符&amp;gt;.aliyuncs.com 或 my-static-website.&amp;lt;随机字符&amp;gt;.oss-accelerate.aliyuncs.com。



步骤5：获取Endpoint获取OSS Bucket的访问端点，即获取OSS Bucket的CNAME目标地址。
上一步（绑定域名+HTTPS成功）后自动获得。

在阿里云OSS控制台 -&amp;gt; Bucket (my-static-website) -&amp;gt; “Bucket 配置” -&amp;gt; “域名管理”。
找到状态为“正常”的已绑定域名 www.yourdomain.com。
在对应的“CNAME”或“加速域名”列下，找到那个长字符串地址。它就是 Endpoint &amp;#x2F; CNAME目标地址。
复制 这个完整的Endpoint地址。例如：www.yourdomain.com.w.kunlunca.com 或 my-static-website.oss-accelerate.aliyuncs.com (具体格式阿里云可能会变，认准它是CNAME值)。


结果： 拿到将域名流量指向阿里云CDN网络的 **关键地址 (Endpoint)**。

各区域Endpoint示例：



地域
Endpoint（地域节点）
Bucket 域名



华北1（青岛）
oss-cn-qingdao.aliyuncs.com
myblog.oss-cn-qingdao.aliyuncs.com


华东1（杭州）
oss-cn-hangzhou.aliyuncs.com
static.oss-cn-hangzhou.aliyuncs.com


华南1（深圳）
oss-cn-shenzhen.aliyuncs.com
images.oss-cn-shenzhen.aliyuncs.com


香港
oss-cn-hongkong.aliyuncs.com
cdn.oss-cn-hongkong.aliyuncs.com


重要注意事项：

必须复制完整域名
+ 正确：oss-cn-beijing.aliyuncs.com- 错误：your-bucket （不完整）

地域匹配验证

在概览页的 “基本信息” 中确认Bucket所在地域
确保Endpoint中的地域代码（如 cn-beijing）与实际地域一致



步骤6：解析域名阿里云解析设置 (CNAME)
进入域名控制台，域名注册商控制台 (和之前添加验证记录是同一个地方)

详细步骤：

登录您的域名注册商&amp;#x2F;DNS托管商控制台 (如阿里云域名控制台、DNSPod、Cloudflare)。
进入域名 yourdomain.com 的 DNS解析设置&amp;#x2F;域名解析 页面。
添加最终的CNAME记录 ：

在弹出的表单中填写以下关键信息：
记录类型：最常用的是：

A 记录：将域名指向一个 IPv4 地址（例如服务器的IP）。这是最常用的，用于网站、服务器。

CNAME 记录：将域名指向另一个域名（例如，指向阿里云OSS的Bucket域名、CDN的加速域名、或腾讯云的服务器域名等）。当目标地址是域名而不是IP时使用。

AAAA 记录：将域名指向一个 IPv6 地址。

MX 记录：用于邮箱服务器解析（如果你要为 mail.yourdomain.com 设置邮件服务）。

主机记录：这里填写的就是你要创建的二级域名的前缀部分！

例如：要创建 blog.yourdomain.com，就填写 blog。
要创建 shop.yourdomain.com，就填写 shop。
要创建 www.yourdomain.com，就填写 www。
特殊值：
@：表示直接解析主域名 yourdomain.com（本身不是二级域名，但记录类型也在这里设置）。
*：表示泛解析，匹配所有未单独设置的二级域名（例如 anything.yourdomain.com 都会指向这里设置的目标）。谨慎使用。



解析线路：一般选择 “默认”。如果需要根据访问者的网络运营商（如电信、联通）或地理位置（如境外）提供不同解析结果，可以选择相应线路。免费版也提供基础线路（默认、搜索引擎、境外）。
记录值：

如果记录类型是 A，这里填写你的服务器或服务的 IPv4 地址 (例如 123.123.123.123)。
如果记录类型是 CNAME，这里填写目标域名 (例如 your-bucket.oss-cn-hangzhou.aliyuncs.com 或 cdn.example.net)。注意： 目标域名后面通常需要加一个点 .，但阿里云控制台一般会自动处理或提示，按界面要求填写即可（有时不加点也可以）。
如果记录类型是 AAAA，填写 IPv6 地址。
如果记录类型是 MX，填写邮件服务器域名，并设置优先级。

TTL（生存时间）：表示DNS记录在本地缓存中保留的时间。一般选择 “10分钟”（默认）即可。数值越小，更新生效越快，但对权威DNS查询压力略大；数值越大，生效越慢，但能减少查询次数。非特殊需求保持默认。


填写完成后，点击 “确认” 按钮。


等待生效 &amp;amp; 测试DNS生效： 保存最终CNAME记录后，需要等待DNS全球刷新（根据您设置的TTL，通常几分钟到几小时）。可以使用 dig www.yourdomain.com 或 nslookup www.yourdomain.com 命令查看解析结果是否变成了您的Endpoint地址。
访问测试：

在浏览器中输入您的自定义域名 https://www.yourdomain.com (注意是 https!)。
首次访问可能稍慢（CDN节点需要回源到OSS Bucket拉取文件并缓存）。
刷新几次后，速度应显著提升（文件已缓存在CDN边缘节点）。
检查浏览器地址栏是否有绿色的锁图标（HTTPS生效）。

使用以下方法检测DNS是否生效：
# Windows 命令提示符nslookup 您的二级域名# 示例：nslookup blog.yourdomain.com# Linux/Mac终端dig 您的二级域名 CNAME# 示例：dig blog.yourdomain.com CNAME

✅ 正确响应应显示您的OSS Endpoint地址
备案与配置常见问题汇总
Q：为什么已备案主域名下的子域名仍绑定失败？A：请检查主域名备案是否接入阿里云。若备案在其他服务商，需在阿里云做 「接入备案」10。
Q：开启静态页面后访问域名仍下载文件？A：检查文件 Content-Type 是否为 text/html（可在 OSS 文件详情中修改）8。
Q：HTTPS 访问提示不安全？A：在域名绑定页面开启 「强制 HTTPS」 并上传 SSL 证书（阿里云可申请免费证书）

Q：为什么一定要使用OSS+CDN？CDN（内容分发网络） 是一种分布式网络架构，由分布在不同地理位置的边缘节点服务器组成，旨在通过缓存内容并将其分发到离用户最近的节点，提升内容传输速度、减少延迟并优化用户体验。CDN广泛应用于网站加速、视频流媒体、文件下载等场景。
CDN的工作原理
CDN通过将源站的内容缓存到各地的边缘节点，当用户发起请求时，系统会根据用户的地理位置、网络运营商等因素，将请求引导到最近的缓存节点。如果缓存节点已有所需内容，则直接返回；否则会从源站获取内容并缓存到节点，供后续用户访问。
以下是CDN的主要流程：
用户请求内容时，DNS解析会将请求指向最优的CDN节点。如果节点已有缓存内容，直接返回给用户。若无缓存内容，节点会向源站请求并缓存，随后返回给用户。
使用CDN的优势
提升访问速度：通过就近访问缓存节点，减少物理距离和网络延迟，显著提升页面加载速度。降低带宽成本：缓存技术减少源站的直接请求次数，从而降低带宽消耗。提高可用性：分布式架构能有效应对高流量和硬件故障，确保服务稳定。增强安全性：通过DDoS防护、TLS&amp;#x2F;SSL加密等技术，提升网站的安全性。减轻源站压力：分担源站负载，避免因流量激增导致的宕机。
CDN的典型应用场景
网站加速：静态资源（如图片、CSS、JS文件）通过CDN分发，提升加载速度。视频点播与直播：支持大文件下载、视频流媒体分发，优化用户观看体验。移动应用加速：加速APP更新包、短视频等内容的分发，提升用户访问效率。跨地域访问优化：解决不同运营商或地域间的网络互通问题，确保全球用户流畅访问。
重要术语
边缘节点：距离用户最近的缓存服务器，用于快速响应用户请求。回源率：缓存未命中时向源站请求的比例，回源率越低，CDN效率越高。命中率：用户请求直接命中缓存的比例，命中率越高，用户体验越好。
结论一：OSS 本身可以独立运行，不强制依赖 CDN

OSS 本身是对象存储服务：它核心功能是安全、可靠、低成本地存储海量文件（图片、视频、静态网页文件等）。
OSS 自带访问端点（Endpoint）：每个 Bucket 都有一个形如 your-bucket.oss-cn-hangzhou.aliyuncs.com 的 URL。您可以直接通过这个 URL 访问 Bucket 里的文件。
OSS 支持静态网站托管：开启此功能后，OSS 可以自动处理 index.html, error.html 等，让 Bucket 像一个基础 Web 服务器一样工作。
技术上可行：如果您：
对访问速度要求不高（用户能忍受几秒加载时间）。
用户主要集中在一个区域（如仅国内华东用户）。
流量很小（没有突发高并发）。
不太在意 HTTPS 证书管理（OSS 静态托管本身不支持自定义域名 HTTPS，需搭配 CDN 或云函数等实现）。
能接受 OSS 外网流出流量费用（可能比 CDN 回源流量贵）。那么，仅使用 OSS 部署静态网站是完全可以工作的！不需要 CDN。



结论二：但在绝大多数生产环境场景中，强烈推荐 OSS + CDN 组合！ CDN 为 OSS 带来的核心价值远超“提速”
CDN 绝不仅仅是“锦上添花”的加速器，它解决了 OSS 直接暴露给公网访问的多个关键痛点：



痛点
仅用 OSS 的问题
OSS + CDN 的解决方案



1. 访问速度慢 (全球&amp;#x2F;跨区域用户)
用户直接连接 OSS 数据中心（如杭州）。美国用户访问延迟可能高达 200-300ms+，体验极差。
CDN 边缘节点就近响应：美国用户访问美国边缘节点 (可能 &amp;lt; 20ms)，节点缓存命中则瞬间返回。核心价值！


2. 高并发&amp;#x2F;突发流量扛不住
OSS 虽然高可靠，但公网带宽和连接数有限。突发流量（如被分享）易导致响应变慢或超时。
CDN 海量边缘节点分散压力：请求被分散到全球数千节点，单点压力小。节点缓存扛住绝大部分请求，**保护源站 (OSS)**。


3. 成本可能更高
OSS 的外网流出流量费相对较高。用户下载越多，费用越高。
CDN 回源流量费更低：CDN 从 OSS 取数据（回源）享受更低单价。用户从 CDN 下载，CDN 流出流量费通常低于 OSS 外网流出费。大流量下显著省钱！


4. 无法自定义域名 HTTPS
OSS 静态托管原生不支持绑定自定义域名且开启 HTTPS (需额外配置，依赖其他服务)。
CDN 天然支持：一键绑定自定义域名，自动申请&amp;#x2F;部署&amp;#x2F;续费 Let’s Encrypt 证书，强制 HTTPS，提升安全与 SEO。


5. 安全风险增加
直接暴露 OSS Endpoint：



* 易被扫描、攻击。* 源站 IP 可能被 DDoS。* 热链接盗刷流量。 | **CDN 作为安全屏障**：* 隐藏真实 OSS Endpoint。* 边缘节点提供 DDoS 基础防护、WAF (需配置)。* 支持 Referer 防盗链、URL 鉴权等，**在边缘拦截非法请求**，保护 OSS 和节省流量。 |

| 6. 功能局限 | OSS 主要功能是存储，Web 高级功能弱（如缓存策略、压缩、HTTP&amp;#x2F;2, Brotli）。 | CDN 提供丰富优化功能：灵活缓存规则、Gzip&amp;#x2F;Brotli 压缩、HTTP&amp;#x2F;2&amp;#x2F;HTTP3、页面优化、QUIC 协议等，进一步提升性能与体验。 |
总结：什么时候可以不用 CDN？什么时候强烈建议用？

可以不用 CDN (仅 OSS)：
内部系统&amp;#x2F;工具： 仅限公司内网或特定区域访问的后台、工具页面。
极低流量测试&amp;#x2F;演示环境： 访问量忽略不计，速度要求不高。
纯粹的数据备份&amp;#x2F;归档： 文件不需要被频繁公网访问。


强烈建议搭配 CDN：
面向公网用户的网站&amp;#x2F;应用： 博客、官网、H5、小程序后端、产品文档等。速度、稳定性、安全、成本、HTTPS 都至关重要！
包含大量静态资源 (图片&amp;#x2F;JS&amp;#x2F;CSS&amp;#x2F;视频)： 这类文件最适合缓存，CDN 加速效果立竿见影，省流量明显。
用户分布广泛 (全球&amp;#x2F;全国)： 必须靠 CDN 边缘节点解决物理延迟问题。
预期有流量波动或增长： CDN 能轻松应对突发流量，避免 OSS 被打垮。
重视安全与盗链防护： CDN 提供第一道防线和防盗链能力。



Vercel</content>
    <url>/2025/07/09/%E9%9D%99%E6%80%81%E7%BD%91%E7%AB%99%E6%89%98%E7%AE%A1%E7%9A%84N%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
  </entry>
  <entry>
    <title>Web开发模式演进与对比</title>
    <content>全面Web开发架构模式对比表
省流：
静态 → 服务端动态 → 客户端动态 → 混合渲染 → 构建时渲染

传统静态MPA、动态服务端MPA、客户端SPA、现代同构应用、静态生成站点、微前端架构。


简易版表格


模式名称
架构
代码模式
开发范式
渲染方式
核心特征
适用场景



传统静态MPA
MPA
独立HTML文件
无复用结构
静态直接服务
每个页面独立，维护成本高
简单展示页、个人网站


动态服务端MPA
MPA
模板组合页面
服务端模板(SST)
SSR
服务器拼装，有一定复用
传统企业官网、早期电商


客户端SPA
SPA
组件构成应用
组件化开发(CBD)
CSR
单HTML入口，前端路由，体验流畅
后台管理、工具类Web应用


现代同构应用
混合
组件+页面路由
CBD + 服务端能力
SSR + CSR混合
首屏服务端渲染，后续客户端交互
电商、社交平台、需要SEO的复杂应用


静态生成站点
混合
组件&amp;#x2F;模板构建
内容驱动开发
构建时渲染
预先生成HTML，性能极致
博客、文档、营销页面


微前端架构
分布式
多个独立子应用
独立团队协作
多种渲染策略混合
大型应用拆解，独立开发部署
企业级SaaS平台、大型系统


具体技术栈对应关系


模式
代表技术
典型项目



传统静态MPA
纯HTML&amp;#x2F;CSS&amp;#x2F;JS
个人作品集、简单宣传页


动态服务端MPA
PHP(Laravel)、Python(Django)、Java(Spring)
传统企业官网、小型电商


客户端SPA
Vue&amp;#x2F;React&amp;#x2F;Angular + 路由库
后台管理系统、SAAS工具


现代同构应用
Next.js(React)、Nuxt.js(Vue)、Remix
电商平台、社交应用、内容社区


静态生成站点
Hugo、Jekyll、VuePress、Astro
技术博客、产品文档、营销网站


微前端架构
Single SPA、Module Federation、qiankun
大型企业平台、银行系统、复杂SAAS


复杂版：该表格从许多角度详细区分了Web开发的不同模式


维度
1. 原始MPA
2. 服务端MPA
3. SPA (CSR)
4. SSR框架
5. SSG&amp;#x2F;静态生成
6. 微前端
7. JAMstack
8. 岛屿架构
9. 可恢复架构
10. 边缘渲染
11. 渐进增强(HTMX)
12. Web Components



核心架构
多页面应用
多页面应用
单页面应用
同构应用
静态站点
分布式应用
JavaScript+APIs+Markup
静态HTML+交互岛屿
可序列化状态恢复
边缘计算
渐进增强
原生Web组件


渲染位置
无渲染(静态)
服务端
客户端
服务端+客户端
构建时
客户端&amp;#x2F;服务端混合
构建时+客户端
服务端+按需客户端
服务端序列化
边缘节点
服务端为主
客户端


代码组织
每个页面独立HTML
模板继承&amp;#x2F;include
组件化
组件化+页面路由
组件化+模板
独立子应用
组件化+API调用
静态模板+岛屿组件
组件化(特殊)
组件化+边缘函数
传统HTML+AJAX
自定义元素


路由方式
服务端路由(整页刷新)
服务端路由
前端路由(hash&amp;#x2F;history)
混合路由
静态文件路由
前端路由+集成
静态路由+客户端路由
静态路由+客户端交互
前端路由(按需)
边缘路由
服务端路由+局部更新
前端&amp;#x2F;服务端均可


状态管理
无&amp;#x2F;简单全局变量
服务器Session
Vuex&amp;#x2F;Pinia&amp;#x2F;Redux
服务端状态传递+客户端状态
无&amp;#x2F;静态数据
独立状态+共享状态
客户端状态+API状态
组件状态
序列化状态
边缘状态
服务端状态
组件内部状态


数据获取
无&amp;#x2F;静态内容
服务器数据库查询
AJAX&amp;#x2F;Fetch API
getServerSideProps等
构建时获取
独立数据源
API调用(GraphQL&amp;#x2F;REST)
构建时&amp;#x2F;运行时API
序列化数据传递
边缘函数调用
服务器返回HTML片段
AJAX&amp;#x2F;服务器推送


构建工具
无
无&amp;#x2F;简单编译
Webpack&amp;#x2F;Vite
Next.js&amp;#x2F;Nuxt.js内置
Hugo&amp;#x2F;Jekyll&amp;#x2F;Gatsby
Webpack模块联邦
Vite&amp;#x2F;Webpack+部署平台
Astro&amp;#x2F;Vite
Qwik CLI
边缘平台工具
无&amp;#x2F;简单构建
无&amp;#x2F;Vite&amp;#x2F;Webpack


部署方式
静态文件托管
传统服务器
静态托管+API服务器
Node.js服务器&amp;#x2F;Serverless
静态托管&amp;#x2F;CDN
独立部署+集成
静态托管+Serverless函数
静态托管
静态托管+边缘
边缘平台
传统服务器
静态&amp;#x2F;服务器均可


性能特点
首屏最快
首屏快,但TTFB依赖服务器
首屏慢,后续快
首屏快,水合后有开销
最快,纯静态
独立加载,可能冗余
静态快,API调用有延迟
极快,JS按需加载
即时交互,极低JS
全球低延迟
快速初始,渐进增强
原生性能好


SEO支持
完美
完美
差(需额外处理)
优秀
完美
各子应用独立处理
优秀(预渲染)
完美
优秀
优秀(SSR)
完美
一般(需配合SSR)


开发体验
简单但重复
传统,耦合度高
现代,热更新好
优秀,混合体验
简单但构建慢
复杂但独立
优秀,前后端解耦
极佳,关注点分离
独特,学习曲线陡
新兴,工具链发展中
简单直观
原生但生态小


维护成本
高(重复代码)
中高(服务器维护)
中(依赖管理)
中(服务器成本)
低(纯静态)
高(集成复杂度)
低(托管服务)
低(简单清晰)
中(新颖概念)
中(平台依赖)
低(技术简单)
中(浏览器兼容)


学习曲线
极低
中(服务器语言)
中高(框架概念)
高(服务端+客户端)
低
高(架构设计)
中
低
高(新范式)
中高
低
中


团队协作
适合小团队
前后端紧密协作
前后端分离
全栈团队
内容团队友好
多团队独立开发
前后端分离
设计+开发协作
需要新思维
DevOps要求高
传统团队友好
跨框架协作


适用规模
极小项目
中小型
中小到大型
中小到大型
中小型(内容型)
超大型(企业级)
中小型
内容为主网站
性能敏感应用
全球分布式应用
传统网站增强
跨框架组件


典型用例
简单展示页
传统企业网站
Web应用&amp;#x2F;后台管理
电商&amp;#x2F;社交平台
博客&amp;#x2F;文档站
大型SaaS平台
营销网站&amp;#x2F;博客
内容网站少量交互
电商&amp;#x2F;门户
全球应用&amp;#x2F;API网关
传统网站现代化
UI组件库


详细释义
核心架构类MPA - Multi-Page Application中文：多页面应用详细解释：

传统的Web应用架构，每个页面都是独立的HTML文件
用户每次导航都会从服务器加载新的完整页面
页面跳转时浏览器会完全刷新
示例：传统的PHP网站、Java JSP网站、早期企业官网

特点：
优点：

SEO友好（每个页面都有独立URL和完整内容）
首屏加载快（服务器直接返回HTML）
技术成熟，开发简单

缺点：

页面切换慢（需要重新加载整个页面）
用户体验差（有白屏等待时间）
代码重复率高（公共部分每个页面都要写）

SPA - Single-Page Application中文：单页面应用详细解释：

现代Web应用架构，整个应用只有一个HTML页面
通过JavaScript动态更新内容，无需重新加载页面
使用前端路由（如Vue Router、React Router）管理不同视图
示例：Gmail、Google Docs、现代后台管理系统

特点：
优点：

用户体验好（无刷新页面切换）
类似原生应用的流畅感
前后端完全分离

缺点：

SEO困难（初始HTML内容为空）
首屏加载慢（需要先下载所有JS）
对浏览器性能要求较高

CSR - Client-Side Rendering中文：客户端渲染详细解释：

在用户的浏览器中执行JavaScript来生成和渲染页面内容
服务器只提供初始的空HTML骨架和JavaScript文件
是SPA的主要渲染方式
与SSR相对

技术流程：

浏览器请求HTML（空壳）

下载并执行JavaScript

JavaScript请求数据（API）

用数据生成DOM并渲染


SSR - Server-Side Rendering中文：服务器端渲染详细解释：

在服务器上生成完整的HTML页面，然后发送给浏览器
浏览器接收到的是已经渲染好的内容
传统方式：PHP、JSP；现代方式：Next.js、Nuxt.js

分类：

传统SSR：PHP的include、JSP标签等
现代SSR：Node.js运行React&amp;#x2F;Vue代码生成HTML

优点：

SEO友好：搜索引擎直接看到完整内容
首屏快：用户立即看到内容，无需等待JS执行
低端设备友好：不依赖客户端JavaScript性能

SSG - Static Site Generation中文：静态站点生成详细解释：

在构建时（build time）预先生成所有HTML页面
生成的纯静态文件部署到CDN或服务器
示例：Hugo、Jekyll、VuePress、Gatsby

适用场景：

博客、文档网站、产品官网
内容不频繁变化的网站
对性能和安全要求极高的网站

技术特点：
构建时：源代码 → 构建工具 → 静态HTML&amp;#x2F;CSS&amp;#x2F;JS文件运行时：直接提供静态文件，无需服务器渲染
ISR - Incremental Static Regeneration中文：增量静态再生详细解释：

SSG的增强版本，支持增量更新
部分页面静态生成，部分页面动态生成或按需生成
典型实现：Next.js的getStaticProps + revalidate

工作流程：

首次访问：生成静态页面并缓存
后续访问：直接提供缓存的静态页面
定时更新：到达指定时间后重新生成
按需更新：内容变化时触发重新生成

</content>
    <url>/2026/01/29/Web%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F%E6%BC%94%E8%BF%9B%E4%B8%8E%E5%AF%B9%E6%AF%94/</url>
  </entry>
  <entry>
    <title>Untitled</title>
    <content>{}</content>
    <url>/package.json</url>
  </entry>
  <entry>
    <title>about</title>
    <content>



个人介绍你好！欢迎来看我的博客！
我的互联网通用名：Morlvoid（馒头白面）🫓
可以叫做mor、馍馍、momo，小摩。
程序员萌新，插画萌新，ACG爱好者，喜欢哲学，心理学，各方面都在学习中~本站不定期更新各种类型笔记。
博客：morlvoid.pro




本站指引🔗tag指引我码故存在——自我介绍
Hello, 赛博世界——程序相关日志&amp;#x2F;笔记
电绘人の自我修养——绘画相关
二周目ACG补完计划——ACG相关
脑内BUG实录——心理学与哲学
形而上学摸鱼指南——随笔&amp;#x2F;碎碎念
脑洞OC管理局——原创相关




📌左侧引导栏主页：文章内容
归档：时间抽
分类：文章分类
标签：tag成分
画作：叙事性插画作品集
友链：友情链接
关于：关于“我”的详细介绍




💻技术栈计算机技术UI设计、前端复现、Spring为主的Java后端开发、数据库与大数据、Python脚本与爬虫、Linux服务器等均有学习，擅长各种类型的网站相关开发，喜欢美术性强与高交互性的内容。
目前在学习：UI与UX与前端结合的高美术交互的网站开发。
开源项目保存在Github。
GitHub：Morlvoid




全栈项目展示🗃️自定义WIKI送给独立开发者的自定义游戏宣传页
DiyWiki




网页端项目请点击左侧“项目”查看





🎨插画2005年开始学习画画，2016年起开始板绘，2024年进入KK魔法学院正式以职业方向练习职业风格。
擅长二次元风格立绘、插画。
未来插画创作方向：专注于叙事性插画和与前端方向结合良好的SVG图画。
绘画作品请查看左侧：画作。个人作品集&amp;#x2F;个人原创绘本准备中……
一些里程碑：
为游戏绘制宣传图。
为网易云音乐人绘制专辑封面。
参与社团周边设计。
参与多个公司多个IP同人征集供稿。
【绘画学习笔记】
Pixiv：Morlvoid
触站：Morlvoid








其他爱好📔哲学&amp;#x2F;心理学喜欢看书，哲学、心理学、认知科学相关最多。
个人心得：【存在的天平】




🎊ACG老二次元人，喜欢各种类型的番剧、漫画，喜欢V家曲子，喜欢剧情类游戏。
自修过中国传媒大学动画设计专业。动画、动画电影、漫画、自媒体、虚拟主播都有接触。
【ACG基础知识补完计划】
MMD能够制作简单建模，制作MMD视频  [惯用ray渲]


喜欢和擅长料理和中医养生。
喜欢黑客，喜欢Tokameine老师。




🫧原创IP&amp;#x2F;独立游戏【原创虚拟IP主题站】
独立游戏计划中




其他链接🐙绮良个人站兴趣使然，为绮良学习了绘画、建模、MMD、动画，做了骰娘、个人站、公众号等等。


绮良个人站链接：
【Kirara的游戏城】
【Kirara主页】
绮良公众号：KiraraKira
绮良相关的绘画作品可以在P站或森空岛主页查看。
森空岛：Mor




🍱SSDS烘焙房——K大构成14.4班毕业展留给14.4班的同学做纪念，施工中……
【SSDS烘焙房】




联系方式Bilibil：Morlvoid




QQ：1524367770
欢迎交友！


</content>
    <url>/about/index.html</url>
  </entry>
  <entry>
    <title>categories</title>
    <content></content>
    <url>/categories/index.html</url>
  </entry>
  <entry>
    <title>friends</title>
    <content>欢迎交换友链！
格式：
网站名称：Morlvoid网站地址：https://www.morlvoid.pro/网站描述：事已至此，先睡觉吧。网站头像：https://img.cdn1.vip/i/68c5671deb8da_1757767453.webp



</content>
    <url>/friends/index.html</url>
  </entry>
  <entry>
    <title>项目</title>
    <content>这里是我的项目介绍~
自定义一周七日值日表网页应用-WeeklyDuty
部署地址：http://weekly-duty.morlvoid.pro
开源地址：https://github.com/Morlvoid/Custom-WeeklyDuty

年度绘画总结表格-MonthlyCanvas
部署地址：http://monthly.morlvoid.pro
开源地址：https://github.com/Morlvoid/MonthlyCanvas

带壳截图工具网页应用-Computer-case
部署地址：http://computer-case.morlvoid.pro
开源地址：https://github.com/Morlvoid/computer-case

</content>
    <url>/project/index.html</url>
  </entry>
  <entry>
    <title>Untitled</title>
    <content>// Live2D兼容性修复脚本
window.addEventListener(&apos;load&apos;, function() {
    // 监听Live2D加载事件
    const originalLog = console.log;
    console.log = function(...args) {
        if (args[0] &amp;&amp; args[0].includes(&apos;not supported mask count&apos;)) {
            console.warn(&apos;检测到遮罩兼容性问题，尝试修复...&apos;);
            attemptFix();
        }
        originalLog.apply(console, args);
    };

    function attemptFix() {
        // 延迟执行，确保Live2D完全加载
        setTimeout(() =&gt; {
            if (window.OhMyLive2D &amp;&amp; window.OhMyLive2D.instances.length &gt; 0) {
                const instance = window.OhMyLive2D.instances[0];

                // 尝试禁用高级渲染功能
                if (instance.model &amp;&amp; instance.model.coreModel) {
                    try {
                        // 强制设置简化模式
                        instance.model.forceSimplifiedRendering = true;
                        console.log(&apos;已启用简化渲染模式&apos;);
                    } catch (e) {
                        console.log(&apos;简化渲染设置失败:&apos;, e);
                    }
                }
            }
        }, 2000);
    }
});</content>
    <url>/js/live2d-fix.js</url>
  </entry>
  <entry>
    <title>Untitled</title>
    <content>{&quot;name&quot;:&quot;source&quot;,&quot;lockfileVersion&quot;:3,&quot;requires&quot;:true,&quot;packages&quot;:{}}</content>
    <url>/package-lock.json</url>
  </entry>
  <entry>
    <title>photos</title>
    <content></content>
    <url>/photos/index.html</url>
  </entry>
</search>